

дія виділити<Т>(кількість: позитивне): адреса<Т> {
  вернути пусто;
}
дія перевиділити<Т>(виділене: адреса<Т>, кількість: позитивне): адреса<Т> {
  вернути пусто;
}

секція лисиця {
  синонім памʼять = адреса; // памʼять це адреса, що вказує на якийсь елемент (зазвичай початок) послідовності
                            // існує щоб виразити масив, а не одну адресу
  синонім Ю8 = памʼять<п8>; // Ю8 це UTF-8 з нульовим завершенням
                            // використовуємо його лише під час читання файлу
  синонім Ю32 = памʼять<п32>; // Ю32 це UTF-32 з нульовим завершенням
                              // використовуємо саме його для зручності

  структура АСДМісцезнаходження;
  структура АСДІдентифікатор;
  структура АСДЕлемент;
  структура АСДДаніЕлементаІдентифікатор;
  структура АСДДаніЕлементаЧисло;
  структура АСДДаніЕлементаТекст;
  структура АСДДаніЕлементаІнструкція;

  структура АСДМісцезнаходження {
    рядок: позитивне;
    стовпець: позитивне;
  }

  структура АСДІдентифікатор {
    значення: Ю32;
    місцезнаходження: АСДМісцезнаходження;
  }

  синонім ВидАСДЕлементаІдентифікатор = 1;
  синонім ВидАСДЕлементаЧисло = 2;
  синонім ВидАСДЕлементаТекст = 3;
  синонім ВидАСДЕлементаІнстукція = 4;

  структура АСДЕлемент {
    вид: позитивне;
    дані: адреса<АСДДаніЕлементаІдентифікатор> | адреса<АСДДаніЕлементаЧисло> | адреса<АСДДаніЕлементаТекст> | адреса<АСДДаніЕлементаІнструкція>;
    місцезнаходження: АСДМісцезнаходження;
  }

  // приклад: а, привіт, імʼя, Щось, ЩОСЬ, Щ_О_С_Ь
  структура АСДДаніЕлементаІдентифікатор {
    ідентифікатор: адреса<АСДІдентифікатор>;
  }

  // приклад: 1, -2, 3.14
  структура АСДДаніЕлементаЧисло {
    значення: Ю32;
  }

  // приклад:"привіт"
  структура АСДДаніЕлементаТекст {
    значення: Ю32;
  }

  // приклад: (надрукувати "привіт")
  структура АСДДаніЕлементаІнструкція {
    ідентифікатор: адреса<АСДІдентифікатор>;
    кількість_аргументів: позитивне;
    аргументи: памʼять<адреса<АСДЕлемент>>;
  }

  структура РозібранаЛисиця {
    кількість_елементів: позитивне;
    елементи: памʼять<адреса<АСДЕлемент>>;
  }

  структура ПомилкаРозборуЛисиці {
    місцезнаходження: АСДМісцезнаходження;
    повідомлення: Ю8;
  }

  дія додати_елемент_до_розібраної_лисиці(адреса_на_розібрану_лисицю: адреса<РозібранаЛисиця>, елемент: адреса<АСДЕлемент>): позитивне {
    адреса_на_розібрану_лисицю.елементи = перевиділити<адреса<АСДЕлемент>>(адреса_на_розібрану_лисицю.елементи, адреса_на_розібрану_лисицю.кількість_елементів + 1);
    адреса_на_розібрану_лисицю.елементи[адреса_на_розібрану_лисицю.кількість_елементів] = елемент;
    адреса_на_розібрану_лисицю.кількість_елементів += 1;
    вернути адреса_на_розібрану_лисицю.кількість_елементів - 1;
  }

  дія розібрати_лисицю(адреса_на_розібрану_лисицю: адреса<РозібранаЛисиця>, адреса_на_помилку_розбору_лисиці: адреса<ПомилкаРозборуЛисиці>, значення: Ю32, довжина_значення: позитивне): логічне {
    вернути ні;
  }

  дія порахувати_довжину_ю8(значення: Ю8): позитивне {
    змінна ціль довжина: позитивне = 0;
    поки значення[довжина] != 0 {
      довжина = довжина + 1;
    }
    вернути довжина;
  }

  дія перекодувати_Ю8_в_Ю32(вхід: Ю8, довжина_входу: позитивне, адреса_на_вихід: адреса<Ю32>): позитивне {
    вернути 0;
  }
}

дія старт(): ц32 {
  ціль код_Ю8 = ю8"(надрукувати \"привіт\")";
  ціль довжина_коду_Ю8 = лисиця::порахувати_довжину_ю8(код_Ю8);
  змінна ціль код_Ю32: лисиця::Ю32 = пусто;
  ціль довжина_перекодованого_коду_Ю32 = лисиця::перекодувати_Ю8_в_Ю32(код_Ю8, довжина_коду_Ю8, код_Ю32::адреса);
  якщо довжина_перекодованого_коду_Ю32 == 0 {
    // ... обробити помилку
  }
  ціль розібрана_лисиця = лисиця::РозібранаЛисиця {
    кількість_елементів = 0,
    елементи = пусто,
  };
  ціль помилка_розбору_лисиці = лисиця::ПомилкаРозборуЛисиці { ... };
  ціль успіх_розбору = лисиця::розібрати_лисицю(
    розібрана_лисиця::адреса,
    помилка_розбору_лисиці::адреса,
    код_Ю32,
    довжина_перекодованого_коду_Ю32
  );
  якщо успіх_розбору {
    // ...
  } інакше {
    // ... надрукувати місцезнаходження помилки розбору і повідомлення
    //     після цього звільнити повідомлення помилки розбору
  }
  вернути 0;
}