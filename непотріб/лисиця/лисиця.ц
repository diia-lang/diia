дія виділити<Т>(кількість: п32): адреса<Т> {
  вернути пусто;
}
дія перевиділити<Т>(виділене: адреса<Т>, кількість: п32): адреса<Т> {
  вернути пусто;
}

секція лисиця {
  структура АСДМісцезнаходження;
  структура АСДІдентифікатор;
  структура АСДЕлемент;
  структура АСДДаніЕлементаІдентифікатор;
  структура АСДДаніЕлементаЧисло;
  структура АСДДаніЕлементаТекст;
  структура АСДДаніЕлементаІнструкція;

  синонім ВидАСДЕлементаІдентифікатор = 1;
  синонім ВидАСДЕлементаЧисло = 2;
  синонім ВидАСДЕлементаТекст = 3;
  синонім ВидАСДЕлементаІнстукція = 4;

  синонім памʼять = адреса; // памʼять це адреса, що вказує на якийсь елемент (зазвичай початок) послідовності
                            // існує щоб виразити масив, а не одну адресу
  синонім Ю8 = памʼять<п8>; // Ю8 це UTF-8 з нульовим завершенням
                            // використовуємо його лише під час читання файлу
  синонім Ю32 = памʼять<п32>; // Ю32 це UTF-32 з нульовим завершенням
                              // використовуємо саме його для зручності

  структура АСДМісцезнаходження {
    рядок: п32;
    стовпчик: п32;
  }

  структура АСДІдентифікатор {
    значення: Ю32;
    місцезнаходження: АСДМісцезнаходження;
  }

  структура АСДЕлемент {
    вид: п32;
    дані: адреса<АСДДаніЕлементаІдентифікатор> | адреса<АСДДаніЕлементаЧисло> | адреса<АСДДаніЕлементаТекст> | адреса<АСДДаніЕлементаІнструкція>;
    місцезнаходження: АСДМісцезнаходження;
  }

  // приклад: а, привіт, імʼя, Щось, ЩОСЬ, Щ_О_С_Ь
  структура АСДДаніЕлементаІдентифікатор {
    ідентифікатор: адреса<АСДІдентифікатор>;
  }

  // приклад: 1, -2, 3.14
  структура АСДДаніЕлементаЧисло {
    значення: Ю32;
  }

  // приклад:"привіт"
  структура АСДДаніЕлементаТекст {
    значення: Ю32;
  }

  // приклад: (надрукувати "привіт")
  структура АСДДаніЕлементаІнструкція {
    ідентифікатор: адреса<АСДІдентифікатор>;
    кількість_аргументів: п32;
    аргументи: памʼять<адреса<АСДЕлемент>>;
  }

  структура РозібранаЛисиця {
    кількість_елементів: п32;
    елементи: памʼять<адреса<АСДЕлемент>>;
  }

  структура ПомилкаРозборуЛисиці {
    місцезнаходження: АСДМісцезнаходження;
    повідомлення: Ю8;
  }

  дія додати_елемент_до_розібраної_лисиці(адреса_на_розібрану_лисицю: адреса<РозібранаЛисиця>, елемент: адреса<АСДЕлемент>): п32 {
    адреса_на_розібрану_лисицю.елементи = перевиділити<адреса<АСДЕлемент>>(адреса_на_розібрану_лисицю.елементи, адреса_на_розібрану_лисицю.кількість_елементів + 1);
    адреса_на_розібрану_лисицю.елементи[адреса_на_розібрану_лисицю.кількість_елементів] = елемент;
    адреса_на_розібрану_лисицю.кількість_елементів += 1;
    вернути адреса_на_розібрану_лисицю.кількість_елементів - 1;
  }

  дія розібрати_лисицю(адреса_на_розібрану_лисицю: адреса<РозібранаЛисиця>, адреса_на_помилку_розбору_лисиці: адреса<ПомилкаРозборуЛисиці>, значення: Ю8): логічне {
    вернути ні;
  }
}

дія старт(): ц32 {
  ціль розібрана_лисиця = лисиця::РозібранаЛисиця {
    кількість_елементів = 0,
    елементи = пусто,
  };
  ціль помилка_розбору_лисиці = лисиця::ПомилкаРозборуЛисиці { ... };
  ціль успіх_розбору = лисиця::розібрати_лисицю(
    розібрана_лисиця::адреса,
    помилка_розбору_лисиці::адреса,
    ю8"(надрукувати \"привіт\")"
  );
  якщо успіх_розбору {
    // ...
  } інакше {
    // ... надрукувати місцезнаходження помилки розбору і повідомлення
    //     після цього звільнити повідомлення помилки розбору
  }
  вернути 0;
}