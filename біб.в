зовнішня дія malloc(size: ц32): адреса;
зовнішня дія free(ptr: адреса);
зовнішня дія realloc(ptr: адреса, size: ц32): адреса;
зовнішня дія write(fd: ц32, buf: адреса, count: ц32): ц32;

синонім невідома_комірка = адреса;
синонім невідома_памʼять = адреса;
синонім комірка<Т> = адреса<Т>;
синонім памʼять<Т> = адреса<Т>;

дія виділити<Т>(): комірка<Т>;
дія виділити<Т>(кількість: ц32): памʼять<Т>;
дія перевиділити<Т>(значення: адреса<Т>, кількість: ц32): памʼять<Т>;
дія звільнити(значення: адреса);

дія виділити<Т>(): комірка<Т> {
  вернути malloc(Т::розмір) як комірка<Т>;
}

дія виділити<Т>(кількість: ц32): памʼять<Т> {
  вернути malloc(кількість * Т::розмір) як памʼять<Т>;
}

дія перевиділити<Т>(значення: адреса<Т>, кількість: ц32): памʼять<Т> {
  вернути realloc(значення, кількість * Т::розмір) як памʼять<Т>;
}

дія звільнити(значення: невідома_комірка) {
  free(значення);
}

синонім Ю8 = памʼять<п8>;
синонім Ю16 = памʼять<п16>;
синонім Ю32 = памʼять<п32>;


дія надрукувати_ю8(значення: Ю8) {
  змінна ціль х: позитивне = 0;
  поки (значення[х] != 0) {
    write(1, значення + х, 1);
    х = х + 1;
  }
  ціль нр = 10п8;
  write(1, нр::адреса, 1);
}

дія перетворити_п64_в_ю8(значення: п64): Ю8 {
  змінна ціль буфер = виділити<п8>(21);
  змінна ціль індекс: ц32 = 20;
  буфер[20] = 0;
  поки (значення > 0) {
    індекс = індекс - 1;
    буфер[індекс] = (значення % 10) як п8 + 48;
    значення = значення / 10;
  }
  якщо (індекс == 20) {
    індекс = індекс - 1;
    буфер[індекс] = 48;
  }
  ціль результуючий_буфер = виділити<п8>(21ц32 - індекс);
  змінна ціль х: ц32 = 0;
  поки (індекс < 21) {
    результуючий_буфер[х] = буфер[індекс];
    х = х + 1;
    індекс = індекс + 1;
  }
  звільнити(буфер);
  вернути результуючий_буфер;
}

дія перетворити_д64_в_ю8(значення: д64): Ю8 {
  вернути перетворити_п64_в_ю8(значення як п64); // потім: пофіксати
}

дія надрукувати_п64(значення: п64) {
  ціль п64ю8 = перетворити_п64_в_ю8(значення);
  надрукувати_ю8(п64ю8);
  звільнити(п64ю8);
}

дія надрукувати_д64(значення: д64) {
  ціль д64ю8 = перетворити_д64_в_ю8(значення);
  надрукувати_ю8(д64ю8);
  звільнити(д64ю8);
}

дія fmod(a: д64, b: д64): д64 {
  вернути a - (a / b) * b;
}

дія перевірити_чи_ю8_рівні(а: Ю8, б: Ю8): логічне {
  змінна ціль позиція: позитивне = 0;
  поки а[позиція] == б[позиція] {
    якщо а[позиція] == 0 {
      вернути так;
    }
    позиція = позиція + 1;
  }
  вернути ні;
}

дія виділити_копію_ю8(вихідна: Ю8): Ю8 {
  змінна ціль довжина: позитивне = 0;
  поки вихідна[довжина] != 0 {
    довжина = довжина + 1;
  }
  ціль копія = виділити<п8>(довжина як ц32 + 1);
  змінна ціль позиція: позитивне = 0;
  поки вихідна[позиція] != 0 {
    копія[позиція] = вихідна[позиція];
    позиція = позиція + 1;
  }
  копія[позиція] = 0;
  вернути копія;
}