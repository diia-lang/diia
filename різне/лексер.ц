зовнішня дія malloc(розмір: size_t): адреса;
зовнішня дія realloc(памʼять: адреса, розмір: size_t): адреса;
зовнішня дія free(памʼять: адреса);

дія виділити<Т>(): адреса<Т>;
дія виділити<Т>(кількість: позитивне): памʼять<Т>;
дія перевиділити<Т>(значення: памʼять<Т>, кількість: позитивне): памʼять<Т>;
дія звільнити(значення: адреса);

дія виділити<Т>(): адреса<Т> {
  вернути malloc(size_t(Т.розмір)) як адреса<Т>;
}

дія виділити<Т>(кількість: позитивне): памʼять<Т> {
  вернути malloc(size_t(кількість) * Т.розмір) як памʼять<Т>;
}

дія перевиділити<Т>(значення: памʼять<Т>, кількість: позитивне): памʼять<Т> {
  вернути realloc(значення як адреса, size_t(кількість) * Т.розмір) як памʼять<Т>;
}

дія звільнити(значення: адреса) {
  free(значення);
}

дія порахувати_розмір_Ю8(значення: памʼять<п8>): позитивне {
  змінна ціль довжина: позитивне = 0;
  поки значення[довжина] != 0 {
    довжина += 1;
  }
  вернути довжина;
}

дія порахувати_розмір_Ю32(значення: памʼять<п32>): позитивне {
  змінна ціль довжина: позитивне = 0;
  поки значення[довжина] != 0 {
    довжина += 1;
  }
  вернути довжина;
}

дія дізнатись_розмір_символа_юнікоду(перший_байт: п8): п8 {
  якщо (перший_байт & 128) == 0 {
    вернути 1;
  }
  якщо (перший_байт & 224) == 192 {
    вернути 2;
  }
  якщо (перший_байт & 240) == 224 {
    вернути 3;
  }
  якщо (перший_байт & 248) == 240 {
    вернути 4;
  }
  вернути 0;
}

дія перекодувати_Ю8_в_Ю32(вхід: памʼять<п8>, розмір_входу: позитивне, адреса_виходу: адреса<памʼять<п32>>): позитивне {
  змінна ціль вихід: памʼять<п32> = виділити<п32>(розмір_входу + 1);
  змінна ціль розмір_виходу: позитивне = 0;
  змінна ціль х: позитивне = 0;
  поки х < розмір_входу {
    ціль перший_байт = вхід[х];
    ціль розмір_символа = дізнатись_розмір_символа_юнікоду(перший_байт);
    якщо розмір_символа == 1 {
      вихід[розмір_виходу] = п32(перший_байт & 127);
      розмір_виходу = розмір_виходу + 1;
    }
    якщо розмір_символа == 2 {
      ціль другий_байт = вхід[х + 1];
      вихід[розмір_виходу] = (п32(перший_байт & 31) << 6) | п32(другий_байт & 63);
      розмір_виходу = розмір_виходу + 1;
      х = х + 1;
    }
    якщо розмір_символа == 3 {
      ціль другий_байт = вхід[х + 1];
      ціль третій_байт = вхід[х + 2];
      вихід[розмір_виходу] = (п32(перший_байт & 15) << 12) | (п32(другий_байт & 63) << 6) | п32(третій_байт & 63);
      розмір_виходу = розмір_виходу + 1;
      х = х + 2;
    }
    якщо розмір_символа == 4 {
      ціль другий_байт = вхід[х + 1];
      ціль третій_байт = вхід[х + 2];
      ціль четвертий_байт = вхід[х + 3];
      вихід[розмір_виходу] = (п32(перший_байт & 15) << 18) | (п32(другий_байт & 63) << 12) | (п32(третій_байт & 63) << 6) | п32(четвертий_байт & 63);
      розмір_виходу = розмір_виходу + 1;
      х = х + 3;
    }
    х = х + 1;
  }
  вихід[розмір_виходу] = 0;
  вихід = перевиділити<п32>(вихід, розмір_виходу + 1);
  адреса_виходу::вміст = вихід;
  вернути розмір_виходу;
}

секція UNICODE {
  синонім NEWLINE = 10;
  синонім CARRIAGE_RETURN = 13;
  синонім SPACE = 32;
  синонім OPEN_PARENTHESIS = 40;
  синонім CLOSE_PARENTHESIS = 41;
  синонім ASTERISK = 42;
  синонім PLUS = 43;
  синонім COLON = 58;
  синонім SEMICOLON = 59;
  синонім QUESTION_MARK = 63;
  синонім OPEN_CURLY_BRACKET = 123;
  синонім LINE = 124;
  синонім CLOSE_CURLY_BRACKET = 125;
}

секція Г {
  секція лексер {
    структура Місцезнаходження {
      рядок_початку: позитивне;
      стовпець_початку: позитивне;
      рядок_кінця: позитивне;
      стовпець_кінця: позитивне;
    }

    перелік Лексема {
      КлючовеСловоЛексика { місцезнаходження: адреса<Місцезнаходження> },
      КлючовеСловоГраматика { місцезнаходження: адреса<Місцезнаходження> },
      КлючовеСловоФаргмент { місцезнаходження: адреса<Місцезнаходження> },
      ВідкритаДужка { місцезнаходження: адреса<Місцезнаходження> },
      ЗакритаДужка { місцезнаходження: адреса<Місцезнаходження> },
      Зірочка { місцезнаходження: адреса<Місцезнаходження> },
      Плюс { місцезнаходження: адреса<Місцезнаходження> },
      Двокрапка { місцезнаходження: адреса<Місцезнаходження> },
      Крапкакома { місцезнаходження: адреса<Місцезнаходження> },
      ЗнакПитання { місцезнаходження: адреса<Місцезнаходження> },
      ВідкритаФігурнаДужка { місцезнаходження: адреса<Місцезнаходження> },
      Пряма { місцезнаходження: адреса<Місцезнаходження> },
      ЗакритаФігурнаДужка { місцезнаходження: адреса<Місцезнаходження> },
      Ідентифікатор { значення: памʼять<п32>; місцезнаходження: адреса<Місцезнаходження> },
      Текст { значення: памʼять<п32>; місцезнаходження: адреса<Місцезнаходження> },
    }

    структура РозібранаЛексика {
      кількість_лексем: позитивне;
      лексеми: памʼять<Лексема>;
    }

    дія перевірити_ключове_слово(значення: памʼять<п32>, позиція_початку: позитивне, шукане_значення: памʼять<п8>): логічне {
      змінна ціль розмір_шуканого_значення = порахувати_розмір_Ю8(шукане_значення);
      ціль шукане_значення_Ю32 = виділити<п32>(розмір_шуканого_значення + 1);
      розмір_шуканого_значення = перекодувати_Ю8_в_Ю32(шукане_значення, розмір_шуканого_значення, шукане_значення_Ю32::адреса);
      шукане_значення_Ю32[розмір_шуканого_значення] = 0;
      змінна ціль п: позитивне = 0;
      поки шукане_значення[п] != 0 {
        якщо значення[позиція_початку + п] != шукане_значення_Ю32[п] {
          звільнити(шукане_значення_Ю32 як адреса);
          вернути ні;
        }
        п += 1;
      }
      звільнити(шукане_значення_Ю32 як адреса);
      вернути так;
    }

    дія розібрати(значення: памʼять<п32>, вихід: адреса<адреса<РозібранаЛексика>>): позитивне {
      ціль розібрана_лексика = виділити<РозібранаЛексика>();
      змінна ціль п: позитивне = 0;
      далі:
      ціль символ = значення[п];
      якщо символ == 0 {
        стрибнути стоп;
      }
      якщо символ == UNICODE::NEWLINE {
        п += 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::CARRIAGE_RETURN {
        п += 1;
        стрибнути далі;
      }
      якщо символ == UNICODE::SPACE {
        п += 1;
        стрибнути далі;
      }
      якщо перевірити_ключове_слово(значення, п, ю8"лексика") {
        ціль лексема = Лексема::КлючовеСловоЛексика { пусто };
        розібрана_лексика.лексеми = перевиділити<Лексема>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 6;
        стрибнути далі;
      }
      якщо перевірити_ключове_слово(значення, п, ю8"граматика") {
        ціль лексема = Лексема::КлючовеСловоГраматика { пусто };
        розібрана_лексика.лексеми = перевиділити<Лексема>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 6;
        стрибнути далі;
      }
      якщо перевірити_ключове_слово(значення, п, ю8"фрагмент") {
        ціль лексема = Лексема::КлючовеСловоФаргмент { пусто };
        розібрана_лексика.лексеми = перевиділити<Лексема>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 6;
        стрибнути далі;
      }
      якщо символ == UNICODE::OPEN_PARENTHESIS {
        ціль лексема = Лексема::ВідкритаДужка { пусто };
        розібрана_лексика.лексеми = перевиділити<Лексема>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
      }
      якщо символ == UNICODE::CLOSE_PARENTHESIS {
        ціль лексема = Лексема::ЗакритаДужка { пусто };
        розібрана_лексика.лексеми = перевиділити<Лексема>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
      }
      якщо символ == UNICODE::ASTERISK {
        ціль лексема = Лексема::Зірочка { пусто };
        розібрана_лексика.лексеми = перевиділити<Лексема>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
      }
      якщо символ == UNICODE::PLUS {
        ціль лексема = Лексема::Плюс { пусто };
        розібрана_лексика.лексеми = перевиділити<Лексема>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
      }
      якщо символ == UNICODE::COLON {
        ціль лексема = Лексема::Двокрапка { пусто };
        розібрана_лексика.лексеми = перевиділити<Лексема>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
      }
      якщо символ == UNICODE::SEMICOLON {
        ціль лексема = Лексема::Крапкакома { пусто };
        розібрана_лексика.лексеми = перевиділити<Лексема>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
      }
      якщо символ == UNICODE::QUESTION_MARK {
        ціль лексема = Лексема::ЗнакПитання { пусто };
        розібрана_лексика.лексеми = перевиділити<Лексема>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
      }
      якщо символ == UNICODE::OPEN_CURLY_BRACKET {
        ціль лексема = Лексема::ВідкритаФігурнаДужка { пусто };
        розібрана_лексика.лексеми = перевиділити<Лексема>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
      }
      якщо символ == UNICODE::LINE {
        ціль лексема = Лексема::Пряма { пусто };
        розібрана_лексика.лексеми = перевиділити<Лексема>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
      }
      якщо символ == UNICODE::CLOSE_CURLY_BRACKET {
        ціль лексема = Лексема::ЗакритаФігурнаДужка { пусто };
        розібрана_лексика.лексеми = перевиділити<Лексема>(розібрана_лексика.лексеми, розібрана_лексика.кількість_лексем + 1);
        розібрана_лексика.лексеми[розібрана_лексика.кількість_лексем] = лексема;
        розібрана_лексика.кількість_лексем += 1;
        п += 1;
      }
      // ...
      стоп:
      вихід::вміст = розібрана_лексика;
    }
  }
}