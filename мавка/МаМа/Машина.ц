взяти визначення МаМа;

зовнішня дія математика_abs(значення: дійсне): дійсне;
зовнішня дія математика_acos(значення: дійсне): дійсне;
зовнішня дія математика_asin(значення: дійсне): дійсне;
зовнішня дія математика_atan(значення: дійсне): дійсне;
зовнішня дія математика_atan2(а: дійсне, б: дійсне): дійсне;
зовнішня дія математика_cos(значення: дійсне): дійсне;
зовнішня дія математика_sin(значення: дійсне): дійсне;
зовнішня дія математика_tan(значення: дійсне): дійсне;
зовнішня дія математика_cosh(значення: дійсне): дійсне;
зовнішня дія математика_sinh(значення: дійсне): дійсне;
зовнішня дія математика_tanh(значення: дійсне): дійсне;
зовнішня дія математика_exp(значення: дійсне): дійсне;
зовнішня дія математика_log(значення: дійсне): дійсне;
зовнішня дія математика_log10(значення: дійсне): дійсне;
зовнішня дія математика_pow(а: дійсне, б: дійсне): дійсне;
зовнішня дія математика_sqrt(значення: дійсне): дійсне;
зовнішня дія математика_ceil(значення: дійсне): дійсне;
зовнішня дія математика_floor(значення: дійсне): дійсне;
зовнішня дія математика_round(значення: дійсне): дійсне;

секція мама {
  місцева дія створити_машину(шлях_до_папки_запуску: памʼять<п8>): комірка<Машина> {
    ціль М = виділити<Машина>();
    М.шлях_до_папки_запуску = шлях_до_папки_запуску;
    М.слова = створити_вектор<комірка<Слово>>();
    М.база_слів = БазаСлів {
      довжина = отримати_або_створити_слово(М, ю8"довжина"),
      розмір = отримати_або_створити_слово(М, ю8"розмір"),
      назва = отримати_або_створити_слово(М, ю8"назва"),
    };
    М.стопка = створити_вектор<Значення>();
    М.утилізатор = створити_утилізатор(М, помаркувати);
    М.глобальне_середовище = створити_середовище(М, пусто);
    М.сліди = створити_вектор<Слід>();
    М.існуючі_обʼєкти = створити_вектор<комірка<Обʼєкт>>();
    М.взяті_модулі = створити_вектор<комірка<ВзятийМодуль>>();
    М.кореневий_взятий_модуль = пусто;
    М.взяти_біб = пусто;
    М.структура_обʼєкт = створити_структуру_обʼєкт(М);
    змінити_субʼєкт_в_середовищі(М.глобальне_середовище, отримати_або_створити_слово(М, ю8"обʼєкт"), Значення { ЗОбʼєкт, дані = М.структура_обʼєкт });
    М.структура_структура = створити_структуру_структура(М);
    М.структура_структура.с = М.структура_структура;
    М.структура_обʼєкт.с = пусто;
    М.структура_обʼєкт.структура_предок = пусто;
    змінити_субʼєкт_в_середовищі(М.глобальне_середовище, отримати_або_створити_слово(М, ю8"Структура"), Значення { ЗОбʼєкт, дані = М.структура_структура });
    М.структура_дія = створити_структуру_дія(М);
    змінити_субʼєкт_в_середовищі(М.глобальне_середовище, отримати_або_створити_слово(М, ю8"Дія"), Значення { ЗОбʼєкт, дані = М.структура_дія });
    М.структура_число = створити_структуру_число(М);
    змінити_субʼєкт_в_середовищі(М.глобальне_середовище, отримати_або_створити_слово(М, ю8"число"), Значення { ЗОбʼєкт, дані = М.структура_число });
    М.структура_логічне = створити_структуру_логічне(М);
    змінити_субʼєкт_в_середовищі(М.глобальне_середовище, отримати_або_створити_слово(М, ю8"логічне"), Значення { ЗОбʼєкт, дані = М.структура_логічне });
    М.структура_символ = створити_структуру_символ(М);
    змінити_субʼєкт_в_середовищі(М.глобальне_середовище, отримати_або_створити_слово(М, ю8"символ"), Значення { ЗОбʼєкт, дані = М.структура_символ });
    М.структура_текст = створити_структуру_текст(М);
    змінити_субʼєкт_в_середовищі(М.глобальне_середовище, отримати_або_створити_слово(М, ю8"текст"), Значення { ЗОбʼєкт, дані = М.структура_текст });
    М.структура_помилка = створити_структуру_помилка(М);
    змінити_субʼєкт_в_середовищі(М.глобальне_середовище, отримати_або_створити_слово(М, ю8"Помилка"), Значення { ЗОбʼєкт, дані = М.структура_помилка });
    М.структура_перебір = створити_структуру_перебір(М);
    змінити_субʼєкт_в_середовищі(М.глобальне_середовище, отримати_або_створити_слово(М, ю8"перебір"), Значення { ЗОбʼєкт, дані = М.структура_перебір });
    М.структура_список = створити_структуру_список(М);
    змінити_субʼєкт_в_середовищі(М.глобальне_середовище, отримати_або_створити_слово(М, ю8"список"), Значення { ЗОбʼєкт, дані = М.структура_список });
    М.структура_словник = створити_структуру_словник(М);
    змінити_субʼєкт_в_середовищі(М.глобальне_середовище, отримати_або_створити_слово(М, ю8"словник"), Значення { ЗОбʼєкт, дані = М.структура_словник });
    М.структура_модуль = створити_структуру_модуль(М);
    змінити_субʼєкт_в_середовищі(М.глобальне_середовище, отримати_або_створити_слово(М, ю8"модуль"), Значення { ЗОбʼєкт, дані = М.структура_модуль });
    М.мавкаРМв1 = створити_мавкуРМв1(М);
    М.взятіРМв1 = створити_карту<комірка<Слово>, комірка<Обʼєкт>>(порівняти_слова);
    М.інформація_бібліотеки_мавки = пусто;
    М.взяті_модулі_бібліотеки_мавки = створити_карту<комірка<Слово>, комірка<Обʼєкт>>(порівняти_слова);
    вернути М;
  }

  місцева дія сортувати_вектор_значень_мама(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, вектор_значень: комірка<вектор<Значення>>, значення_дії_порівняння: Значення): Результат {
    змінна х = 0;
    поки х < вектор_значень.довжина {
      змінна у = х + 1;
      поки у < вектор_значень.довжина {
        покласти_на_стопку(М, вектор_значень.дані[х]);
        покласти_на_стопку(М, вектор_значень.дані[у]);
        ціль результат_дії_порівняння = машина_виконати_дію(М, місцезнаходження, значення_дії_порівняння, 2);
        якщо результат_дії_порівняння.успіх == 0 {
          вернути результат_дії_порівняння;
        }
        ціль результат_чи_більше = машина_порівняти_чи_більше(М, місцезнаходження, результат_дії_порівняння.значення, Значення { ЗЧисло, дані = 0.0 як дійсне });
        якщо результат_чи_більше.успіх == 0 {
          вернути результат_чи_більше;
        }
        якщо результат_чи_більше.значення.тип == ЗТак {
          змінна тимчасова = вектор_значень.дані[х];
          вектор_значень.дані[х] = вектор_значень.дані[у];
          вектор_значень.дані[у] = тимчасова;
        }
        у = у + 1;
      }
      х = х + 1;
    }
    вернути Результат { так, Значення { ЗПусто } };
  }

  місцева дія завантажити_бібліотеку_мавки(М: комірка<Машина>): позитивне {
    якщо М.інформація_бібліотеки_мавки != пусто {
      вернути 0;
    }
    ціль інформація_бібліотеки_мавки = завантажити_інформацію_бібліотеки_мавки(М);
    М.інформація_бібліотеки_мавки = інформація_бібліотеки_мавки;
    вернути 1;
  }

  місцева дія покласти_на_стопку(М: комірка<Машина>, значення: Значення) {
    додати_до_вектору<Значення>(М.стопка, значення);
  }

  місцева дія забрати_зі_стопки(М: комірка<Машина>): Значення {
    якщо  М.стопка.довжина == 0 {
      вернути Значення { ЗПусто };
    }
    ціль значення = М.стопка.дані[М.стопка.довжина - 1];
    М.стопка.довжина = М.стопка.довжина - 1;
    вернути значення;
  }

  місцева дія порівняти_слова(к1: комірка<Слово>, к2: комірка<Слово>): ціле {
    якщо к1 == к2 {
      вернути 1;
    }
    вернути 0;
  }

  дія порівняти_ю32(з1: памʼять<п32>, з2: памʼять<п32>): позитивне {
    змінна х = 0;
    поки з1[х] != 0 {
      якщо з1[х] != з2[х] {
        вернути 0;
      }
      х = х + 1;
    }
    якщо з2[х] != 0 {
      вернути 0;
    }
    вернути 1;
  }

  місцева дія порівняти_значення(к1: Значення, к2: Значення): ціле {
    якщо к1.тип == ЗПусто {
      якщо к2.тип == ЗПусто {
        вернути 1;
      }
      вернути 0;
    }
    якщо к1.тип == ЗТак {
      якщо к2.тип == ЗТак {
        вернути 1;
      }
      вернути 0;
    }
    якщо к1.тип == ЗНі {
      якщо к2.тип == ЗНі {
        вернути 1;
      }
      вернути 0;
    }
    якщо к1.тип == ЗЧисло {
      якщо к2.тип == ЗЧисло {
        якщо (к1.дані як дійсне) == (к2.дані як дійсне) {
          вернути 1;
        }
      }
      вернути 0;
    }
    якщо к1.тип == ЗСимвол {
      якщо к2.тип == ЗСимвол {
        якщо (к1.дані як п32) == (к2.дані як п32) {
          вернути 1;
        }
      }
      вернути 0;
    }
    якщо к1.тип == ЗОбʼєкт {
      якщо к2.тип == ЗОбʼєкт {
        якщо (к1.дані як комірка<Обʼєкт>) == (к2.дані як комірка<Обʼєкт>) {
          вернути 1;
        }
        якщо (к1.дані як комірка<Обʼєкт>).тип == ОТекст {
          якщо (к2.дані як комірка<Обʼєкт>).тип == ОТекст {
            якщо (к1.дані як комірка<Обʼєкт>).текст_довжина == (к2.дані як комірка<Обʼєкт>).текст_довжина {
              якщо порівняти_ю32((к1.дані як комірка<Обʼєкт>).текст_значення, (к2.дані як комірка<Обʼєкт>).текст_значення) != 0 {
                вернути 1;
              }
            }
          }
        }
      }
      вернути 0;
    }
    вернути 0;
  }

  місцева дія зробити_безсмертним(М: комірка<Машина>, обʼєкт: комірка<Обʼєкт>): комірка<Обʼєкт> {
    обʼєкт.безсмертний = 1;
    додати_до_вектору<комірка<Обʼєкт>>(М.існуючі_обʼєкти, обʼєкт);
    М.утилізатор.кількість_безсмертних_обʼєктів = М.утилізатор.кількість_безсмертних_обʼєктів + 1;
    вернути обʼєкт;
  }

  місцева дія додати_обʼєкт_до_існуючих(М: комірка<Машина>, обʼєкт: комірка<Обʼєкт>) {
    додати_до_вектору<комірка<Обʼєкт>>(М.існуючі_обʼєкти, обʼєкт);
  }

  місцева дія додати_вказівку(М: комірка<Машина>, код: комірка<вектор<Вказівка>>, вказівка: Вказівка) {
    додати_до_вектору<Вказівка>(код, вказівка);
  }

  місцева дія додати_слід(М: комірка<Машина>, слід: Слід) {
    додати_до_вектору<Слід>(М.сліди, слід);
  }

  місцева дія видалити_останній_слід(М: комірка<Машина>) {
    М.сліди.довжина = М.сліди.довжина - 1;
  }

  місцева дія отримати_взятий_модуль_з_середовища(середовище: комірка<Середовище>): комірка<ВзятийМодуль> {
    якщо середовище.обʼєкт_модуля != пусто {
      якщо середовище.обʼєкт_модуля.модуль_взятий_модуль != пусто {
        вернути середовище.обʼєкт_модуля.модуль_взятий_модуль;
      }
    }
    якщо середовище.зовнішнє != пусто {
      вернути отримати_взятий_модуль_з_середовища(середовище.зовнішнє);
    }
    вернути пусто;
  }

  місцева дія знайти_взятий_модуль(М: комірка<Машина>, слово_шляху: комірка<Слово>): комірка<ВзятийМодуль> {
    змінна х = 0;
    поки х < М.взяті_модулі.довжина {
      ціль взятий_модуль = М.взяті_модулі.дані[х];
      якщо взятий_модуль.слово_шляху == слово_шляху {
        вернути взятий_модуль;
      }
      х = х + 1;
    }
    вернути пусто;
  }

  місцева дія додати_взятий_модуль(М: комірка<Машина>, взятий_модуль: комірка<ВзятийМодуль>) {
    додати_до_вектору<комірка<ВзятийМодуль>>(М.взяті_модулі, взятий_модуль);
  }

  місцева дія взяти_модуль_за_шляхом(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, батьківський_взятий_модуль: комірка<ВзятийМодуль>, шлях: памʼять<п8>): Результат {
    ціль нормалізований_шлях = нормалізувати_шлях(шлях);
    ціль слово_шляху = отримати_або_створити_слово(М, нормалізований_шлях);
    ціль існуючий_взятий_модуль = знайти_взятий_модуль(М, слово_шляху);
    якщо існуючий_взятий_модуль != пусто {
      звільнити(нормалізований_шлях);
      вернути результат_значення(Значення { ЗОбʼєкт, дані = існуючий_взятий_модуль.обʼєкт_модуля });
    }
//    біб::вивести_ю8(ю8"беремо ");
//    біб::друк_ю8(нормалізований_шлях);
    ціль текст_коду = виділити<ТекстКоду>();
    текст_коду.шлях = нормалізований_шлях;
    текст_коду.значення = прочитати_файл(нормалізований_шлях);
    якщо текст_коду.значення == пусто {
      вернути результат_помилка_обʼєкт(створити_помилку_П9_не_вдалось_прочитати_файл(М, місцезнаходження, нормалізований_шлях));
    }
    ціль результат_розбору = розібрати_мавку(текст_коду);
    якщо результат_розбору.успіх == 0 {
      вернути результат_помилка_обʼєкт(створити_обʼєкт_помилка(М, результат_розбору.помилка.місцезнаходження, результат_розбору.помилка.повідомлення));
    }
    ціль код_тіла = створити_вектор<Вказівка>();
    ціль результат_компіляції = мама::скомпілювати_тіло(М, пусто, код_тіла, результат_розбору.тіло);
    якщо результат_компіляції.успіх == 0 {
      звільнити_вектор<Вказівка>(код_тіла);
      вернути результат_помилка_обʼєкт(створити_обʼєкт_помилка(М, результат_компіляції.помилка.місцезнаходження, результат_компіляції.помилка.повідомлення));
    }
    ціль взятий_модуль = виділити<ВзятийМодуль>();
    якщо батьківський_взятий_модуль == пусто {
      взятий_модуль.кореневий_взятий_модуль = взятий_модуль;
    } інакше {
      взятий_модуль.кореневий_взятий_модуль = батьківський_взятий_модуль.кореневий_взятий_модуль;
    }
    якщо М.кореневий_взятий_модуль == пусто {
      М.кореневий_взятий_модуль = взятий_модуль;
    }
    взятий_модуль.слово_шляху = слово_шляху;
    додати_взятий_модуль(М, взятий_модуль);
    ціль обʼєкт_модуля = зробити_безсмертним(М, створити_обʼєкт(М, ОМодуль));
    взятий_модуль.обʼєкт_модуля = обʼєкт_модуля;
    обʼєкт_модуля.с = М.структура_модуль;
    обʼєкт_модуля.модуль_слово = отримати_або_створити_слово(М, отримати_назву_файлу_без_розширення(слово_шляху.назва));
    обʼєкт_модуля.модуль_взятий_модуль = взятий_модуль;
    ціль середовище = створити_середовище(М, М.глобальне_середовище);
    середовище.обʼєкт_модуля = обʼєкт_модуля;
    ціль слово_я = отримати_або_створити_слово(М, ю8"я");
    змінити_субʼєкт_в_середовищі(середовище, слово_я, Значення { ЗОбʼєкт, дані = обʼєкт_модуля });
    додати_слід(М, Слід { місцезнаходження, середовище, обʼєкт_дії = пусто, обʼєкт_модуля = обʼєкт_модуля });
    ціль результат = запустити(М, код_тіла, середовище);
    якщо результат.успіх == 0 {
      вернути результат;
    }
    видалити_останній_слід(М);
    вернути результат_значення(Значення { ЗОбʼєкт, дані = обʼєкт_модуля });
  }

  структура РезультатОбробленняСпроби {
    вп: позитивне;
    результат: Результат;
  }

  дія обробити_спроби(М: комірка<Машина>, середовище: комірка<Середовище>, вп: позитивне, спроби: комірка<вектор<Спроба>>, значення_помилки: Значення): позитивне {
    якщо спроби == пусто {
      вернути вп;
    }
    якщо спроби.довжина == 0 {
      звільнити_вектор<Спроба>(спроби);
      вернути вп;
    }
    ціль спроба = спроби.дані[спроби.довжина - 1];
    спроби.довжина = спроби.довжина - 1;
    М.сліди.довжина = спроба.довжина_слідів;
    якщо спроба.слово != пусто {
      змінити_субʼєкт_в_середовищі(
        середовище,
        спроба.слово,
        значення_помилки
      );
    }
    вернути спроба.позиція;
  }

  місцева дія запустити(М: комірка<Машина>, вказівки: комірка<вектор<Вказівка>>, середовище: комірка<Середовище>): Результат {
    змінна вп = 0;
    змінна спроби: комірка<вектор<Спроба>> = пусто;
    поки вп < вказівки.довжина {
      ціль вказівка = вказівки.дані[вп];
//      друк_вказівка(вказівка);
      якщо (М.утилізатор.кількість_обʼєктів - М.утилізатор.кількість_безсмертних_обʼєктів) >= М.утилізатор.кількість_обʼєктів_щоб_запустити_утилізацію {
        утилізувати(М);
      }
      якщо М.утилізатор.кількість_середовищ >= М.утилізатор.кількість_середовищ_щоб_запустити_утилізацію {
        утилізувати(М);
      }
      якщо вказівка.тип == ВСтворитиПусто {
        покласти_на_стопку(М, Значення { ЗПусто });
      } інакше якщо вказівка.тип == ВСтворитиТак {
        покласти_на_стопку(М, Значення { ЗТак });
      } інакше якщо вказівка.тип == ВСтворитиНі {
        покласти_на_стопку(М, Значення { ЗНі });
      } інакше якщо вказівка.тип == ВСтворитиЧисло {
        покласти_на_стопку(М, Значення { ЗЧисло, дані = вказівка.дані як дійсне });
      } інакше якщо вказівка.тип == ВСтворитиСимвол {
        покласти_на_стопку(М, Значення { ЗСимвол, дані = вказівка.дані як п32 });
      } інакше якщо вказівка.тип == ВСтворитиСлово {
        покласти_на_стопку(М, Значення { ЗСлово, дані = вказівка.дані як комірка<Слово> });
      } інакше якщо вказівка.тип == ВПокластиОбʼєкт {
        покласти_на_стопку(М, Значення { ЗОбʼєкт, дані = вказівка.дані як комірка<Обʼєкт> });
      } інакше якщо вказівка.тип == ВПокластиСтруктуруОбʼєкт {
        покласти_на_стопку(М, Значення { ЗОбʼєкт, дані = М.структура_обʼєкт });
      } інакше якщо вказівка.тип == ВЗабрати {
        забрати_зі_стопки(М);
      } інакше якщо вказівка.тип == ВВизначитиСубʼєкт {
        ціль значення = забрати_зі_стопки(М);
        ціль слово_назви = вказівка.дані як комірка<Слово>;
        ціль результат = машина_визначити_субʼєкт(М, вказівка.місцезнаходження, середовище, слово_назви, значення);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        }
      } інакше якщо вказівка.тип == ВЗвернутисьДоСубʼєкта {
        ціль слово_назви = вказівка.дані як комірка<Слово>;
        ціль результат = машина_звернутись_до_субʼєкта(М, вказівка.місцезнаходження, середовище, слово_назви);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВОтриматиВластивість {
        ціль а = забрати_зі_стопки(М);
        ціль слово_назви = вказівка.дані як комірка<Слово>;
        ціль результат = машина_отримати_властивість(М, вказівка.місцезнаходження, а, слово_назви);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВЗмінитиВластивість {
        ціль значення = забрати_зі_стопки(М);
        ціль а = забрати_зі_стопки(М);
        ціль слово_назви = вказівка.дані як комірка<Слово>;
        ціль результат = машина_змінити_властивість(М, вказівка.місцезнаходження, а, слово_назви, значення);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        }
      } інакше якщо вказівка.тип == ВОтриматиЕлемент {
        ціль значення_ключа = забрати_зі_стопки(М);
        ціль а = забрати_зі_стопки(М);
        ціль результат = машина_отримати_елемент(М, вказівка.місцезнаходження, а, значення_ключа);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВПокластиЕлемент {
        ціль значення = забрати_зі_стопки(М);
        ціль значення_ключа = забрати_зі_стопки(М);
        ціль а = забрати_зі_стопки(М);
        ціль результат = машина_покласти_елемент(М, вказівка.місцезнаходження, а, значення_ключа, значення);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        }
      } інакше якщо вказівка.тип == ВСтворитиСтруктуру {
        ціль значення_предка = забрати_зі_стопки(М);
        якщо значення_предка.тип != ЗОбʼєкт {
          вернути результат_помилка_обʼєкт(створити_помилку_П10_обʼєкт_наслідування_повинен_бути_структурою(М, вказівка.місцезнаходження, значення_предка));
        }
        ціль слово_назви = вказівка.дані як комірка<Слово>;
        ціль результат = машина_створити_структуру(М, вказівка.місцезнаходження, середовище, слово_назви, значення_предка.дані як комірка<Обʼєкт>);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВЗберегтиПараметрСтруктури {
        ціль значення_за_замовчуванням = забрати_зі_стопки(М);
        ціль значення_типу = забрати_зі_стопки(М);
        ціль значення_структури = забрати_зі_стопки(М);
        покласти_на_стопку(М, значення_структури);
        якщо значення_типу.тип != ЗОбʼєкт {
          вернути результат_помилка_обʼєкт(створити_помилку_П11_тип_параметра_повинен_бути_структурою(М, вказівка.місцезнаходження, значення_типу));
        }
        ціль дані_вказівки = вказівка.дані як комірка<ДаніВказівкиЗберегтиПараметрСтруктури>;
        ціль результат = машина_зберегти_параметр_структури(М, вказівка.місцезнаходження, значення_структури.дані як комірка<Обʼєкт>, дані_вказівки.позиція, дані_вказівки.слово_назви, значення_типу.дані як комірка<Обʼєкт>, дані_вказівки.тип_може_бути_пусто, дані_вказівки.має_значення_за_замовчуванням, значення_за_замовчуванням);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        }
      } інакше якщо вказівка.тип == ВСтворитиДію {
        ціль значення_типу_повернення = забрати_зі_стопки(М);
        якщо значення_типу_повернення.тип != ЗОбʼєкт {
          вернути результат_помилка_обʼєкт(створити_помилку_П12_тип_повернення_повинен_бути_структурою(М, вказівка.місцезнаходження, значення_типу_повернення));
        }
        ціль дані_вказівки = вказівка.дані як комірка<ДаніВказівкиСтворитиДію>;
        ціль результат = машина_створити_дію(М, вказівка.місцезнаходження, середовище, дані_вказівки.слово_назви, дані_вказівки.код_тіла, значення_типу_повернення.дані як комірка<Обʼєкт>, дані_вказівки.тип_повернення_може_бути_пусто);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВЗберегтиПараметрДії {
        ціль значення_за_замовчуванням = забрати_зі_стопки(М);
        ціль значення_типу = забрати_зі_стопки(М);
        ціль значення_дії = забрати_зі_стопки(М);
        покласти_на_стопку(М, значення_дії);
        якщо значення_типу.тип != ЗОбʼєкт {
          вернути результат_помилка_обʼєкт(створити_помилку_П11_тип_параметра_повинен_бути_структурою(М, вказівка.місцезнаходження, значення_типу));
        }
        ціль дані_вказівки = вказівка.дані як комірка<ДаніВказівкиЗберегтиПараметрДії>;
        ціль результат = машина_зберегти_параметр_дії(М, вказівка.місцезнаходження, значення_дії.дані як комірка<Обʼєкт>, дані_вказівки.позиція, дані_вказівки.слово_назви, значення_типу.дані як комірка<Обʼєкт>, дані_вказівки.тип_може_бути_пусто, дані_вказівки.має_значення_за_замовчуванням, значення_за_замовчуванням);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        }
      } інакше якщо вказівка.тип == ВВернути {
        якщо спроби != пусто {
          звільнити_вектор<Спроба>(спроби);
        }
        вернути машина_вернути(М, вказівка.місцезнаходження, середовище, забрати_зі_стопки(М));
      } інакше якщо вказівка.тип == ВСтворитиДіюДляСтруктури {
        ціль значення_дії = забрати_зі_стопки(М);
        ціль значення_структури = забрати_зі_стопки(М);
        якщо значення_структури.тип != ЗОбʼєкт {
          вернути результат_помилка_обʼєкт(створити_помилку_П13_дію_можна_причепити_лише_до_структури(М, вказівка.місцезнаходження, значення_структури));
        }
        ціль результат = машина_створити_дію_для_структури(М, вказівка.місцезнаходження, значення_дії.дані як комірка<Обʼєкт>, значення_структури.дані як комірка<Обʼєкт>);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        }
      } інакше якщо вказівка.тип == ВСтворитиМодуль {
        ціль дані_вказівки = вказівка.дані як комірка<ДаніВказівкиСтворитиМодуль>;
        ціль результат = машина_створити_модуль(М, вказівка.місцезнаходження, середовище, дані_вказівки.слово_назви, дані_вказівки.код_тіла);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВДати {
        ціль значення = забрати_зі_стопки(М);
        ціль слово_назви = вказівка.дані як комірка<Слово>;
        ціль результат = машина_дати(М, вказівка.місцезнаходження, середовище, слово_назви, значення);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        }
      } інакше якщо вказівка.тип == ВСтворитиСписок {
        ціль результат = машина_створити_список(М, вказівка.місцезнаходження);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВДодатиЕлементДоСписку {
        ціль значення_елемента = забрати_зі_стопки(М);
        ціль значення_списку = забрати_зі_стопки(М);
        покласти_на_стопку(М, значення_списку);
        ціль результат = машина_додати_елемент_до_списку(М, вказівка.місцезнаходження, значення_списку.дані як комірка<Обʼєкт>, значення_елемента);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        }
      } інакше якщо вказівка.тип == ВСтворитиСловник {
        ціль результат = машина_створити_словник(М, вказівка.місцезнаходження);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВДодатиЕлементДоСловника {
        ціль значення_елемента = забрати_зі_стопки(М);
        ціль значення_ключа = забрати_зі_стопки(М);
        ціль значення_списку = забрати_зі_стопки(М);
        покласти_на_стопку(М, значення_списку);
        ціль результат = машина_додати_елемент_до_словника(М, вказівка.місцезнаходження, значення_списку.дані як комірка<Обʼєкт>, значення_ключа, значення_елемента);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        }
      } інакше якщо вказівка.тип == ВВиконатиДію {
        ціль а = забрати_зі_стопки(М);
        ціль кількість_аргументів = вказівка.дані як позитивне;
        ціль результат = машина_виконати_дію(М, вказівка.місцезнаходження, а, кількість_аргументів);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВДодати {
        ціль б = забрати_зі_стопки(М);
        ціль а = забрати_зі_стопки(М);
        ціль результат = машина_додати(М, вказівка.місцезнаходження, а, б);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВВідняти {
        ціль б = забрати_зі_стопки(М);
        ціль а = забрати_зі_стопки(М);
        ціль результат = машина_відняти(М, вказівка.місцезнаходження, а, б);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВПомножити {
        ціль б = забрати_зі_стопки(М);
        ціль а = забрати_зі_стопки(М);
        ціль результат = машина_помножити(М, вказівка.місцезнаходження, а, б);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВПоділити {
        ціль б = забрати_зі_стопки(М);
        ціль а = забрати_зі_стопки(М);
        ціль результат = машина_поділити(М, вказівка.місцезнаходження, а, б);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВПоділитиЗаМодулем {
        ціль б = забрати_зі_стопки(М);
        ціль а = забрати_зі_стопки(М);
        ціль результат = машина_поділити_за_модулем(М, вказівка.місцезнаходження, а, б);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВПоділитиНаціло {
        ціль б = забрати_зі_стопки(М);
        ціль а = забрати_зі_стопки(М);
        ціль результат = машина_поділити_націло(М, вказівка.місцезнаходження, а, б);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВПіднестиДоСтепеня {
        ціль б = забрати_зі_стопки(М);
        ціль а = забрати_зі_стопки(М);
        ціль результат = машина_піднести_до_степеня(М, вказівка.місцезнаходження, а, б);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВДвійковеІ {
        ціль б = забрати_зі_стопки(М);
        ціль а = забрати_зі_стопки(М);
        ціль результат = машина_двійкове_і(М, вказівка.місцезнаходження, а, б);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВДвійковеАбо {
        ціль б = забрати_зі_стопки(М);
        ціль а = забрати_зі_стопки(М);
        ціль результат = машина_двійкове_або(М, вказівка.місцезнаходження, а, б);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВДвійковеВиключнеАбо {
        ціль б = забрати_зі_стопки(М);
        ціль а = забрати_зі_стопки(М);
        ціль результат = машина_двійкове_виключне_або(М, вказівка.місцезнаходження, а, б);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВДвійковийЗсувВліво {
        ціль б = забрати_зі_стопки(М);
        ціль а = забрати_зі_стопки(М);
        ціль результат = машина_двійковий_зсув_вліво(М, вказівка.місцезнаходження, а, б);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВДвійковийЗсувВправо {
        ціль б = забрати_зі_стопки(М);
        ціль а = забрати_зі_стопки(М);
        ціль результат = машина_двійковий_зсув_вправо(М, вказівка.місцезнаходження, а, б);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВДвійковийЗсувВправоЗЗаповненням {
        ціль б = забрати_зі_стопки(М);
        ціль а = забрати_зі_стопки(М);
        ціль результат = машина_двійковий_зсув_вправо_з_заповненням(М, вказівка.місцезнаходження, а, б);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВПорівнятиЧиРівно {
        ціль б = забрати_зі_стопки(М);
        ціль а = забрати_зі_стопки(М);
        ціль результат = машина_порівняти_чи_рівно(М, вказівка.місцезнаходження, а, б);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВПорівнятиЧиБільше {
        ціль б = забрати_зі_стопки(М);
        ціль а = забрати_зі_стопки(М);
        ціль результат = машина_порівняти_чи_більше(М, вказівка.місцезнаходження, а, б);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВПорівнятиЧиМенше {
        ціль б = забрати_зі_стопки(М);
        ціль а = забрати_зі_стопки(М);
        ціль результат = машина_порівняти_чи_менше(М, вказівка.місцезнаходження, а, б);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВПорівнятиЧиЄ {
        ціль б = забрати_зі_стопки(М);
        ціль а = забрати_зі_стопки(М);
        ціль результат = машина_порівняти_чи_є(М, вказівка.місцезнаходження, а, б);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВПорівнятиЧиМістить {
        ціль б = забрати_зі_стопки(М);
        ціль а = забрати_зі_стопки(М);
        ціль результат = машина_порівняти_чи_містить(М, вказівка.місцезнаходження, а, б);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВЗробитиВідʼємним {
        ціль а = забрати_зі_стопки(М);
        ціль результат = машина_зробити_відʼємним(М, вказівка.місцезнаходження, а);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВДвійковеНі {
        ціль а = забрати_зі_стопки(М);
        ціль результат = машина_двійкове_ні(М, вказівка.місцезнаходження, а);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВЗаперечити {
        ціль а = забрати_зі_стопки(М);
        ціль результат = машина_заперечити(М, вказівка.місцезнаходження, а);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВВзяти {
        ціль слова_шляху = створити_вектор<комірка<Слово>>();
        ціль значення_розміру_слів_шляху = забрати_зі_стопки(М);
        ціль розмір_слів_шляху = значення_розміру_слів_шляху.дані як дійсне;
        змінна х = 0;
        поки х < розмір_слів_шляху {
          ціль значення_слова_шляху = забрати_зі_стопки(М);
          ціль слово_шляху = значення_слова_шляху.дані як комірка<Слово>;
          додати_до_вектору<комірка<Слово>>(слова_шляху, слово_шляху);
          х = х + 1;
        }
        обернути_вектор<комірка<Слово>>(слова_шляху);
        ціль значення_слова_репозиторія = забрати_зі_стопки(М);
        ціль слово_репозиторія = значення_слова_репозиторія.дані як комірка<Слово>;
        ціль результат = машина_взяти(М, вказівка.місцезнаходження, середовище, слово_репозиторія, слова_шляху);
        звільнити_вектор<комірка<Слово>>(слова_шляху);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше якщо вказівка.тип == ВСтрибнути {
        вп = (вказівка.дані як позитивне) - 1;
      } інакше якщо вказівка.тип == ВСтрибнутиЯкщоНі {
        ціль значення = забрати_зі_стопки(М);
        якщо значення.тип == ЗПусто {
          вп = (вказівка.дані як позитивне) - 1;
        } інакше якщо значення.тип == ЗНі {
          вп = (вказівка.дані як позитивне) - 1;
        } інакше якщо значення.тип == ЗЧисло {
          якщо (значення.дані як дійсне) == 0.0 {
            вп = (вказівка.дані як позитивне) - 1;
          }
        }
      } інакше якщо вказівка.тип == ВСтрибнутиЯкщоНіХ {
        ціль значення = забрати_зі_стопки(М);
        покласти_на_стопку(М, значення);
        якщо значення.тип == ЗПусто {
          вп = (вказівка.дані як позитивне) - 1;
        } інакше якщо значення.тип == ЗНі {
          вп = (вказівка.дані як позитивне) - 1;
        } інакше якщо значення.тип == ЗЧисло {
          якщо (значення.дані як дійсне) == 0.0 {
            вп = (вказівка.дані як позитивне) - 1;
          }
        }
      } інакше якщо вказівка.тип == ВСтрибнутиЯкщоТак {
        ціль значення = забрати_зі_стопки(М);
        якщо значення.тип == ЗТак {
          вп = (вказівка.дані як позитивне) - 1;
        } інакше якщо значення.тип == ЗЧисло {
          якщо (значення.дані як дійсне) != 0.0 {
            вп = (вказівка.дані як позитивне) - 1;
          }
        } інакше якщо значення.тип == ЗСимвол {
          вп = (вказівка.дані як позитивне) - 1;
        } інакше якщо значення.тип == ЗОбʼєкт {
          вп = (вказівка.дані як позитивне) - 1;
        }
      } інакше якщо вказівка.тип == ВСтрибнутиЯкщоТакХ {
        ціль значення = забрати_зі_стопки(М);
        покласти_на_стопку(М, значення);
        якщо значення.тип == ЗТак {
          вп = (вказівка.дані як позитивне) - 1;
        } інакше якщо значення.тип == ЗЧисло {
          якщо (значення.дані як дійсне) != 0.0 {
            вп = (вказівка.дані як позитивне) - 1;
          }
        } інакше якщо значення.тип == ЗСимвол {
          вп = (вказівка.дані як позитивне) - 1;
        } інакше якщо значення.тип == ЗОбʼєкт {
          вп = (вказівка.дані як позитивне) - 1;
        }
      } інакше якщо вказівка.тип == ВПочатиСпробу {
        якщо спроби == пусто {
          спроби = створити_вектор<Спроба>();
        }
        ціль дані_вказівки = вказівка.дані як комірка<ДаніВказівкиПочатиСпробу>;
        додати_до_вектору<Спроба>(спроби, Спроба { дані_вказівки.позиція, дані_вказівки.слово_назви_субʼєкта_зловити, М.сліди.довжина });
      } інакше якщо вказівка.тип == ВЗакінчитиСпробу {
        спроби.довжина = спроби.довжина - 1;
        вп = (вказівка.дані як позитивне) - 1;
      } інакше якщо вказівка.тип == ВВпасти {
        ціль значення_помилки = забрати_зі_стопки(М);
        якщо значення_помилки.тип == ЗОбʼєкт {
          (значення_помилки.дані як комірка<Обʼєкт>).місцезнаходження_помилки = вказівка.місцезнаходження;
        }
        ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, значення_помилки);
        якщо новий_вп == вп {
          вернути результат_помилка(значення_помилки);
        } інакше {
          вп = новий_вп - 1;
        }
      } інакше якщо вказівка.тип == ВДублювати {
        ціль останнє_значення = забрати_зі_стопки(М);
        покласти_на_стопку(М, останнє_значення);
        покласти_на_стопку(М, останнє_значення);
      } інакше якщо вказівка.тип == ВДублювати_1 {
        ціль останнє_значення = забрати_зі_стопки(М);
        ціль попереднє_значення = забрати_зі_стопки(М);
        покласти_на_стопку(М, попереднє_значення);
        покласти_на_стопку(М, останнє_значення);
        покласти_на_стопку(М, попереднє_значення);
      } інакше якщо вказівка.тип == ВДублювати_2 {
        ціль останнє_значення = забрати_зі_стопки(М);
        ціль попереднє_значення = забрати_зі_стопки(М);
        ціль попереднє_значення_2 = забрати_зі_стопки(М);
        покласти_на_стопку(М, попереднє_значення_2);
        покласти_на_стопку(М, попереднє_значення);
        покласти_на_стопку(М, останнє_значення);
        покласти_на_стопку(М, попереднє_значення_2);
      } інакше якщо вказівка.тип == ВСкопіювати_2 {
        ціль останнє_значення = забрати_зі_стопки(М);
        ціль попереднє_значення = забрати_зі_стопки(М);
        ціль попереднє_значення_2 = забрати_зі_стопки(М);
        покласти_на_стопку(М, останнє_значення);
        покласти_на_стопку(М, попереднє_значення);
        покласти_на_стопку(М, останнє_значення);
      } інакше якщо вказівка.тип == ВОтриматиПеребір {
        ціль значення = забрати_зі_стопки(М);
        ціль результат = машина_отримати_перебір(М, вказівка.місцезнаходження, значення);
        якщо результат.успіх == 0 {
          ціль новий_вп = обробити_спроби(М, середовище, вп, спроби, результат.значення);
          якщо новий_вп == вп {
            вернути результат;
          } інакше {
            вп = новий_вп - 1;
          }
        } інакше {
          покласти_на_стопку(М, результат.значення);
        }
      } інакше {
        якщо спроби != пусто {
          звільнити_вектор<Спроба>(спроби);
        }
        вернути результат_помилка_обʼєкт(створити_обʼєкт_помилка(М, вказівка.місцезнаходження, ю8"Невідома вказівка!"));
      }
      вп = вп + 1;
    }
    якщо спроби != пусто {
      звільнити_вектор<Спроба>(спроби);
    }
    вернути результат_значення(забрати_зі_стопки(М));
  }

  місцева дія машина_визначити_субʼєкт(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, середовище: комірка<Середовище>, слово: комірка<Слово>, значення: Значення): Результат {
    змінити_субʼєкт_в_середовищі(
      середовище,
      слово,
      значення
    );
    вернути результат_значення(Значення { ЗПусто });
  }

  місцева дія машина_звернутись_до_субʼєкта(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, середовище: комірка<Середовище>, слово: комірка<Слово>): Результат {
    ціль значення = отримати_субʼєкт_зі_середовища(середовище, слово);
    вернути результат_значення(значення);
  }

  місцева дія машина_отримати_властивість(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення, слово: комірка<Слово>): Результат {
    якщо значення.тип == ЗТак {
      ціль метод = отримати_метод_структури_за_словом(М.структура_логічне, слово);
      якщо метод != пусто {
        вернути результат_значення(Значення { ЗОбʼєкт, дані = метод });
      }
    } інакше якщо значення.тип == ЗНі {
      ціль метод = отримати_метод_структури_за_словом(М.структура_логічне, слово);
      якщо метод != пусто {
        вернути результат_значення(Значення { ЗОбʼєкт, дані = метод });
      }
    } інакше якщо значення.тип == ЗЧисло {
      ціль метод = отримати_метод_структури_за_словом(М.структура_число, слово);
      якщо метод != пусто {
        вернути результат_значення(Значення { ЗОбʼєкт, дані = метод });
      }
    } інакше якщо значення.тип == ЗСимвол {
      ціль метод = отримати_метод_структури_за_словом(М.структура_символ, слово);
      якщо метод != пусто {
        вернути результат_значення(Значення { ЗОбʼєкт, дані = метод });
      }
    } інакше якщо значення.тип == ЗОбʼєкт {
      вернути (значення.дані як комірка<Обʼєкт>).отримати_властивість(М, місцезнаходження, (значення.дані як комірка<Обʼєкт>), слово);
    }
    вернути результат_помилка_обʼєкт(створити_помилку_П20_властивість_не_визначено(М, місцезнаходження, слово.назва, значення));
  }

  місцева дія машина_змінити_властивість(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення, слово: комірка<Слово>, значення_значення: Значення): Результат {
    якщо значення.тип == ЗОбʼєкт {
      вернути (значення.дані як комірка<Обʼєкт>).змінити_властивість(М, місцезнаходження, (значення.дані як комірка<Обʼєкт>), слово, значення_значення);
    }
    вернути результат_помилка_обʼєкт(створити_помилку_П20_властивість_не_визначено(М, місцезнаходження, слово.назва, значення));
  }

  місцева дія машина_отримати_елемент(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення, ключ: Значення): Результат {
    якщо значення.тип == ЗОбʼєкт {
      ціль результат = (значення.дані як комірка<Обʼєкт>).отримати_властивість(М, місцезнаходження, (значення.дані як комірка<Обʼєкт>), отримати_або_створити_слово(М, ю8"чародія_отримати"));
      якщо результат.успіх == 0 {
        вернути результат;
      }
      покласти_на_стопку(М, ключ);
      вернути машина_виконати_дію(М, місцезнаходження, результат.значення, 1);
    }
    вернути результат_помилка_обʼєкт(створити_помилку_П20_властивість_не_визначено(М, місцезнаходження, ю8"чародія_отримати", значення));
  }

  місцева дія машина_покласти_елемент(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення, ключ: Значення, значення_значення: Значення): Результат {
    якщо значення.тип == ЗОбʼєкт {
      ціль результат = (значення.дані як комірка<Обʼєкт>).отримати_властивість(М, місцезнаходження, (значення.дані як комірка<Обʼєкт>), отримати_або_створити_слово(М, ю8"чародія_покласти"));
      якщо результат.успіх == 0 {
        вернути результат;
      }
      покласти_на_стопку(М, ключ);
      покласти_на_стопку(М, значення_значення);
      вернути машина_виконати_дію(М, місцезнаходження, результат.значення, 2);
    }
    вернути результат_помилка_обʼєкт(створити_помилку_П20_властивість_не_визначено(М, місцезнаходження, ю8"чародія_покласти", значення));
  }

  місцева дія машина_створити_структуру(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, зовнішнє_середовище: комірка<Середовище>, слово: комірка<Слово>, предок: комірка<Обʼєкт>): Результат {
    якщо предок.тип != ОСтруктура {
      якщо предок != М.структура_обʼєкт {
        вернути результат_помилка_обʼєкт(створити_помилку_П10_обʼєкт_наслідування_повинен_бути_структурою(М, місцезнаходження, Значення { ЗОбʼєкт, дані = предок }));
      }
    }
    ціль о = створити_обʼєкт_структура(М, слово, предок);
    вернути результат_значення(Значення { ЗОбʼєкт, дані = о });
  }

  місцева дія машина_зберегти_параметр_структури(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, о: комірка<Обʼєкт>, позиція: позитивне, слово: комірка<Слово>, тип: комірка<Обʼєкт>, тип_може_бути_пусто: позитивне, має_значення_за_замовчуванням: позитивне, значення_за_замовчуванням: Значення): Результат {
    якщо тип.тип == ОСтруктура {
      додати_до_вектору<ПараметрСтруктури>(о.структура_параметри, ПараметрСтруктури { позиція = о.структура_кількість_параметрів_від_предка + позиція, слово = слово, тип = тип, тип_може_бути_пусто = тип_може_бути_пусто, має_значення_за_замовчуванням = має_значення_за_замовчуванням, значення_за_замовчуванням = значення_за_замовчуванням });
      вернути результат_значення(Значення { ЗПусто });
    } інакше {
      вернути результат_помилка_обʼєкт(створити_помилку_П11_тип_параметра_повинен_бути_структурою(М, місцезнаходження, Значення { ЗОбʼєкт, дані = тип }));
    }
  }

  місцева дія машина_створити_дію(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, зовнішнє_середовище: комірка<Середовище>, слово: комірка<Слово>, код_тіла: комірка<вектор<Вказівка>>, обʼєкт_типу_повернення: комірка<Обʼєкт>, тип_повернення_може_бути_пусто: позитивне): Результат {
    ціль обʼєкт_дії = створити_обʼєкт_дія(М, зовнішнє_середовище, слово, код_тіла, обʼєкт_типу_повернення, тип_повернення_може_бути_пусто);
    вернути результат_значення(Значення { ЗОбʼєкт, дані = обʼєкт_дії });
  }

  місцева дія машина_зберегти_параметр_дії(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, о: комірка<Обʼєкт>, позиція: позитивне, слово: комірка<Слово>, тип: комірка<Обʼєкт>, тип_може_бути_пусто: позитивне, має_значення_за_замовчуванням: позитивне, значення_за_замовчуванням: Значення): Результат {
    якщо тип.тип == ОСтруктура {
      додати_до_вектору<ПараметрДії>(о.дія_параметри, ПараметрДії { позиція = позиція, слово = слово, тип = тип, тип_може_бути_пусто = тип_може_бути_пусто, має_значення_за_замовчуванням = має_значення_за_замовчуванням, значення_за_замовчуванням = значення_за_замовчуванням });
      вернути результат_значення(Значення { ЗПусто });
    } інакше {
      вернути результат_помилка_обʼєкт(створити_помилку_П11_тип_параметра_повинен_бути_структурою(М, місцезнаходження, Значення { ЗОбʼєкт, дані = тип }));
    }
  }

  місцева дія машина_вернути(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, середовище: комірка<Середовище>, значення: Значення): Результат {
    якщо середовище.обʼєкт_дії == пусто {
      вернути результат_помилка_обʼєкт(створити_помилку_П14_вернути_можна_лише_в_середовищі_дії(М, місцезнаходження));
    }
    якщо середовище.обʼєкт_дії.дія_тип_повернення != пусто {
      якщо середовище.обʼєкт_дії.дія_тип_повернення_може_бути_пусто == 1 {
        якщо значення.тип == ЗПусто {
        } інакше {
          якщо перевірити_чи_значення_є(М, значення, середовище.обʼєкт_дії.дія_тип_повернення) == 0 {
            вернути результат_помилка_обʼєкт(створити_помилку_П15_недопустимий_тип_повернення(М, місцезнаходження, значення, середовище.обʼєкт_дії.дія_тип_повернення));
          }
        }
      } інакше {
        якщо перевірити_чи_значення_є(М, значення, середовище.обʼєкт_дії.дія_тип_повернення) == 0 {
          вернути результат_помилка_обʼєкт(створити_помилку_П15_недопустимий_тип_повернення(М, місцезнаходження, значення, середовище.обʼєкт_дії.дія_тип_повернення));
        }
      }
    }
    вернути результат_значення(значення);
  }

  місцева дія машина_створити_дію_для_структури(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, обʼєкт_дії: комірка<Обʼєкт>, обʼєкт_структури: комірка<Обʼєкт>): Результат {
    ціль слово = обʼєкт_дії.дія_слово;
    змінити_значення_карти<комірка<Слово>, комірка<Обʼєкт>>(
      обʼєкт_структури.структура_методи,
      слово,
      обʼєкт_дії
    );
    вернути результат_значення(Значення { ЗПусто });
  }

  місцева дія машина_створити_модуль(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, зовнішнє_середовище: комірка<Середовище>, слово: комірка<Слово>, код_тіла: комірка<вектор<Вказівка>>): Результат {
    ціль обʼєкт_модуля = створити_обʼєкт_модуль(М, слово);
    ціль середовище = створити_середовище(М, зовнішнє_середовище);
    середовище.обʼєкт_модуля = обʼєкт_модуля;
    ціль слово_я = отримати_або_створити_слово(М, ю8"я");
    змінити_субʼєкт_в_середовищі(середовище, слово_я, Значення { ЗОбʼєкт, дані = обʼєкт_модуля });
    додати_слід(М, Слід { місцезнаходження, середовище, обʼєкт_дії = пусто, обʼєкт_модуля = обʼєкт_модуля });
    ціль результат = запустити(М, код_тіла, середовище);
    якщо результат.успіх == 0 {
      вернути результат;
    }
    видалити_останній_слід(М);
    вернути результат_значення(Значення { ЗОбʼєкт, дані = обʼєкт_модуля });
  }

  місцева дія машина_дати(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, середовище: комірка<Середовище>, слово: комірка<Слово>, значення: Значення): Результат {
    якщо середовище.обʼєкт_модуля == пусто {
      вернути результат_помилка_обʼєкт(створити_помилку_П16_дати_можна_лише_середовищі_модуля(М, місцезнаходження));
    }
    змінити_властивість_обʼєкта(середовище.обʼєкт_модуля, слово, значення);
    вернути результат_значення(Значення { ЗПусто });
  }

  місцева дія машина_створити_список(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>): Результат {
    ціль обʼєкт_списку = створити_обʼєкт_список(М);
    вернути результат_значення(Значення { ЗОбʼєкт, дані = обʼєкт_списку });
  }

  місцева дія машина_додати_елемент_до_списку(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, обʼєкт_списку: комірка<Обʼєкт>, значення: Значення): Результат {
    додати_до_вектору<Значення>(обʼєкт_списку.список_елементи, значення);
    вернути результат_значення(Значення { ЗПусто });
  }

  місцева дія машина_створити_словник(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>): Результат {
    ціль обʼєкт_словника = створити_обʼєкт_словник(М);
    вернути результат_значення(Значення { ЗОбʼєкт, дані = обʼєкт_словника });
  }

  місцева дія машина_додати_елемент_до_словника(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, обʼєкт_словника: комірка<Обʼєкт>, значення_ключа: Значення, значення_елемента: Значення): Результат {
    змінити_значення_карти<Значення, Значення>(обʼєкт_словника.словник_елементи, значення_ключа, значення_елемента);
    вернути результат_значення(Значення { ЗПусто });
  }

  місцева дія машина_виконати_дію_з_аргументами(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення, аргументи: комірка<вектор<Аргумент>>): Результат {
    якщо значення.тип == ЗОбʼєкт {
      ціль обʼєкт = (значення.дані як комірка<Обʼєкт>);
      вернути обʼєкт.виконати(М, місцезнаходження, обʼєкт, аргументи);
    }
    вернути результат_помилка_обʼєкт(створити_помилку_П20_властивість_не_визначено(М, місцезнаходження, ю8"чародія_виконати", значення));
  }

  місцева дія машина_виконати_дію(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення, кількість_аргументів: позитивне): Результат {
    ціль аргументи = створити_вектор<Аргумент>();
    відкласти звільнити_вектор<Аргумент>(аргументи);
    змінна х = 0;
    поки х < кількість_аргументів {
      змінна значення = забрати_зі_стопки(М);
      якщо значення.тип == ЗСлово {
        додати_до_вектору<Аргумент>(аргументи, Аргумент { слово = значення.дані як комірка<Слово>, значення = забрати_зі_стопки(М) });
      } інакше {
        додати_до_вектору<Аргумент>(аргументи, Аргумент { слово = пусто, значення = значення });
      }
      х = х + 1;
    }
    обернути_вектор<Аргумент>(аргументи);
    вернути машина_виконати_дію_з_аргументами(М, місцезнаходження, значення, аргументи);
  }

  місцева дія машина_додати(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення, значення_аргумента: Значення): Результат {
    якщо значення.тип == ЗЧисло {
      якщо значення_аргумента.тип == ЗЧисло {
        вернути результат_значення(Значення { ЗЧисло, дані = (значення.дані як дійсне) + (значення_аргумента.дані як дійсне) });
      } інакше {
        вернути результат_помилка_обʼєкт(створити_помилку_П4_чародія_очікує_аргументом_число(М, місцезнаходження, ю8"чародія_додати", значення_аргумента));
      }
    } інакше якщо значення.тип == ЗОбʼєкт {
      ціль результат_отримання_чародії = (значення.дані як комірка<Обʼєкт>).отримати_властивість(М, місцезнаходження, (значення.дані як комірка<Обʼєкт>), отримати_або_створити_слово(М, ю8"чародія_додати"));
      якщо результат_отримання_чародії.успіх == 0 {
        вернути результат_отримання_чародії;
      }
      покласти_на_стопку(М, значення_аргумента);
      вернути машина_виконати_дію(М, місцезнаходження, результат_отримання_чародії.значення, 1);
    }
    вернути результат_помилка_обʼєкт(створити_помилку_П20_властивість_не_визначено(М, місцезнаходження, ю8"чародія_додати", значення));
  }

  місцева дія машина_відняти(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення, значення_аргумента: Значення): Результат {
    якщо значення.тип == ЗЧисло {
      якщо значення_аргумента.тип == ЗЧисло {
        вернути результат_значення(Значення { ЗЧисло, дані = (значення.дані як дійсне) - (значення_аргумента.дані як дійсне) });
      } інакше {
        вернути результат_помилка_обʼєкт(створити_помилку_П4_чародія_очікує_аргументом_число(М, місцезнаходження, ю8"чародія_відняти", значення_аргумента));
      }
    } інакше якщо значення.тип == ЗОбʼєкт {
      ціль результат_отримання_чародії = (значення.дані як комірка<Обʼєкт>).отримати_властивість(М, місцезнаходження, (значення.дані як комірка<Обʼєкт>), отримати_або_створити_слово(М, ю8"чародія_відняти"));
      якщо результат_отримання_чародії.успіх == 0 {
        вернути результат_отримання_чародії;
      }
      покласти_на_стопку(М, значення_аргумента);
      вернути машина_виконати_дію(М, місцезнаходження, результат_отримання_чародії.значення, 1);
    }
    вернути результат_помилка_обʼєкт(створити_помилку_П20_властивість_не_визначено(М, місцезнаходження, ю8"чародія_відняти", значення));
  }

  місцева дія машина_помножити(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення, значення_аргумента: Значення): Результат {
    якщо значення.тип == ЗЧисло {
      якщо значення_аргумента.тип == ЗЧисло {
        вернути результат_значення(Значення { ЗЧисло, дані = (значення.дані як дійсне) * (значення_аргумента.дані як дійсне) });
      } інакше {
        вернути результат_помилка_обʼєкт(створити_помилку_П4_чародія_очікує_аргументом_число(М, місцезнаходження, ю8"чародія_помножити", значення_аргумента));
      }
    } інакше якщо значення.тип == ЗОбʼєкт {
      ціль результат_отримання_чародії = (значення.дані як комірка<Обʼєкт>).отримати_властивість(М, місцезнаходження, (значення.дані як комірка<Обʼєкт>), отримати_або_створити_слово(М, ю8"чародія_помножити"));
      якщо результат_отримання_чародії.успіх == 0 {
        вернути результат_отримання_чародії;
      }
      покласти_на_стопку(М, значення_аргумента);
      вернути машина_виконати_дію(М, місцезнаходження, результат_отримання_чародії.значення, 1);
    }
    вернути результат_помилка_обʼєкт(створити_помилку_П20_властивість_не_визначено(М, місцезнаходження, ю8"чародія_помножити", значення));
  }

  місцева дія машина_поділити(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення, значення_аргумента: Значення): Результат {
    якщо значення.тип == ЗЧисло {
      якщо значення_аргумента.тип == ЗЧисло {
        вернути результат_значення(Значення { ЗЧисло, дані = (значення.дані як дійсне) / (значення_аргумента.дані як дійсне) });
      } інакше {
        вернути результат_помилка_обʼєкт(створити_помилку_П4_чародія_очікує_аргументом_число(М, місцезнаходження, ю8"чародія_поділити", значення_аргумента));
      }
    } інакше якщо значення.тип == ЗОбʼєкт {
      ціль результат_отримання_чародії = (значення.дані як комірка<Обʼєкт>).отримати_властивість(М, місцезнаходження, (значення.дані як комірка<Обʼєкт>), отримати_або_створити_слово(М, ю8"чародія_поділити"));
      якщо результат_отримання_чародії.успіх == 0 {
        вернути результат_отримання_чародії;
      }
      покласти_на_стопку(М, значення_аргумента);
      вернути машина_виконати_дію(М, місцезнаходження, результат_отримання_чародії.значення, 1);
    }
    вернути результат_помилка_обʼєкт(створити_помилку_П20_властивість_не_визначено(М, місцезнаходження, ю8"чародія_поділити", значення));
  }

  місцева дія машина_поділити_за_модулем(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення, значення_аргумента: Значення): Результат {
    якщо значення.тип == ЗЧисло {
      якщо значення_аргумента.тип == ЗЧисло {
        вернути результат_значення(Значення { ЗЧисло, дані = (значення.дані як дійсне) % (значення_аргумента.дані як дійсне) });
      } інакше {
        вернути результат_помилка_обʼєкт(створити_помилку_П4_чародія_очікує_аргументом_число(М, місцезнаходження, ю8"чародія_остача", значення_аргумента));
      }
    } інакше якщо значення.тип == ЗОбʼєкт {
      ціль результат_отримання_чародії = (значення.дані як комірка<Обʼєкт>).отримати_властивість(М, місцезнаходження, (значення.дані як комірка<Обʼєкт>), отримати_або_створити_слово(М, ю8"чародія_остача"));
      якщо результат_отримання_чародії.успіх == 0 {
        вернути результат_отримання_чародії;
      }
      покласти_на_стопку(М, значення_аргумента);
      вернути машина_виконати_дію(М, місцезнаходження, результат_отримання_чародії.значення, 1);
    }
    вернути результат_помилка_обʼєкт(створити_помилку_П20_властивість_не_визначено(М, місцезнаходження, ю8"чародія_остача", значення));
  }

  місцева дія машина_поділити_націло(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення, значення_аргумента: Значення): Результат {
    якщо значення.тип == ЗЧисло {
      якщо значення_аргумента.тип == ЗЧисло {
        вернути результат_значення(Значення { ЗЧисло, дані = математика_floor((значення.дані як дійсне) / (значення_аргумента.дані як дійсне)) });
      } інакше {
        вернути результат_помилка_обʼєкт(створити_помилку_П4_чародія_очікує_аргументом_число(М, місцезнаходження, ю8"чародія_частка", значення_аргумента));
      }
    } інакше якщо значення.тип == ЗОбʼєкт {
      ціль результат_отримання_чародії = (значення.дані як комірка<Обʼєкт>).отримати_властивість(М, місцезнаходження, (значення.дані як комірка<Обʼєкт>), отримати_або_створити_слово(М, ю8"чародія_частка"));
      якщо результат_отримання_чародії.успіх == 0 {
        вернути результат_отримання_чародії;
      }
      покласти_на_стопку(М, значення_аргумента);
      вернути машина_виконати_дію(М, місцезнаходження, результат_отримання_чародії.значення, 1);
    }
    вернути результат_помилка_обʼєкт(створити_помилку_П20_властивість_не_визначено(М, місцезнаходження, ю8"чародія_частка", значення));
  }

  місцева дія машина_піднести_до_степеня(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення, значення_аргумента: Значення): Результат {
    якщо значення.тип == ЗЧисло {
      якщо значення_аргумента.тип == ЗЧисло {
        вернути результат_значення(Значення { ЗЧисло, дані = математика_pow((значення.дані як дійсне), (значення_аргумента.дані як дійсне)) });
      } інакше {
        вернути результат_помилка_обʼєкт(створити_помилку_П4_чародія_очікує_аргументом_число(М, місцезнаходження, ю8"чародія_степінь", значення_аргумента));
      }
    } інакше якщо значення.тип == ЗОбʼєкт {
      ціль результат_отримання_чародії = (значення.дані як комірка<Обʼєкт>).отримати_властивість(М, місцезнаходження, (значення.дані як комірка<Обʼєкт>), отримати_або_створити_слово(М, ю8"чародія_степінь"));
      якщо результат_отримання_чародії.успіх == 0 {
        вернути результат_отримання_чародії;
      }
      покласти_на_стопку(М, значення_аргумента);
      вернути машина_виконати_дію(М, місцезнаходження, результат_отримання_чародії.значення, 1);
    }
    вернути результат_помилка_обʼєкт(створити_помилку_П20_властивість_не_визначено(М, місцезнаходження, ю8"чародія_степінь", значення));
  }

  місцева дія машина_двійкове_і(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення, значення_аргумента: Значення): Результат {
    якщо значення.тип == ЗЧисло {
      якщо значення_аргумента.тип == ЗЧисло {
        вернути результат_значення(Значення { ЗЧисло, дані = (((значення.дані як дійсне) як ціле) & ((значення_аргумента.дані як дійсне) як ціле)) як дійсне });
      } інакше {
        вернути результат_помилка_обʼєкт(створити_помилку_П4_чародія_очікує_аргументом_число(М, місцезнаходження, ю8"чародія_ді", значення_аргумента));
      }
    } інакше якщо значення.тип == ЗОбʼєкт {
      ціль результат_отримання_чародії = (значення.дані як комірка<Обʼєкт>).отримати_властивість(М, місцезнаходження, (значення.дані як комірка<Обʼєкт>), отримати_або_створити_слово(М, ю8"чародія_ді"));
      якщо результат_отримання_чародії.успіх == 0 {
        вернути результат_отримання_чародії;
      }
      покласти_на_стопку(М, значення_аргумента);
      вернути машина_виконати_дію(М, місцезнаходження, результат_отримання_чародії.значення, 1);
    }
    вернути результат_помилка_обʼєкт(створити_помилку_П20_властивість_не_визначено(М, місцезнаходження, ю8"чародія_ді", значення));
  }

  місцева дія машина_двійкове_або(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення, значення_аргумента: Значення): Результат {
    якщо значення.тип == ЗЧисло {
      якщо значення_аргумента.тип == ЗЧисло {
        вернути результат_значення(Значення { ЗЧисло, дані = (((значення.дані як дійсне) як ціле) | ((значення_аргумента.дані як дійсне) як ціле)) як дійсне });
      } інакше {
        вернути результат_помилка_обʼєкт(створити_помилку_П4_чародія_очікує_аргументом_число(М, місцезнаходження, ю8"чародія_дабо", значення_аргумента));
      }
    } інакше якщо значення.тип == ЗОбʼєкт {
      ціль результат_отримання_чародії = (значення.дані як комірка<Обʼєкт>).отримати_властивість(М, місцезнаходження, (значення.дані як комірка<Обʼєкт>), отримати_або_створити_слово(М, ю8"чародія_дабо"));
      якщо результат_отримання_чародії.успіх == 0 {
        вернути результат_отримання_чародії;
      }
      покласти_на_стопку(М, значення_аргумента);
      вернути машина_виконати_дію(М, місцезнаходження, результат_отримання_чародії.значення, 1);
    }
    вернути результат_помилка_обʼєкт(створити_помилку_П20_властивість_не_визначено(М, місцезнаходження, ю8"чародія_дабо", значення));
  }

  місцева дія машина_двійкове_виключне_або(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення, значення_аргумента: Значення): Результат {
    якщо значення.тип == ЗЧисло {
      якщо значення_аргумента.тип == ЗЧисло {
        вернути результат_значення(Значення { ЗЧисло, дані = (((значення.дані як дійсне) як ціле) ^ ((значення_аргумента.дані як дійсне) як ціле)) як дійсне });
      } інакше {
        вернути результат_помилка_обʼєкт(створити_помилку_П4_чародія_очікує_аргументом_число(М, місцезнаходження, ю8"чародія_вабо", значення_аргумента));
      }
    } інакше якщо значення.тип == ЗОбʼєкт {
      ціль результат_отримання_чародії = (значення.дані як комірка<Обʼєкт>).отримати_властивість(М, місцезнаходження, (значення.дані як комірка<Обʼєкт>), отримати_або_створити_слово(М, ю8"чародія_вабо"));
      якщо результат_отримання_чародії.успіх == 0 {
        вернути результат_отримання_чародії;
      }
      покласти_на_стопку(М, значення_аргумента);
      вернути машина_виконати_дію(М, місцезнаходження, результат_отримання_чародії.значення, 1);
    }
    вернути результат_помилка_обʼєкт(створити_помилку_П20_властивість_не_визначено(М, місцезнаходження, ю8"чародія_вабо", значення));
  }

  місцева дія машина_двійковий_зсув_вліво(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення, значення_аргумента: Значення): Результат {
    якщо значення.тип == ЗЧисло {
      якщо значення_аргумента.тип == ЗЧисло {
        вернути результат_значення(Значення { ЗЧисло, дані = (((значення.дані як дійсне) як ціле) << ((значення_аргумента.дані як дійсне) як ціле)) як дійсне });
      } інакше {
        вернути результат_помилка_обʼєкт(створити_помилку_П4_чародія_очікує_аргументом_число(М, місцезнаходження, ю8"чародія_вліво", значення_аргумента));
      }
    } інакше якщо значення.тип == ЗОбʼєкт {
      ціль результат_отримання_чародії = (значення.дані як комірка<Обʼєкт>).отримати_властивість(М, місцезнаходження, (значення.дані як комірка<Обʼєкт>), отримати_або_створити_слово(М, ю8"чародія_вліво"));
      якщо результат_отримання_чародії.успіх == 0 {
        вернути результат_отримання_чародії;
      }
      покласти_на_стопку(М, значення_аргумента);
      вернути машина_виконати_дію(М, місцезнаходження, результат_отримання_чародії.значення, 1);
    }
    вернути результат_помилка_обʼєкт(створити_помилку_П20_властивість_не_визначено(М, місцезнаходження, ю8"чародія_вліво", значення));
  }

  місцева дія машина_двійковий_зсув_вправо(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення, значення_аргумента: Значення): Результат {
    якщо значення.тип == ЗЧисло {
      якщо значення_аргумента.тип == ЗЧисло {
        вернути результат_значення(Значення { ЗЧисло, дані = (((значення.дані як дійсне) як ціле) >> ((значення_аргумента.дані як дійсне) як ціле)) як дійсне });
      } інакше {
        вернути результат_помилка_обʼєкт(створити_помилку_П4_чародія_очікує_аргументом_число(М, місцезнаходження, ю8"чародія_вправо", значення_аргумента));
      }
    } інакше якщо значення.тип == ЗОбʼєкт {
      ціль результат_отримання_чародії = (значення.дані як комірка<Обʼєкт>).отримати_властивість(М, місцезнаходження, (значення.дані як комірка<Обʼєкт>), отримати_або_створити_слово(М, ю8"чародія_вправо"));
      якщо результат_отримання_чародії.успіх == 0 {
        вернути результат_отримання_чародії;
      }
      покласти_на_стопку(М, значення_аргумента);
      вернути машина_виконати_дію(М, місцезнаходження, результат_отримання_чародії.значення, 1);
    }
    вернути результат_помилка_обʼєкт(створити_помилку_П20_властивість_не_визначено(М, місцезнаходження, ю8"чародія_вправо", значення));
  }

  місцева дія машина_двійковий_зсув_вправо_з_заповненням(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення, значення_аргумента: Значення): Результат {
    якщо значення.тип == ЗЧисло {
      якщо значення_аргумента.тип == ЗЧисло {
        вернути результат_значення(Значення { ЗЧисло, дані = (((значення.дані як дійсне) як ціле) >> ((значення_аргумента.дані як дійсне) як ціле)) як дійсне }); // потім: виправити
      } інакше {
        вернути результат_помилка_обʼєкт(створити_помилку_П4_чародія_очікує_аргументом_число(М, місцезнаходження, ю8"чародія_вправо_зі_заповненням", значення_аргумента));
      }
    } інакше якщо значення.тип == ЗОбʼєкт {
      ціль результат_отримання_чародії = (значення.дані як комірка<Обʼєкт>).отримати_властивість(М, місцезнаходження, (значення.дані як комірка<Обʼєкт>), отримати_або_створити_слово(М, ю8"чародія_вправо_зі_заповненням"));
      якщо результат_отримання_чародії.успіх == 0 {
        вернути результат_отримання_чародії;
      }
      покласти_на_стопку(М, значення_аргумента);
      вернути машина_виконати_дію(М, місцезнаходження, результат_отримання_чародії.значення, 1);
    }
    вернути результат_помилка_обʼєкт(створити_помилку_П20_властивість_не_визначено(М, місцезнаходження, ю8"чародія_вправо_зі_заповненням", значення));
  }

  місцева дія машина_порівняти_чи_рівно(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, а: Значення, б: Значення): Результат {
    якщо порівняти_значення(а, б) {
      вернути результат_значення(Значення { ЗТак });
    } інакше {
      вернути результат_значення(Значення { ЗНі });
    }
  }

  місцева дія машина_порівняти_чи_більше(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення, значення_аргумента: Значення): Результат {
    якщо значення.тип == ЗЧисло {
      якщо значення_аргумента.тип == ЗЧисло {
        якщо ((значення.дані як дійсне)) > ((значення_аргумента.дані як дійсне)) {
          вернути результат_значення(Значення { ЗТак });
        } інакше {
          вернути результат_значення(Значення { ЗНі });
        }
      } інакше {
        вернути результат_помилка_обʼєкт(створити_помилку_П4_чародія_очікує_аргументом_число(М, місцезнаходження, ю8"чародія_більше", значення_аргумента));
      }
    } інакше якщо значення.тип == ЗОбʼєкт {
      ціль результат_отримання_чародії = (значення.дані як комірка<Обʼєкт>).отримати_властивість(М, місцезнаходження, (значення.дані як комірка<Обʼєкт>), отримати_або_створити_слово(М, ю8"чародія_більше"));
      якщо результат_отримання_чародії.успіх == 0 {
        вернути результат_отримання_чародії;
      }
      покласти_на_стопку(М, значення_аргумента);
      вернути машина_виконати_дію(М, місцезнаходження, результат_отримання_чародії.значення, 1);
    }
    вернути результат_помилка_обʼєкт(створити_помилку_П20_властивість_не_визначено(М, місцезнаходження, ю8"чародія_більше", значення));
  }

  місцева дія машина_порівняти_чи_менше(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення, значення_аргумента: Значення): Результат {
    якщо значення.тип == ЗЧисло {
      якщо значення_аргумента.тип == ЗЧисло {
        якщо ((значення.дані як дійсне)) < ((значення_аргумента.дані як дійсне)) {
          вернути результат_значення(Значення { ЗТак });
        } інакше {
          вернути результат_значення(Значення { ЗНі });
        }
      } інакше {
        вернути результат_помилка_обʼєкт(створити_помилку_П4_чародія_очікує_аргументом_число(М, місцезнаходження, ю8"чародія_менше", значення_аргумента));
      }
    } інакше якщо значення.тип == ЗОбʼєкт {
      ціль результат_отримання_чародії = (значення.дані як комірка<Обʼєкт>).отримати_властивість(М, місцезнаходження, (значення.дані як комірка<Обʼєкт>), отримати_або_створити_слово(М, ю8"чародія_менше"));
      якщо результат_отримання_чародії.успіх == 0 {
        вернути результат_отримання_чародії;
      }
      покласти_на_стопку(М, значення_аргумента);
      вернути машина_виконати_дію(М, місцезнаходження, результат_отримання_чародії.значення, 1);
    }
    вернути результат_помилка_обʼєкт(створити_помилку_П20_властивість_не_визначено(М, місцезнаходження, ю8"чародія_менше", значення));
  }

  місцева дія машина_порівняти_чи_є(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення, значення_праворуч: Значення): Результат {
    якщо значення.тип == ЗПусто {
      якщо значення_праворуч.тип == ЗПусто {
        вернути результат_значення(Значення { ЗТак });
      } інакше якщо значення_праворуч.тип == ЗОбʼєкт {
        якщо (значення_праворуч.дані як комірка<Обʼєкт>) == М.структура_обʼєкт {
          вернути результат_значення(Значення { ЗТак });
        }
        якщо (значення_праворуч.дані як комірка<Обʼєкт>).тип == ОСтруктура {
          вернути результат_значення(Значення { ЗНі });
        } інакше {
          вернути результат_помилка_обʼєкт(створити_помилку_П7_є_лише_для_структур(М, місцезнаходження, значення_праворуч));
        }
      } інакше {
        вернути результат_помилка_обʼєкт(створити_помилку_П7_є_лише_для_структур(М, місцезнаходження, значення_праворуч));
      }
    } інакше якщо значення.тип == ЗТак {
      якщо значення_праворуч.тип == ЗПусто {
        вернути результат_значення(Значення { ЗНі });
      }
      якщо значення_праворуч.тип == ЗОбʼєкт {
        якщо (значення_праворуч.дані як комірка<Обʼєкт>).тип == ОСтруктура {
          якщо (значення_праворуч.дані як комірка<Обʼєкт>) == М.структура_обʼєкт {
            вернути результат_значення(Значення { ЗТак });
          } інакше якщо (значення_праворуч.дані як комірка<Обʼєкт>) == М.структура_логічне {
            вернути результат_значення(Значення { ЗТак });
          } інакше {
            вернути результат_значення(Значення { ЗНі });
          }
        } інакше {
          вернути результат_помилка_обʼєкт(створити_помилку_П7_є_лише_для_структур(М, місцезнаходження, значення_праворуч));
        }
      } інакше {
        вернути результат_помилка_обʼєкт(створити_помилку_П7_є_лише_для_структур(М, місцезнаходження, значення_праворуч));
      }
    } інакше якщо значення.тип == ЗНі {
      якщо значення_праворуч.тип == ЗПусто {
        вернути результат_значення(Значення { ЗНі });
      }
      якщо значення_праворуч.тип == ЗОбʼєкт {
        якщо (значення_праворуч.дані як комірка<Обʼєкт>).тип == ОСтруктура {
          якщо (значення_праворуч.дані як комірка<Обʼєкт>) == М.структура_обʼєкт {
            вернути результат_значення(Значення { ЗТак });
          } інакше якщо (значення_праворуч.дані як комірка<Обʼєкт>) == М.структура_логічне {
            вернути результат_значення(Значення { ЗТак });
          } інакше {
            вернути результат_значення(Значення { ЗНі });
          }
        } інакше {
          вернути результат_помилка_обʼєкт(створити_помилку_П7_є_лише_для_структур(М, місцезнаходження, значення_праворуч));
        }
      } інакше {
        вернути результат_помилка_обʼєкт(створити_помилку_П7_є_лише_для_структур(М, місцезнаходження, значення_праворуч));
      }
    } інакше якщо значення.тип == ЗЧисло {
      якщо значення_праворуч.тип == ЗПусто {
        вернути результат_значення(Значення { ЗНі });
      }
      якщо значення_праворуч.тип == ЗОбʼєкт {
        якщо (значення_праворуч.дані як комірка<Обʼєкт>).тип == ОСтруктура {
          якщо (значення_праворуч.дані як комірка<Обʼєкт>) == М.структура_обʼєкт {
            вернути результат_значення(Значення { ЗТак });
          } інакше якщо (значення_праворуч.дані як комірка<Обʼєкт>) == М.структура_число {
            вернути результат_значення(Значення { ЗТак });
          } інакше {
            вернути результат_значення(Значення { ЗНі });
          }
        } інакше {
          вернути результат_помилка_обʼєкт(створити_помилку_П7_є_лише_для_структур(М, місцезнаходження, значення_праворуч));
        }
      } інакше {
        вернути результат_помилка_обʼєкт(створити_помилку_П7_є_лише_для_структур(М, місцезнаходження, значення_праворуч));
      }
    } інакше якщо значення.тип == ЗСимвол {
      якщо значення_праворуч.тип == ЗПусто {
        вернути результат_значення(Значення { ЗНі });
      }
      якщо значення_праворуч.тип == ЗОбʼєкт {
        якщо (значення_праворуч.дані як комірка<Обʼєкт>).тип == ОСтруктура {
          якщо (значення_праворуч.дані як комірка<Обʼєкт>) == М.структура_обʼєкт {
            вернути результат_значення(Значення { ЗТак });
          } інакше якщо (значення_праворуч.дані як комірка<Обʼєкт>) == М.структура_символ {
            вернути результат_значення(Значення { ЗТак });
          } інакше {
            вернути результат_значення(Значення { ЗНі });
          }
        } інакше {
          вернути результат_помилка_обʼєкт(створити_помилку_П7_є_лише_для_структур(М, місцезнаходження, значення_праворуч));
        }
      } інакше {
        вернути результат_помилка_обʼєкт(створити_помилку_П7_є_лише_для_структур(М, місцезнаходження, значення_праворуч));
      }
    } інакше якщо значення.тип == ЗОбʼєкт {
      якщо значення_праворуч.тип == ЗПусто {
        вернути результат_значення(Значення { ЗНі });
      }
      якщо значення_праворуч.тип == ЗОбʼєкт {
        якщо (значення_праворуч.дані як комірка<Обʼєкт>).тип == ОСтруктура {
          якщо перевірити_чи_обʼєкт_є(М, (значення.дані як комірка<Обʼєкт>), значення_праворуч.дані як комірка<Обʼєкт>) {
            вернути результат_значення(Значення { ЗТак });
          } інакше {
            вернути результат_значення(Значення { ЗНі });
          }
        } інакше якщо значення_праворуч.тип == ЗПусто {
          вернути результат_значення(Значення { ЗНі });
        } інакше {
          вернути результат_помилка_обʼєкт(створити_помилку_П7_є_лише_для_структур(М, місцезнаходження, значення_праворуч));
        }
      } інакше {
        вернути результат_помилка_обʼєкт(створити_помилку_П7_є_лише_для_структур(М, місцезнаходження, значення_праворуч));
      }
    } інакше {
      вернути результат_помилка_обʼєкт(створити_помилку_П7_є_лише_для_структур(М, місцезнаходження, значення_праворуч));
    }
  }

  місцева дія машина_порівняти_чи_містить(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення, значення_аргумента: Значення): Результат {
    якщо значення.тип == ЗОбʼєкт {
      ціль результат_отримання_чародії = (значення.дані як комірка<Обʼєкт>).отримати_властивість(М, місцезнаходження, (значення.дані як комірка<Обʼєкт>), отримати_або_створити_слово(М, ю8"чародія_містить"));
      якщо результат_отримання_чародії.успіх == 0 {
        вернути результат_отримання_чародії;
      }
      покласти_на_стопку(М, значення_аргумента);
      вернути машина_виконати_дію(М, місцезнаходження, результат_отримання_чародії.значення, 1);
    }
    вернути результат_помилка_обʼєкт(створити_помилку_П20_властивість_не_визначено(М, місцезнаходження, ю8"чародія_містить", значення));
  }

  місцева дія машина_зробити_відʼємним(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення): Результат {
    якщо значення.тип == ЗЧисло {
      вернути результат_значення(Значення { ЗЧисло, дані = д64(0) - (значення.дані як дійсне) });
    } інакше якщо значення.тип == ЗОбʼєкт {
      ціль результат_отримання_чародії = (значення.дані як комірка<Обʼєкт>).отримати_властивість(М, місцезнаходження, (значення.дані як комірка<Обʼєкт>), отримати_або_створити_слово(М, ю8"чародія_відʼємне"));
      якщо результат_отримання_чародії.успіх == 0 {
        вернути результат_отримання_чародії;
      }
      вернути машина_виконати_дію(М, місцезнаходження, результат_отримання_чародії.значення, 1);
    }
    вернути результат_помилка_обʼєкт(створити_помилку_П20_властивість_не_визначено(М, місцезнаходження, ю8"чародія_відʼємне", значення));
  }

  місцева дія машина_двійкове_ні(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення): Результат {
    якщо значення.тип == ЗЧисло {
      вернути результат_значення(Значення { ЗЧисло, дані = двійкове_ні((значення.дані як дійсне) як ціле) як дійсне });
    } інакше якщо значення.тип == ЗОбʼєкт {
      ціль результат_отримання_чародії = (значення.дані як комірка<Обʼєкт>).отримати_властивість(М, місцезнаходження, (значення.дані як комірка<Обʼєкт>), отримати_або_створити_слово(М, ю8"чародія_дні"));
      якщо результат_отримання_чародії.успіх == 0 {
        вернути результат_отримання_чародії;
      }
      вернути машина_виконати_дію(М, місцезнаходження, результат_отримання_чародії.значення, 1);
    }
    вернути результат_помилка_обʼєкт(створити_помилку_П20_властивість_не_визначено(М, місцезнаходження, ю8"чародія_дні", значення));
  }

  місцева дія машина_заперечити(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення): Результат {
    якщо значення.тип == ЗПусто {
      вернути результат_значення(Значення { ЗТак });
    } інакше якщо значення.тип == ЗТак {
      вернути результат_значення(Значення { ЗНі });
    } інакше якщо значення.тип == ЗНі {
      вернути результат_значення(Значення { ЗТак });
    } інакше якщо значення.тип == ЗЧисло {
      якщо ((значення.дані як дійсне)) == 0.0 {
        вернути результат_значення(Значення { ЗТак });
      } інакше {
        вернути результат_значення(Значення { ЗНі });
      }
    } інакше якщо значення.тип == ЗСимвол {
      вернути результат_значення(Значення { ЗНі });
    } інакше якщо значення.тип == ЗОбʼєкт {
      вернути результат_значення(Значення { ЗНі });
    } інакше {
      вернути результат_помилка_обʼєкт(створити_обʼєкт_помилка(М, місцезнаходження, ю8"[ВНУТРІШНЯ ПОМИЛКА] Неможливо заперечити"));
    }
  }

  місцева дія машина_взяти(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, середовище: комірка<Середовище>, слово_репозиторія: комірка<Слово>, слова_шляху: комірка<вектор<комірка<Слово>>>): Результат {
    ціль слово_біб = отримати_або_створити_слово(М, ю8"біб");
    ціль слово_пак = отримати_або_створити_слово(М, ю8"пак");
    ціль слово_РМв1 = отримати_або_створити_слово(М, ю8"РМв1");
    ціль буфер_шляху = створити_буфер_ю8();
    відкласти звільнити_буфер_ю8(буфер_шляху);
    змінна взятий_модуль = отримати_взятий_модуль_з_середовища(середовище);
    взятий_модуль = взятий_модуль.кореневий_взятий_модуль;
    змінна назва_модуля: памʼять<п8> = пусто;
    якщо слово_репозиторія == пусто {
      ціль папка_шляху = отримати_папку_шляху(взятий_модуль.слово_шляху.назва);
      додати_до_буфера_ю8(буфер_шляху, папка_шляху);
      звільнити(папка_шляху);
      змінна х = 0;
      поки х < слова_шляху.довжина {
        ціль слово_шляху = слова_шляху.дані[х];
        якщо х == слова_шляху.довжина - 1 {
          додати_до_буфера_ю8(буфер_шляху, ю8"/");
          додати_до_буфера_ю8(буфер_шляху, слово_шляху.назва);
          додати_до_буфера_ю8(буфер_шляху, ю8".м");
          назва_модуля = слово_шляху.назва;
        } інакше {
          додати_до_буфера_ю8(буфер_шляху, ю8"/");
          додати_до_буфера_ю8(буфер_шляху, слово_шляху.назва);
        }
        х = х + 1;
      }
    } інакше {
      якщо слово_репозиторія == слово_біб {
        змінна х = 0;
        поки х < слова_шляху.довжина {
          ціль слово_шляху = слова_шляху.дані[х];
          якщо х == слова_шляху.довжина - 1 {
            назва_модуля = слово_шляху.назва;
            додати_до_буфера_ю8(буфер_шляху, слово_шляху.назва);
          } інакше {
            додати_до_буфера_ю8(буфер_шляху, слово_шляху.назва);
            додати_до_буфера_ю8(буфер_шляху, ю8".");
          }
          х = х + 1;
        }
        ціль шлях = створити_ю8_сі_з_буфера(буфер_шляху);
        ціль результат = М.взяти_біб(М, місцезнаходження, середовище, шлях);
        звільнити(шлях);
        вернути результат;
      } інакше якщо слово_репозиторія == слово_пак {
        додати_до_буфера_ю8(буфер_шляху, М.шлях_до_папки_запуску);
        додати_до_буфера_ю8(буфер_шляху, ю8"/");
        додати_до_буфера_ю8(буфер_шляху, ю8"паки");
        якщо слова_шляху.довжина == 1 {
          додати_до_буфера_ю8(буфер_шляху, ю8"/");
          додати_до_буфера_ю8(буфер_шляху, слова_шляху.дані[0].назва);
          додати_до_буфера_ю8(буфер_шляху, ю8"/");
          додати_до_буфера_ю8(буфер_шляху, слова_шляху.дані[0].назва);
          додати_до_буфера_ю8(буфер_шляху, ю8".м");
          назва_модуля = слова_шляху.дані[0].назва;
        } інакше {
          змінна х = 0;
          поки х < слова_шляху.довжина {
            ціль слово_шляху = слова_шляху.дані[х];
            якщо х == слова_шляху.довжина - 1 {
              додати_до_буфера_ю8(буфер_шляху, ю8"/");
              додати_до_буфера_ю8(буфер_шляху, слово_шляху.назва);
              додати_до_буфера_ю8(буфер_шляху, ю8".м");
              назва_модуля = слово_шляху.назва;
            } інакше {
              додати_до_буфера_ю8(буфер_шляху, ю8"/");
              додати_до_буфера_ю8(буфер_шляху, слово_шляху.назва);
            }
            х = х + 1;
          }
        }
        взятий_модуль = пусто;
      } інакше якщо слово_репозиторія == слово_РМв1 {
        ціль папка_шляху = отримати_папку_шляху(взятий_модуль.слово_шляху.назва);
        додати_до_буфера_ю8(буфер_шляху, папка_шляху);
        звільнити(папка_шляху);
        змінна х = 0;
        поки х < слова_шляху.довжина {
          ціль слово_шляху = слова_шляху.дані[х];
          якщо х == слова_шляху.довжина - 1 {
            додати_до_буфера_ю8(буфер_шляху, ю8"/");
            додати_до_буфера_ю8(буфер_шляху, слово_шляху.назва);
            додати_до_буфера_ю8(буфер_шляху, ю8".so");
            назва_модуля = слово_шляху.назва;
          } інакше {
            додати_до_буфера_ю8(буфер_шляху, ю8"/");
            додати_до_буфера_ю8(буфер_шляху, слово_шляху.назва);
          }
          х = х + 1;
        }
        ціль шлях = створити_ю8_сі_з_буфера(буфер_шляху);
        ціль результат = завантажити_РМв1(М, місцезнаходження, середовище, шлях, назва_модуля);
        звільнити(шлях);
        вернути результат;
      } інакше {
        вернути результат_помилка_обʼєкт(створити_помилку_П8_невідомий_репозиторій_взяття(М, місцезнаходження, слово_репозиторія));
      }
    }
    ціль шлях = створити_ю8_сі_з_буфера(буфер_шляху);
    ціль результат = взяти_модуль_за_шляхом(М, місцезнаходження, взятий_модуль, шлях);
    звільнити(шлях);
    вернути результат;
  }

  місцева дія машина_отримати_перебір(М: комірка<Машина>, місцезнаходження: комірка<Місцезнаходження>, значення: Значення): Результат {
    ціль результат_отримання_чародії = (значення.дані як комірка<Обʼєкт>).отримати_властивість(М, місцезнаходження, (значення.дані як комірка<Обʼєкт>), отримати_або_створити_слово(М, ю8"чародія_перебір"));
    якщо результат_отримання_чародії.успіх == 0 {
      вернути результат_отримання_чародії;
    }
    вернути машина_виконати_дію(М, місцезнаходження, результат_отримання_чародії.значення, 0);
  }
}