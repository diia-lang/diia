////
// Автор це Богданович Давид Когут Прихожденко та Організація Мавки та Організація Організацій
////

взяти визначення мавка;

секція мавка {
  місцева дія виділити_помилку_компіляції(місцезнаходження: адреса<Місцезнаходження>, повідомлення: Ю8): адреса<ПомилкаКомпіляції> {
    ціль помилка_компіляції = виділити<ПомилкаКомпіляції>();
    помилка_компіляції.місцезнаходження = місцезнаходження;
    помилка_компіляції.повідомлення = виділити_копію_ю8(повідомлення);
    вернути помилка_компіляції;
  }

  місцева дія виділити_контекст_компіляції(): адреса<КонтекстКомпіляції> {
    ціль контекст_компіляції = виділити<КонтекстКомпіляції>();
    контекст_компіляції.код_дії = пусто;
    вернути контекст_компіляції;
  }

  місцева дія скомпілювати_елемент_значення(М: адреса<МаМа::Машина>, контекст: адреса<КонтекстКомпіляції>, код: адреса<МаМа::Код>, елемент: адреса<АСДЗначення>): адреса<ПомилкаКомпіляції> {
    якщо елемент.вид == АСДВидЗвернутись {
      ціль дані = елемент.дані як адреса<АСДДаніЗвернутись>;
      якщо strcmp(дані.ідентифікатор.значення, ю8"я") == 0 {
        МаМа::покласти_вказівку_ПокластиЯ(код, елемент.місцезнаходження.рядок як п32);
      } інакше якщо strcmp(дані.ідентифікатор.значення, ю8"так") == 0 {
        МаМа::покласти_вказівку_ПокластиТак(код, елемент.місцезнаходження.рядок як п32);
      } інакше якщо strcmp(дані.ідентифікатор.значення, ю8"ні") == 0 {
        МаМа::покласти_вказівку_ПокластиНі(код, елемент.місцезнаходження.рядок як п32);
      } інакше {
        ціль позиція_назви = МаМа::позиція_назви_з_ю8(М, дані.ідентифікатор.значення);
        МаМа::покласти_вказівку_Звернутись(код, елемент.місцезнаходження.рядок як п32, позиція_назви);
      }
      вернути пусто;
    } інакше якщо елемент.вид == АСДВидОтримати {
      ціль дані = елемент.дані як адреса<АСДДаніОтримати>;
      ціль помилка_компіляції_обʼєкта = скомпілювати_елемент_значення(М, контекст, код, дані.обʼєкт);
      якщо помилка_компіляції_обʼєкта != пусто {
        вернути помилка_компіляції_обʼєкта;
      }
      ціль позиція_назви = МаМа::позиція_назви_з_ю8(М, дані.ідентифікатор.значення);
      МаМа::покласти_вказівку_ОтриматиВластивість(код, елемент.місцезнаходження.рядок як п32, позиція_назви);
      вернути пусто;
    } інакше якщо елемент.вид == АСДВидОтриматиЗаПозицією {
      ціль дані = елемент.дані як адреса<АСДДаніОтриматиЗаПозицією>;
      ціль результат_компіляції_обʼєкта = скомпілювати_елемент_значення(М, контекст, код, дані.обʼєкт);
      якщо результат_компіляції_обʼєкта != пусто {
        вернути результат_компіляції_обʼєкта;
      }
      ціль результат_компіляції_ключа = скомпілювати_елемент_значення(М, контекст, код, дані.позиція);
      якщо результат_компіляції_ключа != пусто {
        вернути результат_компіляції_ключа;
      }
      МаМа::покласти_вказівку_ОтриматиЕлемент(код, елемент.місцезнаходження.рядок як п32);
    } інакше якщо елемент.вид == АСДВидВиконати {
      ціль дані = елемент.дані як адреса<АСДДаніВиконати>;
      змінна ціль назва_прохання: адреса<МаМа::Назва> = пусто;
      змінна ціль позиція_назви_прохання: п32 = 0;
      якщо дані.обʼєкт.вид == АСДВидОтримати {
        ціль дані_отримання = дані.обʼєкт.дані як адреса<АСДДаніОтримати>;
        ціль помилка_компіляції_обʼєкта = скомпілювати_елемент_значення(М, контекст, код, дані_отримання.обʼєкт);
        якщо помилка_компіляції_обʼєкта != пусто {
          вернути помилка_компіляції_обʼєкта;
        }
        назва_прохання = МаМа::назва_з_ю8(М, дані_отримання.ідентифікатор.значення);
        позиція_назви_прохання = МаМа::позиція_назви_з_ю8(М, дані_отримання.ідентифікатор.значення) як п32;
      } інакше {
        ціль помилка_компіляції_обʼєкта = скомпілювати_елемент_значення(М, контекст, код, дані.обʼєкт);
        якщо помилка_компіляції_обʼєкта != пусто {
          вернути помилка_компіляції_обʼєкта;
        }
      }
      змінна ціль па: позитивне = 0;
      змінна ціль кількість_аргументів_без_назви: п32 = 0;
      змінна ціль вже_був_аргумент_з_назвою = ні;
      поки па < дані.кількість_аргументів {
        ціль аргумент = дані.аргументи[па];
        якщо аргумент.ідентифікатор == пусто {
          якщо вже_був_аргумент_з_назвою {
            вернути виділити_помилку_компіляції(елемент.місцезнаходження, ю8"Позиційні аргументи не можна ставити після іменованих");
          }
          кількість_аргументів_без_назви = кількість_аргументів_без_назви + 1;
        } інакше {
          вже_був_аргумент_з_назвою = так;
        }
        па = па + 1;
      }
      змінна ціль має_аргументи_з_назвами = вже_був_аргумент_з_назвою;
      якщо має_аргументи_з_назвами {
        МаМа::покласти_вказівку_ПокластиРеєстрАргументівЗНазвами(код, елемент.місцезнаходження.рядок як п32);
      }
      па = 0;
      поки па < дані.кількість_аргументів {
        ціль аргумент = дані.аргументи[па];
        ціль помилка_компіляції_аргумента = скомпілювати_елемент_значення(М, контекст, код, аргумент.значення);
        якщо помилка_компіляції_аргумента != пусто {
          вернути помилка_компіляції_аргумента;
        }
        якщо аргумент.ідентифікатор != пусто {
          ціль позиція_назви = МаМа::позиція_назви_з_ю8(М, аргумент.ідентифікатор.значення) як п32;
          МаМа::покласти_вказівку_ЗареєструватиАргументЗНазвою(код, елемент.місцезнаходження.рядок як п32, позиція_назви);
        }
        па = па + 1;
      }
      якщо має_аргументи_з_назвами {
        якщо назва_прохання == пусто {
          МаМа::покласти_вказівку_ВиконатиЗНазвами(код, елемент.місцезнаходження.рядок як п32, кількість_аргументів_без_назви);
        } інакше {
          МаМа::покласти_вказівку_ВиконатиВластивістьЗНазвами(код, елемент.місцезнаходження.рядок як п32, позиція_назви_прохання, кількість_аргументів_без_назви);
        }
      } інакше {
        якщо назва_прохання == пусто {
         МаМа::покласти_вказівку_Виконати(код, елемент.місцезнаходження.рядок як п32, кількість_аргументів_без_назви);
        } інакше {
          МаМа::покласти_вказівку_ВиконатиВластивість(код, елемент.місцезнаходження.рядок як п32, позиція_назви_прохання, кількість_аргументів_без_назви);
        }
      }
      вернути пусто;
    } інакше якщо елемент.вид == АСДВидДія {
      ціль дані = елемент.дані як адреса<АСДДаніДія>;
      ціль позиція_назви = МаМа::позиція_назви_з_ю8(М, дані.ідентифікатор.значення);
      МаМа::покласти_вказівку_ПокластиРеєстрПараметрів(код, елемент.місцезнаходження.рядок як п32);
      змінна ціль па: позитивне = 0;
      поки па < дані.кількість_параметрів {
        ціль параметр = дані.параметри[па];
        ціль позиція_назви_параметра = МаМа::позиція_назви_з_ю8(М, параметр.ідентифікатор.значення) як п32;
        змінна ціль птп: позитивне = 0;
        поки птп < параметр.кількість_типів {
          ціль тип = параметр.типи[птп];
          ціль помилка_компіляції_типу = скомпілювати_елемент_значення(М, контекст, код, тип);
          якщо помилка_компіляції_типу != пусто {
            вернути помилка_компіляції_типу;
          }
          птп = птп + 1;
        }
        якщо параметр.значення != пусто {
          ціль код_значення_параметра = МаМа::виділити_код(код.шлях_до_файлу);
          ціль контекст_значення_параметра = виділити_контекст_компіляції();
          ціль помилка_компіляції_значення_параметра = скомпілювати_елемент_значення(М, контекст_значення_параметра, код_значення_параметра, параметр.значення);
          якщо помилка_компіляції_значення_параметра != пусто {
            вернути помилка_компіляції_значення_параметра;
          }
          ціль позиція_підкоду = М.сховище_кодів.розмір як п32;
          покласти_в_накопичувач<адреса<МаМа::Код>>(М.сховище_кодів::адреса, код_значення_параметра);
          МаМа::покласти_вказівку_ТриматиКод(код, елемент.місцезнаходження.рядок як п32, позиція_підкоду);
        }
        МаМа::покласти_вказівку_ЗареєструватиПараметр(код, елемент.місцезнаходження.рядок як п32, позиція_назви_параметра, параметр.кількість_типів як п32);
        па = па + 1;
      }
      ціль код_дії = МаМа::виділити_код(код.шлях_до_файлу);
      ціль контекст_дії = виділити_контекст_компіляції();
      ціль помилка_компіляції_тіла_дії = скомпілювати_тіло(М, контекст_дії, код_дії, дані.тіло);
      якщо помилка_компіляції_тіла_дії != пусто {
        вернути помилка_компіляції_тіла_дії;
      }
      ціль позиція_підкоду = М.сховище_кодів.розмір як п32;
      покласти_в_накопичувач<адреса<МаМа::Код>>(М.сховище_кодів::адреса, код_дії);
      МаМа::покласти_вказівку_СтворитиДію(код, елемент.місцезнаходження.рядок як п32, позиція_назви, позиція_підкоду);
      вернути пусто;
    } інакше якщо елемент.вид == АСДВидСтруктура {
      ціль дані = елемент.дані як адреса<АСДДаніСтруктура>;
      ціль назва = МаМа::назва_з_ю8(М, дані.ідентифікатор.значення);
      ціль позиція_назви = МаМа::позиція_назви_з_ю8(М, дані.ідентифікатор.значення);
      якщо дані.предок == пусто {
        ціль позиція_назви = МаМа::позиція_назви_з_ю8(М, ю8"обʼєкт");
        МаМа::покласти_вказівку_Звернутись(код, елемент.місцезнаходження.рядок як п32, позиція_назви);
      } інакше {
        ціль помилка_компіляції_предка = скомпілювати_елемент_значення(М, контекст, код, дані.предок);
        якщо помилка_компіляції_предка != пусто {
          вернути помилка_компіляції_предка;
        }
      }
      МаМа::покласти_вказівку_ПокластиРеєстрПараметрів(код, елемент.місцезнаходження.рядок як п32);
      змінна ціль па: позитивне = 0;
      поки па < дані.кількість_параметрів {
        ціль параметр = дані.параметри[па];
        ціль позиція_назви_параметра = МаМа::позиція_назви_з_ю8(М, параметр.ідентифікатор.значення);
        змінна ціль птп: позитивне = 0;
        поки птп < параметр.кількість_типів {
          ціль тип = параметр.типи[птп];
          ціль помилка_компіляції_типу = скомпілювати_елемент_значення(М, контекст, код, тип);
          якщо помилка_компіляції_типу != пусто {
            вернути помилка_компіляції_типу;
          }
          птп = птп + 1;
        }
        якщо параметр.значення != пусто {
          ціль код_значення_параметра = МаМа::виділити_код(код.шлях_до_файлу);
          ціль контекст_значення_параметра = виділити_контекст_компіляції();
          ціль помилка_компіляції_значення_параметра = скомпілювати_елемент_значення(М, контекст_значення_параметра, код_значення_параметра, параметр.значення);
          якщо помилка_компіляції_значення_параметра != пусто {
            вернути помилка_компіляції_значення_параметра;
          }
          ціль позиція_підкоду = М.сховище_кодів.розмір як п32;
          покласти_в_накопичувач<адреса<МаМа::Код>>(М.сховище_кодів::адреса, код_значення_параметра);
          МаМа::покласти_вказівку_ТриматиКод(код, елемент.місцезнаходження.рядок як п32, позиція_підкоду);
        }
        МаМа::покласти_вказівку_ЗареєструватиПараметр(код, елемент.місцезнаходження.рядок як п32, позиція_назви_параметра, параметр.кількість_типів як п32);
        па = па + 1;
      }
      МаМа::покласти_вказівку_СтворитиСтруктуру(код, елемент.місцезнаходження.рядок як п32, позиція_назви);
      вернути пусто;
    } інакше якщо елемент.вид == АСДВидЧисло {
      ціль дані = елемент.дані як адреса<АСДДаніЧисло>;
      ціль результат_розбору_числа = різне::числа::розібрати_дійсне_з_ю8сі<д64>(дані.значення);
      якщо результат_розбору_числа.помилка != пусто {
        надрукувати_ю8(результат_розбору_числа.помилка);
      }
      ціль обʼєкт_числа = МаМа::виділити_обʼєкт_числа(М, результат_розбору_числа.значення);
      ціль позиція_константи = МаМа::покласти_константу(М, обʼєкт_числа як адреса<МаМа::Обʼєкт>);
      МаМа::покласти_вказівку_ПокластиКонстанту(код, елемент.місцезнаходження.рядок як п32, позиція_константи);
      вернути пусто;
    } інакше якщо елемент.вид == АСДВидТекст {
      ціль дані = елемент.дані як адреса<АСДДаніТекст>;
      змінна ціль позиція_константи: п32 = 0;
      якщо дані.ідентифікатор == пусто {
        ціль довжина_Ю8 = strlen(дані.значення);
        якщо довжина_Ю8 == 0 {
          ціль обʼєкт_тексту = МаМа::виділити_обʼєкт_тексту(М, ю8"");
          позиція_константи = МаМа::покласти_константу(М, обʼєкт_тексту як адреса<МаМа::Обʼєкт>);
        } інакше {
          ціль вихід_КД = виділити<п8>(довжина_Ю8 + 1);
          ціль розмір_перекодованого_виходу_КД = КД::перекодувати_з_Ю8(
            дані.значення,
            довжина_Ю8 як позитивне,
            вихід_КД
          );
          якщо розмір_перекодованого_виходу_КД == 0 {
            ціль помилка_компіляції = виділити_помилку_компіляції(елемент.місцезнаходження, ю8"Невідомий символ КД");
            вернути помилка_компіляції;
          }
          вихід_КД[розмір_перекодованого_виходу_КД] = 0;
          ціль обʼєкт_тексту = МаМа::виділити_обʼєкт_тексту(М, вихід_КД);
          звільнити(вихід_КД);
          позиція_константи = МаМа::покласти_константу(М, обʼєкт_тексту як адреса<МаМа::Обʼєкт>);
        }
      } інакше якщо strcmp(дані.ідентифікатор.значення, ю8"ю") == 0 {
        ціль ю32 = перетворити_ю8_на_ю32(дані.значення);
        ціль обʼєкт_юнікоду = МаМа::виділити_обʼєкт_юнікоду(М, ю32);
        звільнити(ю32);
        позиція_константи = МаМа::покласти_константу(М, обʼєкт_юнікоду як адреса<МаМа::Обʼєкт>);
      } інакше {
        ціль помилка_компіляції = виділити_помилку_компіляції(елемент.місцезнаходження, ю8"Невідомий тип тексту");
        вернути помилка_компіляції;
      }
      МаМа::покласти_вказівку_ПокластиКонстанту(код, елемент.місцезнаходження.рядок як п32, позиція_константи);
      вернути пусто;
    } інакше якщо елемент.вид == АСДВидСимвол {
      ціль дані = елемент.дані як адреса<АСДДаніТекст>;
      змінна ціль позиція_константи: п32 = 0;
      якщо дані.ідентифікатор == пусто {
        ціль довжина_Ю8 = strlen(дані.значення);
        якщо довжина_Ю8 == 0 {
          ціль помилка_компіляції = виділити_помилку_компіляції(елемент.місцезнаходження, ю8"Пустий символ");
          вернути помилка_компіляції;
        } інакше {
          ціль вихід_КД = виділити<п8>(довжина_Ю8 + 1);
          ціль розмір_перекодованого_виходу_КД = КД::перекодувати_з_Ю8(
            дані.значення,
            довжина_Ю8 як позитивне,
            вихід_КД
          );
          якщо розмір_перекодованого_виходу_КД == 0 {
            ціль помилка_компіляції = виділити_помилку_компіляції(елемент.місцезнаходження, ю8"Невідомий символ КД");
            вернути помилка_компіляції;
          }
          вихід_КД[розмір_перекодованого_виходу_КД] = 0;
          якщо розмір_перекодованого_виходу_КД > 1 {
            ціль помилка_компіляції = виділити_помилку_компіляції(елемент.місцезнаходження, ю8"Більше одного символу");
            вернути помилка_компіляції;
          }
          ціль обʼєкт_числа = МаМа::виділити_обʼєкт_числа(М, вихід_КД[0] як д64);
          звільнити(вихід_КД);
          позиція_константи = МаМа::покласти_константу(М, обʼєкт_числа як адреса<МаМа::Обʼєкт>);
        }
      } інакше якщо strcmp(дані.ідентифікатор.значення, ю8"ю") == 0 {
        ціль ю32 = перетворити_ю8_на_ю32(дані.значення);
        // потім: перевірити довжину ю32
        ціль обʼєкт_числа = МаМа::виділити_обʼєкт_числа(М, ю32[0] як д64);
        звільнити(ю32);
        позиція_константи = МаМа::покласти_константу(М, обʼєкт_числа як адреса<МаМа::Обʼєкт>);
      } інакше {
        ціль помилка_компіляції = виділити_помилку_компіляції(елемент.місцезнаходження, ю8"Невідомий тип символу");
        вернути помилка_компіляції;
      }
      МаМа::покласти_вказівку_ПокластиКонстанту(код, елемент.місцезнаходження.рядок як п32, позиція_константи);
      вернути пусто;
    } інакше якщо елемент.вид == АСДВидОперація {
      ціль дані = елемент.дані як адреса<АСДДаніОперація>;
      ціль помилка_компіляції_ліво = скомпілювати_елемент_значення(М, контекст, код, дані.ліво);
      якщо помилка_компіляції_ліво != пусто {
        вернути помилка_компіляції_ліво;
      }
      ціль помилка_компіляції_право = скомпілювати_елемент_значення(М, контекст, код, дані.право);
      якщо помилка_компіляції_право != пусто {
        вернути помилка_компіляції_право;
      }
      якщо дані.операція == АСДОпераціяДодавання {
        МаМа::покласти_вказівку_Додати(код, елемент.місцезнаходження.рядок як п32);
        вернути пусто;
      } інакше якщо дані.операція == АСДОпераціяВіднімання {
        МаМа::покласти_вказівку_Відняти(код, елемент.місцезнаходження.рядок як п32);
        вернути пусто;
      } інакше якщо дані.операція == АСДОпераціяМноження {
        МаМа::покласти_вказівку_Помножити(код, елемент.місцезнаходження.рядок як п32);
        вернути пусто;
      } інакше якщо дані.операція == АСДОпераціяДілення {
        МаМа::покласти_вказівку_Поділити(код, елемент.місцезнаходження.рядок як п32);
        вернути пусто;
      } інакше якщо дані.операція == АСДОпераціяМодуль {
        МаМа::покласти_вказівку_ОтриматиОстачуДілення(код, елемент.місцезнаходження.рядок як п32);
        вернути пусто;
      } інакше якщо дані.операція == АСДОпераціяДіленняНаціло {
        МаМа::покласти_вказівку_ОтриматиЧасткуДілення(код, елемент.місцезнаходження.рядок як п32);
        вернути пусто;
      } інакше якщо дані.операція == АСДОпераціяПіднесенняДоСтепеня {
        МаМа::покласти_вказівку_ПіднестиДоСтепеня(код, елемент.місцезнаходження.рядок як п32);
        вернути пусто;
      } інакше якщо дані.операція == АСДОпераціяЗсувВліво {
        МаМа::покласти_вказівку_ЗсунутиВліво(код, елемент.місцезнаходження.рядок як п32);
        вернути пусто;
      } інакше якщо дані.операція == АСДОпераціяЗсувВправо {
        МаМа::покласти_вказівку_ЗсунутиВправо(код, елемент.місцезнаходження.рядок як п32);
        вернути пусто;
      } інакше якщо дані.операція == АСДОпераціяЗсувВправоЗнаковий {
        МаМа::покласти_вказівку_ЗсунутиВправоЗіЗаповненням(код, елемент.місцезнаходження.рядок як п32);
        вернути пусто;
      } інакше якщо дані.операція == АСДОпераціяДІ {
        МаМа::покласти_вказівку_ДвійковеІ(код, елемент.місцезнаходження.рядок як п32);
        вернути пусто;
      } інакше якщо дані.операція == АСДОпераціяДАБО {
        МаМа::покласти_вказівку_ДвійковеАБО(код, елемент.місцезнаходження.рядок як п32);
        вернути пусто;
      } інакше якщо дані.операція == АСДОпераціяВАБО {
        МаМа::покласти_вказівку_ДвійковеВиключнеАБО(код, елемент.місцезнаходження.рядок як п32);
        вернути пусто;
      } інакше якщо дані.операція == АСДОпераціяМенше {
        МаМа::покласти_вказівку_Менше(код, елемент.місцезнаходження.рядок як п32);
        вернути пусто;
      } інакше якщо дані.операція == АСДОпераціяБільше {
        МаМа::покласти_вказівку_Більше(код, елемент.місцезнаходження.рядок як п32);
        вернути пусто;
      } інакше якщо дані.операція == АСДОпераціяМеншеРівне {
        МаМа::покласти_вказівку_НеБільше(код, елемент.місцезнаходження.рядок як п32);
        вернути пусто;
      } інакше якщо дані.операція == АСДОпераціяБільшеРівне {
        МаМа::покласти_вказівку_НеМенше(код, елемент.місцезнаходження.рядок як п32);
        вернути пусто;
      } інакше якщо дані.операція == АСДОпераціяРівне {
        МаМа::покласти_вказівку_Рівно(код, елемент.місцезнаходження.рядок як п32);
        вернути пусто;
      } інакше якщо дані.операція == АСДОпераціяНерівне {
        МаМа::покласти_вказівку_НеРівно(код, елемент.місцезнаходження.рядок як п32);
        вернути пусто;
      } інакше якщо дані.операція == АСДОпераціяІ {
        вернути виділити_помилку_компіляції(елемент.місцезнаходження, ю8"Невідома операція!");
      } інакше якщо дані.операція == АСДОпераціяАБО {
        вернути виділити_помилку_компіляції(елемент.місцезнаходження, ю8"Невідома операція!");
      } інакше {
        вернути виділити_помилку_компіляції(елемент.місцезнаходження, ю8"Невідома операція!");
      }
    } інакше якщо елемент.вид == АСДВидЗначенняЯкщо {
      //
    } інакше якщо елемент.вид == АСДВидЯк {
      //
    } інакше якщо елемент.вид == АСДВидСамоОперація {
      //
    } інакше якщо елемент.вид == АСДВидМодуль {
      ціль дані = елемент.дані як адреса<АСДДаніМодуль>;
      ціль позиція_назви = МаМа::позиція_назви_з_ю8(М, дані.ідентифікатор.значення); // потім: назва може бути пусто
      ціль код_модуля = МаМа::виділити_код(код.шлях_до_файлу);
      ціль контекст_модуля = виділити_контекст_компіляції();
      ціль помилка_компіляції_тіла_модуля = скомпілювати_тіло(М, контекст_модуля, код_модуля, дані.тіло);
      якщо помилка_компіляції_тіла_модуля != пусто {
        вернути помилка_компіляції_тіла_модуля;
      }
      ціль позиція_підкоду = М.сховище_кодів.розмір як п32;
      покласти_в_накопичувач<адреса<МаМа::Код>>(М.сховище_кодів::адреса, код_модуля);
      МаМа::покласти_вказівку_СтворитиМодуль(код, елемент.місцезнаходження.рядок як п32, позиція_назви, позиція_підкоду);
      вернути пусто;
    } інакше якщо елемент.вид == АСДВидСписок {
      ціль дані = елемент.дані як адреса<АСДДаніСписок>;
      МаМа::покласти_вказівку_СтворитиСписок(код, елемент.місцезнаходження.рядок як п32, 0);
      змінна ціль пе: позитивне = 0;
      поки пе < дані.кількість_елементів {
        ціль елемент_списку = дані.елементи[пе];
        ціль помилка_компіляції_елементу_списку = скомпілювати_елемент_значення(М, контекст, код, елемент_списку);
        якщо помилка_компіляції_елементу_списку != пусто {
          вернути помилка_компіляції_елементу_списку;
        }
        МаМа::покласти_вказівку_ПокластиВСписок(код, елемент.місцезнаходження.рядок як п32);
        пе += 1;
      }
      вернути пусто;
    } інакше якщо елемент.вид == АСДВидСловник {
      ціль дані = елемент.дані як адреса<АСДДаніСловник>;
      змінна ціль пе: позитивне = 0;
      поки пе < дані.кількість_елементів {
        ціль елемент_словника = дані.елементи[пе];
        ціль помилка_компіляції_ключа_словника_списку = скомпілювати_елемент_значення(М, контекст, код, елемент_словника.ключ);
        якщо помилка_компіляції_ключа_словника_списку != пусто {
          вернути помилка_компіляції_ключа_словника_списку;
        }
        ціль помилка_компіляції_значення_словника_списку = скомпілювати_елемент_значення(М, контекст, код, елемент_словника.значення);
        якщо помилка_компіляції_значення_словника_списку != пусто {
          вернути помилка_компіляції_значення_словника_списку;
        }
        МаМа::покласти_вказівку_ПокластиВСловник(код, елемент.місцезнаходження.рядок як п32);
        пе += 1;
      }
      вернути пусто;
    }
    вернути виділити_помилку_компіляції(елемент.місцезнаходження, ю8"Невідомий вид АСДЗначення!");
  }

  місцева дія скомпілювати_тіло(М: адреса<МаМа::Машина>, контекст: адреса<КонтекстКомпіляції>, код: адреса<МаМа::Код>, тіло: адреса<СписокАСДЗначень>): адреса<ПомилкаКомпіляції> {
    змінна ціль пе: позитивне = 0;
    поки пе < тіло.довжина {
      ціль елемент = тіло.елементи[пе];
      якщо елемент.вид == АСДВидНіщо {
        вернути виділити_помилку_компіляції(елемент.місцезнаходження, ю8"Виявлено АСДВидНіщо!");
      } інакше якщо елемент.вид == АСДВидВизначити {
        ціль дані = елемент.дані як адреса<АСДДаніВизначити>;
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, дані.значення);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
        ціль позиція_назви = МаМа::позиція_назви_з_ю8(М, дані.ідентифікатор.значення);
        МаМа::покласти_вказівку_Визначити(код, елемент.місцезнаходження.рядок як п32, позиція_назви);
      } інакше якщо елемент.вид == АСДВидЗвернутись {
        ціль дані = елемент.дані як адреса<АСДДаніЗвернутись>;
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, елемент);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
        МаМа::покласти_вказівку_Забрати(код, елемент.місцезнаходження.рядок як п32);
      } інакше якщо елемент.вид == АСДВидОтримати {
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, елемент);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
        МаМа::покласти_вказівку_Забрати(код, елемент.місцезнаходження.рядок як п32);
      } інакше якщо елемент.вид == АСДВидОтриматиЗаПозицією {
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, елемент);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
        МаМа::покласти_вказівку_Забрати(код, елемент.місцезнаходження.рядок як п32);
      } інакше якщо елемент.вид == АСДВидЗмінити {
        ціль дані = елемент.дані як адреса<АСДДаніЗмінити>;
        ціль помилка_компіляції_обʼєкта = скомпілювати_елемент_значення(М, контекст, код, дані.обʼєкт);
        якщо помилка_компіляції_обʼєкта != пусто {
          вернути помилка_компіляції_обʼєкта;
        }
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, дані.значення);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
        ціль позиція_назви = МаМа::позиція_назви_з_ю8(М, дані.ідентифікатор.значення);
        МаМа::покласти_вказівку_ЗмінитиВластивість(код, елемент.місцезнаходження.рядок як п32, позиція_назви);
      } інакше якщо елемент.вид == АСДВидЗмінитиЗаПозицією {
        ціль дані = елемент.дані як адреса<АСДДаніЗмінитиЗаПозицією>;
        ціль помилка_компіляції_обʼєкта = скомпілювати_елемент_значення(М, контекст, код, дані.обʼєкт);
        якщо помилка_компіляції_обʼєкта != пусто {
          вернути помилка_компіляції_обʼєкта;
        }
        ціль помилка_компіляції_позиції = скомпілювати_елемент_значення(М, контекст, код, дані.позиція);
        якщо помилка_компіляції_позиції != пусто {
          вернути помилка_компіляції_позиції;
        }
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, дані.значення);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
        МаМа::покласти_вказівку_ЗмінитиЕлемент(код, елемент.місцезнаходження.рядок як п32);
      } інакше якщо елемент.вид == АСДВидВиконати {
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, елемент);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
        МаМа::покласти_вказівку_Забрати(код, елемент.місцезнаходження.рядок як п32);
      } інакше якщо елемент.вид == АСДВидДія {
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, елемент);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
        ціль дані = елемент.дані як адреса<АСДДаніДія>;
        ціль позиція_назви = МаМа::позиція_назви_з_ю8(М, дані.ідентифікатор.значення);
        МаМа::покласти_вказівку_Визначити(код, елемент.місцезнаходження.рядок як п32, позиція_назви);
      } інакше якщо елемент.вид == АСДВидСтруктура {
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, елемент);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
        ціль дані = елемент.дані як адреса<АСДДаніСтруктура>;
        ціль позиція_назви = МаМа::позиція_назви_з_ю8(М, дані.ідентифікатор.значення);
        МаМа::покласти_вказівку_Визначити(код, елемент.місцезнаходження.рядок як п32, позиція_назви);
      } інакше якщо елемент.вид == АСДВидЧисло {
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, елемент);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
        МаМа::покласти_вказівку_Забрати(код, елемент.місцезнаходження.рядок як п32);
      } інакше якщо елемент.вид == АСДВидТекст {
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, елемент);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
        МаМа::покласти_вказівку_Забрати(код, елемент.місцезнаходження.рядок як п32);
      } інакше якщо елемент.вид == АСДВидОперація {
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, елемент);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
        МаМа::покласти_вказівку_Забрати(код, елемент.місцезнаходження.рядок як п32);
      } інакше якщо елемент.вид == АСДВидЯкщо {
        ціль дані = елемент.дані як адреса<АСДДаніЯкщо>;
        ціль помилка_компіляції = виділити_помилку_компіляції(елемент.місцезнаходження, ю8"Якщо не втілено");
        вернути помилка_компіляції;
      } інакше якщо елемент.вид == АСДВидПоки {
        ціль дані = елемент.дані як адреса<АСДДаніПоки>;
        ціль позиція_вказівки_початку_поки = код.накопичувач_вказівок.розмір;
        змінна ціль позиція_вказівки_якщо_ні = 0п32;
        якщо дані.умова != пусто {
          ціль помилка_компіляції_умови = скомпілювати_елемент_значення(М, контекст, код, дані.умова);
          якщо помилка_компіляції_умови != пусто {
            вернути помилка_компіляції_умови;
          }
          позиція_вказівки_якщо_ні = код.накопичувач_вказівок.розмір;
          МаМа::покласти_вказівку_СтрибнутиЯкщоНі(код, елемент.місцезнаходження.рядок як п32, 0);
        }
        ціль контекст_циклу = виділити_контекст_компіляції();
        ціль помилка_компіляції_тіла = скомпілювати_тіло(М, контекст_циклу, код, дані.тіло);
        якщо помилка_компіляції_тіла != пусто {
          вернути помилка_компіляції_тіла;
        }
        МаМа::покласти_вказівку_Стрибнути(код, елемент.місцезнаходження.рядок як п32, позиція_вказівки_початку_поки);
        якщо дані.умова != пусто {
          код.накопичувач_вказівок.дані[позиція_вказівки_якщо_ні + 1] = код.накопичувач_вказівок.розмір;
        }
      } інакше якщо елемент.вид == АСДВидВернути {
        ціль дані = елемент.дані як адреса<АСДДаніВернути>;
        якщо дані.значення == пусто {
          МаМа::покласти_вказівку_ПокластиПусто(код, елемент.місцезнаходження.рядок як п32);
        } інакше {
          ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, дані.значення);
          якщо помилка_компіляції_значення != пусто {
            вернути помилка_компіляції_значення;
          }
        }
        МаМа::покласти_вказівку_Вернути(код, елемент.місцезнаходження.рядок як п32);
      } інакше якщо елемент.вид == АСДВидЗначенняЯкщо {
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, елемент);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
        МаМа::покласти_вказівку_Забрати(код, елемент.місцезнаходження.рядок як п32);
      } інакше якщо елемент.вид == АСДВидЯк {
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, елемент);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
        МаМа::покласти_вказівку_Забрати(код, елемент.місцезнаходження.рядок як п32);
      } інакше якщо елемент.вид == АСДВидСамоОперація {
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, елемент);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
        МаМа::покласти_вказівку_Забрати(код, елемент.місцезнаходження.рядок як п32);
      } інакше якщо елемент.вид == АСДВидМодуль {
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, елемент);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
        ціль дані = елемент.дані як адреса<АСДДаніМодуль>;
        ціль позиція_назви = МаМа::позиція_назви_з_ю8(М, дані.ідентифікатор.значення);
        МаМа::покласти_вказівку_Визначити(код, елемент.місцезнаходження.рядок як п32, позиція_назви);
      } інакше якщо елемент.вид == АСДВидСписок {
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, елемент);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
        МаМа::покласти_вказівку_Забрати(код, елемент.місцезнаходження.рядок як п32);
      } інакше якщо елемент.вид == АСДВидСловник {
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, елемент);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
        МаМа::покласти_вказівку_Забрати(код, елемент.місцезнаходження.рядок як п32);
      } інакше якщо елемент.вид == АСДВидВзяти {
        ціль дані = елемент.дані як адреса<АСДДаніВзяти>;
        змінна ціль позиція_назви_типу = МаМа::позиція_назви_з_ю8(М, ю8"модуль");
        якщо дані.тип != пусто {
          позиція_назви_типу = МаМа::позиція_назви_з_ю8(М, дані.тип.значення);
        }
        змінна ціль позиція_останьої_назви: п32 = 0;
        змінна ціль пш: позитивне = 0;
        поки пш < дані.довжина_шляху {
          ціль елемент_шляху = дані.шлях[пш];
          ціль позиція_назви = МаМа::позиція_назви_з_ю8(М, елемент_шляху.значення);
          МаМа::покласти_вказівку_НакопичитиНазву(код, елемент.місцезнаходження.рядок як п32, позиція_назви);
          якщо пш == дані.довжина_шляху - 1 {
            позиція_останьої_назви = позиція_назви;
          }
          пш += 1;
        }
        МаМа::покласти_вказівку_Взяти(код, елемент.місцезнаходження.рядок як п32, позиція_назви_типу);
        МаМа::покласти_вказівку_Визначити(код, елемент.місцезнаходження.рядок як п32, позиція_останьої_назви);
      } інакше якщо елемент.вид == АСДВидСпробувати {
        ціль дані = елемент.дані як адреса<АСДДаніСпробувати>;
        ціль позиція_вказівки_почати_спробу = код.накопичувач_вказівок.розмір;
        МаМа::покласти_вказівку_ПочатиСпробу(код, елемент.місцезнаходження.рядок як п32, 0);
        ціль помилка_компіляції_тіла = скомпілювати_тіло(М, контекст, код, дані.тіло);
        якщо помилка_компіляції_тіла != пусто {
          вернути помилка_компіляції_тіла;
        }
        ціль позиція_вказівки_закінчити_спробу = код.накопичувач_вказівок.розмір;
        МаМа::покласти_вказівку_ЗакінчитиСпробу(код, елемент.місцезнаходження.рядок як п32, 0);
        якщо дані.ідентифікатор_зловити == пусто {
          МаМа::покласти_вказівку_Забрати(код, елемент.місцезнаходження.рядок як п32);
        } інакше {
          ціль позиція_назви = МаМа::позиція_назви_з_ю8(М, дані.ідентифікатор_зловити.значення);
          МаМа::покласти_вказівку_Визначити(код, елемент.місцезнаходження.рядок як п32, позиція_назви);
        }
        код.накопичувач_вказівок.дані[позиція_вказівки_почати_спробу + 1] = код.накопичувач_вказівок.розмір;
        ціль помилка_компіляції_тіла_зловити = скомпілювати_тіло(М, контекст, код, дані.тіло_зловити);
        якщо помилка_компіляції_тіла_зловити != пусто {
          вернути помилка_компіляції_тіла_зловити;
        }
        код.накопичувач_вказівок.дані[позиція_вказівки_закінчити_спробу + 1] = код.накопичувач_вказівок.розмір;
      } інакше якщо елемент.вид == АСДВидВпасти {
        ціль дані = елемент.дані як адреса<АСДДаніВпасти>;
        якщо дані.значення == пусто {
          МаМа::покласти_вказівку_ПокластиПусто(код, елемент.місцезнаходження.рядок як п32);
        } інакше {
          ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, дані.значення);
          якщо помилка_компіляції_значення != пусто {
            вернути помилка_компіляції_значення;
          }
        }
        МаМа::покласти_вказівку_Впасти(код, елемент.місцезнаходження.рядок як п32);
      } інакше якщо елемент.вид == АСДВидДати {
        ціль дані = елемент.дані як адреса<АСДДаніДати>;
        змінна ціль пед: позитивне = 0;
        поки пед < дані.кількість_елементів {
          ціль елемент = дані.елементи[пед];
          ціль позиція_назви = МаМа::позиція_назви_з_ю8(М, елемент.ідентифікатор.значення);
          змінна ціль позиція_назви_як = позиція_назви;
          якщо елемент.ідентифікатор_як != пусто {
            позиція_назви_як = МаМа::позиція_назви_з_ю8(М, елемент.ідентифікатор_як.значення);
          }
          МаМа::покласти_вказівку_Звернутись(код, елемент.місцезнаходження.рядок як п32, позиція_назви);
          МаМа::покласти_вказівку_Дати(код, елемент.місцезнаходження.рядок як п32, позиція_назви_як);
          пед += 1;
        }
      } інакше {
        вернути виділити_помилку_компіляції(елемент.місцезнаходження, ю8"Невідомий вид АСДЗначення!");
      }
      пе = пе + 1;
    }
    вернути пусто;
  }

  місцева дія звільнити_контекст_компіляції(контекст: адреса<КонтекстКомпіляції>) {
    звільнити(контекст);
  }
}