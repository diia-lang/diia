взяти визначення компілятор;

секція мама {
  місцева дія успіх_компіляції(): РезультатКомпіляції {
    вернути РезультатКомпіляції { успіх = 1, помилка = ПомилкаКомпіляції { пусто, пусто } };
  }

  місцева дія помилка_компіляції(місцезнаходження: комірка<Місцезнаходження>, повідомлення: памʼять<п8>): РезультатКомпіляції {
    вернути РезультатКомпіляції { успіх = 0, помилка = ПомилкаКомпіляції { місцезнаходження, повідомлення } };
  }

  дія отримати_контекст_компіляції_циклу(контекст: комірка<КонтекстКомпіляції>): комірка<КонтекстКомпіляції> {
    змінна к = контекст;
    поки к != пусто {
      якщо к.тип == ККДія {
        вернути пусто;
      }
      якщо к.тип == ККЦикл {
        вернути к;
      }
      к = к.предок;
    }
    вернути пусто;
  }

  дія отримати_контекст_компіляції_дії(контекст: комірка<КонтекстКомпіляції>): комірка<КонтекстКомпіляції> {
    змінна к = контекст;
    поки к != пусто {
      якщо к.тип == ККДія {
        вернути к;
      }
      якщо к.тип == ККЦикл {
      }
      к = к.предок;
    }
    вернути пусто;
  }

  дія створити_контекст_компіляції_циклу(предок: комірка<КонтекстКомпіляції>): комірка<КонтекстКомпіляції> {
    ціль контекст_циклу = виділити<КонтекстКомпіляції>();
    контекст_циклу.предок = предок;
    контекст_циклу.тип = ККЦикл;
    контекст_циклу.цикл_позиції_вказівок_пропустити = створити_вектор<позитивне>();
    контекст_циклу.цикл_позиції_вказівок_перервати = створити_вектор<позитивне>();
    вернути контекст_циклу;
  }

  дія створити_контекст_компіляції_дії(предок: комірка<КонтекстКомпіляції>): комірка<КонтекстКомпіляції> {
    ціль контекст_циклу = виділити<КонтекстКомпіляції>();
    контекст_циклу.предок = предок;
    контекст_циклу.тип = ККДія;
    контекст_циклу.цикл_позиції_вказівок_пропустити = пусто;
    контекст_циклу.цикл_позиції_вказівок_перервати = пусто;
    вернути контекст_циклу;
  }

  дія звільнити_контекст_компіляції(контекст: комірка<КонтекстКомпіляції>) {
    якщо контекст.цикл_позиції_вказівок_пропустити != пусто {
      звільнити_вектор<позитивне>(контекст.цикл_позиції_вказівок_пропустити);
    }
    якщо контекст.цикл_позиції_вказівок_перервати != пусто {
      звільнити_вектор<позитивне>(контекст.цикл_позиції_вказівок_перервати);
    }
    звільнити(контекст);
  }

  дія заповнити_позиції_вказівок_контексту_циклу(контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, позиція_пропустити: позитивне, позиція_перервати: позитивне) {
    змінна х = 0;
    поки х < контекст.цикл_позиції_вказівок_пропустити.довжина {
      ціль позиція = контекст.цикл_позиції_вказівок_пропустити.дані[х];
      код.дані[позиція].дані = позиція_пропустити;
      х = х + 1;
    }
    х = 0;
    поки х < контекст.цикл_позиції_вказівок_перервати.довжина {
      ціль позиція = контекст.цикл_позиції_вказівок_перервати.дані[х];
      код.дані[позиція].дані = позиція_перервати;
      х = х + 1;
    }
  }

  місцева дія скомпілювати(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    змінна результат: РезультатКомпіляції;
    якщо асд.вид == АСДВидВизначитиСубʼєкт {
      вернути скомпілювати_визначити_субʼєкт(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидЗвернутисьДоСубʼєкта {
      вернути скомпілювати_звернутись_до_субʼєкта(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидОтриматиВластивість {
      вернути скомпілювати_отримати_властивість(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидЗмінитиВластивість {
      вернути скомпілювати_змінити_властивість(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидОтриматиЕлемент {
      вернути скомпілювати_отримати_елемент(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидПокластиЕлемент {
      вернути скомпілювати_покласти_елемент(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидСтворитиПусто {
      вернути скомпілювати_створити_пусто(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидСтворитиТак {
      вернути скомпілювати_створити_так(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидСтворитиНі {
      вернути скомпілювати_створити_ні(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидСтворитиЧисло {
      вернути скомпілювати_створити_число(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидСтворитиТекст {
      вернути скомпілювати_створити_текст(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидСтворитиСимвол {
      вернути скомпілювати_створити_символ(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидСтворитиСтруктуру {
      вернути скомпілювати_створити_структуру(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидСтворитиДію {
      вернути скомпілювати_створити_дію(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидВернути {
      вернути скомпілювати_вернути(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидСтворитиДіюДляСтруктури {
      вернути скомпілювати_створити_дію_для_структури(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидСтворитиМодуль {
      вернути скомпілювати_створити_модуль(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидДати {
      вернути скомпілювати_дати(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидСтворитиСписок {
      вернути скомпілювати_створити_список(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидСтворитиСловник {
      вернути скомпілювати_створити_словник(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидВиконатиДію {
      вернути скомпілювати_виконати_дію(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидОперація {
      вернути скомпілювати_операція(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидСамоОперація {
      вернути скомпілювати_само_операція(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидСтворитиБога {
      вернути скомпілювати_створити_бога(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидСтворитиШаблонСтруктури {
      вернути скомпілювати_створити_шаблон_структури(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидСтворитиШаблонДії {
      вернути скомпілювати_створити_шаблон_дії(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидВиконатиШаблон {
      вернути скомпілювати_виконати_шаблон(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидЗначенняЯкщо {
      вернути скомпілювати_значення_якщо(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидЧекати {
      вернути скомпілювати_чекати(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидЯк {
      вернути скомпілювати_як(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидЯкщо {
      вернути скомпілювати_якщо(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидПоки {
      вернути скомпілювати_поки(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидВзяти {
      вернути скомпілювати_взяти(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидСпробувати {
      вернути скомпілювати_спробувати(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидВпасти {
      вернути скомпілювати_впасти(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидПеребрати {
      вернути скомпілювати_перебрати(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидПеребратиДіапазон {
      вернути скомпілювати_перебрати_діапазон(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидПропустити {
      вернути скомпілювати_пропустити(М, контекст, код, асд);
    } інакше якщо асд.вид == АСДВидПерервати {
      вернути скомпілювати_перервати(М, контекст, код, асд);
    } інакше {
      біб::друк_ціле(асд.вид);
      вернути помилка_компіляції(асд.місцезнаходження, ю8"Невідомий вид АСД");
    }
  }

  місцева дія скомпілювати_тіло(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, тіло: СписокАСДЗначень): РезультатКомпіляції {
    змінна х = 0;
    поки х < тіло.розмір {
      ціль асд = тіло.елементи[х];
      змінна результат: РезультатКомпіляції = скомпілювати(М, контекст, код, асд);
      якщо результат.успіх == 0 {
        вернути результат;
      }
      якщо асд.вид == АСДВидЗвернутисьДоСубʼєкта {
        вказівка_забрати(М, код, пусто);
      } інакше якщо асд.вид == АСДВидОтриматиВластивість {
        вказівка_забрати(М, код, пусто);
      } інакше якщо асд.вид == АСДВидОтриматиЕлемент {
        вказівка_забрати(М, код, пусто);
      } якщо асд.вид == АСДВидСтворитиПусто {
        вказівка_забрати(М, код, пусто);
      } якщо асд.вид == АСДВидСтворитиТак {
        вказівка_забрати(М, код, пусто);
      } якщо асд.вид == АСДВидСтворитиНі {
        вказівка_забрати(М, код, пусто);
      } якщо асд.вид == АСДВидСтворитиЧисло {
        вказівка_забрати(М, код, пусто);
      } інакше якщо асд.вид == АСДВидСтворитиТекст {
        вказівка_забрати(М, код, пусто);
      } інакше якщо асд.вид == АСДВидСтворитиСимвол {
        вказівка_забрати(М, код, пусто);
      } інакше якщо асд.вид == АСДВидСтворитиСтруктуру {
        вказівка_забрати(М, код, пусто);
      } інакше якщо асд.вид == АСДВидСтворитиДію {
        вказівка_забрати(М, код, пусто);
      } якщо асд.вид == АСДВидСтворитиМодуль {
        вказівка_забрати(М, код, пусто);
      } інакше якщо асд.вид == АСДВидСтворитиСписок {
        вказівка_забрати(М, код, пусто);
      } інакше якщо асд.вид == АСДВидСтворитиСловник {
        вказівка_забрати(М, код, пусто);
      } інакше якщо асд.вид == АСДВидВиконатиДію {
        вказівка_забрати(М, код, пусто);
      } інакше якщо асд.вид == АСДВидОперація {
        вказівка_забрати(М, код, пусто);
      } інакше якщо асд.вид == АСДВидСамоОперація {
        вказівка_забрати(М, код, пусто);
      } інакше якщо асд.вид == АСДВидСтворитиБога {
        вказівка_забрати(М, код, пусто);
      } інакше якщо асд.вид == АСДВидСтворитиШаблонСтруктури {
        вказівка_забрати(М, код, пусто);
      } інакше якщо асд.вид == АСДВидСтворитиШаблонДії {
        вказівка_забрати(М, код, пусто);
      } інакше якщо асд.вид == АСДВидВиконатиШаблон {
        вказівка_забрати(М, код, пусто);
      } інакше якщо асд.вид == АСДВидЗначенняЯкщо {
        вказівка_забрати(М, код, пусто);
      } інакше якщо асд.вид == АСДВидЧекати {
        вказівка_забрати(М, код, пусто);
      } інакше якщо асд.вид == АСДВидЯк {
        вказівка_забрати(М, код, пусто);
      }
      х = х + 1;
    }
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_визначити_субʼєкт(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<ВизначитиСубʼєктАСДДані>;
    ціль результат_компіляції_значення = скомпілювати(М, контекст, код, дані.значення);
    якщо результат_компіляції_значення.успіх == 0 {
      вернути результат_компіляції_значення;
    }
    ціль ідентифікатор = дані.ідентифікатор.дані як комірка<ІдентифікаторАСДДані>;
    ціль слово = отримати_або_створити_слово(М, ідентифікатор.назва);
    вказівка_визначити_субʼєкт(М, код, асд.місцезнаходження, слово);
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_звернутись_до_субʼєкта(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<ЗвернутисьДоСубʼєктаАСДДані>;
    ціль дані_ідентифікатора = дані.ідентифікатор.дані як комірка<ІдентифікаторАСДДані>;
    ціль слово = отримати_або_створити_слово(М, дані_ідентифікатора.назва);
    вказівка_звернутись_до_субʼєкта(М, код, асд.місцезнаходження, слово);
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_отримати_властивість(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<ОтриматиВластивістьАСДДані>;
    ціль результат_компіляції_субʼєкта = скомпілювати(М, контекст, код, дані.субʼєкт);
    якщо результат_компіляції_субʼєкта.успіх == 0 {
      вернути результат_компіляції_субʼєкта;
    }
    ціль ідентифікатор = дані.ідентифікатор.дані як комірка<ІдентифікаторАСДДані>;
    ціль слово = отримати_або_створити_слово(М, ідентифікатор.назва);
    вказівка_отримати_властивість(М, код, асд.місцезнаходження, слово);
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_змінити_властивість(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<ЗмінитиВластивістьАСДДані>;
    ціль результат_компіляції_субʼєкта = скомпілювати(М, контекст, код, дані.субʼєкт);
    якщо результат_компіляції_субʼєкта.успіх == 0 {
      вернути результат_компіляції_субʼєкта;
    }
    ціль результат_компіляції_значення = скомпілювати(М, контекст, код, дані.значення);
    якщо результат_компіляції_значення.успіх == 0 {
      вернути результат_компіляції_значення;
    }
    ціль ідентифікатор = дані.ідентифікатор.дані як комірка<ІдентифікаторАСДДані>;
    ціль слово = отримати_або_створити_слово(М, ідентифікатор.назва);
    вказівка_змінити_властивість(М, код, асд.місцезнаходження, слово);
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_отримати_елемент(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<ОтриматиЕлементАСДДані>;
    ціль результат_компіляції_субʼєкта = скомпілювати(М, контекст, код, дані.субʼєкт);
    якщо результат_компіляції_субʼєкта.успіх == 0 {
      вернути результат_компіляції_субʼєкта;
    }
    ціль результат_компіляції_ключа = скомпілювати(М, контекст, код, дані.ключ);
    якщо результат_компіляції_ключа.успіх == 0 {
      вернути результат_компіляції_ключа;
    }
    вказівка_отримати_елемент(М, код, асд.місцезнаходження);
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_покласти_елемент(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<ПокластиЕлементАСДДані>;
    ціль результат_компіляції_субʼєкта = скомпілювати(М, контекст, код, дані.субʼєкт);
    якщо результат_компіляції_субʼєкта.успіх == 0 {
      вернути результат_компіляції_субʼєкта;
    }
    ціль результат_компіляції_ключа = скомпілювати(М, контекст, код, дані.ключ);
    якщо результат_компіляції_ключа.успіх == 0 {
      вернути результат_компіляції_ключа;
    }
    ціль результат_компіляції_значення = скомпілювати(М, контекст, код, дані.значення);
    якщо результат_компіляції_значення.успіх == 0 {
      вернути результат_компіляції_значення;
    }
    вказівка_покласти_елемент(М, код, асд.місцезнаходження);
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_створити_пусто(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<СтворитиПустоАСДДані>;
    вказівка_створити_пусто(М, код, асд.місцезнаходження);
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_створити_так(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<СтворитиТакАСДДані>;
    вказівка_створити_так(М, код, асд.місцезнаходження);
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_створити_ні(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<СтворитиНіАСДДані>;
    вказівка_створити_ні(М, код, асд.місцезнаходження);
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_створити_число(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<СтворитиЧислоАСДДані>;
    вказівка_створити_число(М, код, асд.місцезнаходження, перетворити_ю8_в_дійсне(дані.значення));
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_створити_текст(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<СтворитиТекстАСДДані>;
    якщо дані.інтерпольовано == ні {
      ціль результат_розбору_тексту = розібрати_текст_мавки(асд.місцезнаходження.текст_коду, дані.значення, асд.місцезнаходження.рядок, асд.місцезнаходження.стовпець);
      якщо результат_розбору_тексту.успіх == 0 {
        вернути помилка_компіляції(результат_розбору_тексту.помилка.місцезнаходження, результат_розбору_тексту.помилка.повідомлення);
      }
      вернути скомпілювати(М, контекст, код, результат_розбору_тексту.значення);
    }
    ціль обʼєкт_тексту = зробити_безсмертним(М, створити_обʼєкт_текст(М, дані.значення));
    додати_обʼєкт_до_існуючих(М, обʼєкт_тексту);
    вказівка_покласти_обʼєкт(М, код, асд.місцезнаходження, обʼєкт_тексту);
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_створити_символ(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<СтворитиСимволАСДДані>;
    ціль розмір_значення = біб::юнікод::дізнатись_розмір_ю8_сі(дані.значення);
    ціль ю32 = виділити<п32>(розмір_значення + 1);
    ціль розмір_виходу = біб::юнікод::ю8_в_ю32(дані.значення, розмір_значення, ю32);
    ю32[розмір_виходу] = 0;
    ціль довжина = довжина_ю32(ю32);
    якщо довжина != 1 {
      вернути помилка_компіляції(асд.місцезнаходження, ю8"Символ повинен бути довжиною 1");
    }
    вказівка_створити_символ(М, код, асд.місцезнаходження, ю32[0]);
    звільнити(ю32);
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_створити_структуру(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<СтворитиСтруктуруАСДДані>;
    якщо дані.предок != пусто {
      ціль результат_компіляції_предка = скомпілювати(М, контекст, код, дані.предок);
      якщо результат_компіляції_предка.успіх == 0 {
        вернути результат_компіляції_предка;
      }
    } інакше {
      вказівка_покласти_структуру_обʼєкт(М, код, пусто);
    }
    якщо дані.ідентифікатор == пусто {
      вказівка_створити_структуру(М, код, асд.місцезнаходження, пусто);
    } інакше {
      ціль ідентифікатор = дані.ідентифікатор.дані як комірка<ІдентифікаторАСДДані>;
      ціль слово = отримати_або_створити_слово(М, ідентифікатор.назва);
      вказівка_створити_структуру(М, код, асд.місцезнаходження, слово);
    }
    змінна пх = 0;
    поки пх < дані.елементи.розмір {
      ціль елемент = дані.елементи.елементи[пх];
      якщо елемент.вид == АСДВидПараметрСтруктури {
        ціль дані_параметра = елемент.дані як комірка<ПараметрСтруктуриАСДДані>;
        ціль ідентифікатор = дані_параметра.ідентифікатор.дані як комірка<ІдентифікаторАСДДані>;
        ціль слово = отримати_або_створити_слово(М, ідентифікатор.назва);
        змінна тип_може_бути_пусто = 0;
        змінна має_значення_за_замовчуванням = 0;
        якщо дані_параметра.тип != пусто {
          ціль дані_типу = дані_параметра.тип.дані як комірка<ТипАСДДані>;
          якщо дані_типу.може_бути_пусто == 1 {
            тип_може_бути_пусто = 1;
          }
          ціль результат_компіляції_типу = скомпілювати(М, контекст, код, дані_типу.значення);
          якщо результат_компіляції_типу.успіх == 0 {
            вернути результат_компіляції_типу;
          }
        } інакше {
          тип_може_бути_пусто = 1;
          вказівка_покласти_структуру_обʼєкт(М, код, пусто);
        }
        якщо дані_параметра.значення != пусто {
          якщо дані_параметра.значення.вид != АСДВидСтворитиПусто {
            якщо дані_параметра.значення.вид != АСДВидСтворитиТак {
              якщо дані_параметра.значення.вид != АСДВидСтворитиНі {
                якщо дані_параметра.значення.вид != АСДВидСтворитиЧисло {
                  якщо дані_параметра.значення.вид != АСДВидСтворитиТекст {
                    якщо дані_параметра.значення.вид != АСДВидСтворитиСимвол {
                      вернути помилка_компіляції(дані_параметра.значення.місцезнаходження, ю8"Таке значення за замовчуванням тимчасово не підтримується");
                    }
                  }
                }
              }
            }
          }
          ціль результат_компіляції_значення = скомпілювати(М, контекст, код, дані_параметра.значення);
          якщо результат_компіляції_значення.успіх == 0 {
            вернути результат_компіляції_значення;
          }
          має_значення_за_замовчуванням = 1;
        } інакше {
          вказівка_створити_пусто(М, код, пусто);
        }
        вказівка_зберегти_параметр_структури(М, код, елемент.місцезнаходження, пх, слово, тип_може_бути_пусто, має_значення_за_замовчуванням);
      }
      пх = пх + 1;
    }
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_створити_дію(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<СтворитиДіюАСДДані>;
    якщо дані.чи_тривала == 1 {
      вернути помилка_компіляції(асд.місцезнаходження, ю8"Не втілено");
    }
    ціль контекст_дії = створити_контекст_компіляції_дії(контекст);
    відкласти звільнити_контекст_компіляції(контекст_дії);
    ціль код_тіла = створити_вектор<Вказівка>();
    ціль результат_компіляції_тіла = скомпілювати_тіло(М, контекст_дії, код_тіла, дані.тіло);
    якщо результат_компіляції_тіла.успіх == 0 {
      вернути результат_компіляції_тіла;
    }
    вказівка_створити_пусто(М, код_тіла, пусто);
    вказівка_вернути(М, код_тіла, асд.місцезнаходження);
    змінна тип_повернення_може_бути_пусто = 0;
    якщо дані.тип_повернення != пусто {
      ціль дані_типу = дані.тип_повернення.дані як комірка<ТипАСДДані>;
      якщо дані_типу.може_бути_пусто == 1 {
        тип_повернення_може_бути_пусто = 1;
      }
      ціль результат_компіляції_типу_повернення = скомпілювати(М, контекст, код, дані_типу.значення);
      якщо результат_компіляції_типу_повернення.успіх == 0 {
        вернути результат_компіляції_типу_повернення;
      }
    } інакше {
      тип_повернення_може_бути_пусто = 1;
      вказівка_покласти_структуру_обʼєкт(М, код, пусто);
    }
    якщо дані.ідентифікатор == пусто {
      вказівка_створити_дію(М, код, асд.місцезнаходження, пусто, код_тіла, тип_повернення_може_бути_пусто);
    } інакше {
      ціль ідентифікатор = дані.ідентифікатор.дані як комірка<ІдентифікаторАСДДані>;
      ціль слово = отримати_або_створити_слово(М, ідентифікатор.назва);
      вказівка_створити_дію(М, код, асд.місцезнаходження, слово, код_тіла, тип_повернення_може_бути_пусто);
    }
    змінна пх = 0;
    поки пх < дані.параметри.розмір {
      ціль параметр = дані.параметри.елементи[пх];
      ціль дані_параметра = параметр.дані як комірка<ПараметрДіїАСДДані>;
      ціль ідентифікатор = дані_параметра.ідентифікатор.дані як комірка<ІдентифікаторАСДДані>;
      ціль слово = отримати_або_створити_слово(М, ідентифікатор.назва);
      змінна тип_може_бути_пусто = 0;
      змінна має_значення_за_замовчуванням = 0;
      якщо дані_параметра.тип != пусто {
        ціль дані_типу = дані_параметра.тип.дані як комірка<ТипАСДДані>;
        якщо дані_типу.може_бути_пусто == 1 {
          тип_може_бути_пусто = 1;
        }
        ціль результат_компіляції_типу = скомпілювати(М, контекст, код, дані_типу.значення);
        якщо результат_компіляції_типу.успіх == 0 {
          вернути результат_компіляції_типу;
        }
      } інакше {
        тип_може_бути_пусто = 1;
        вказівка_покласти_структуру_обʼєкт(М, код, пусто);
      }
      якщо дані_параметра.значення != пусто {
        якщо дані_параметра.значення.вид != АСДВидСтворитиПусто {
          якщо дані_параметра.значення.вид != АСДВидСтворитиТак {
            якщо дані_параметра.значення.вид != АСДВидСтворитиНі {
              якщо дані_параметра.значення.вид != АСДВидСтворитиЧисло {
                якщо дані_параметра.значення.вид != АСДВидСтворитиТекст {
                  якщо дані_параметра.значення.вид != АСДВидСтворитиСимвол {
                    вернути помилка_компіляції(дані_параметра.значення.місцезнаходження, ю8"Таке значення за замовчуванням тимчасово не підтримується");
                  }
                }
              }
            }
          }
        }
        ціль результат_компіляції_значення = скомпілювати(М, контекст, код, дані_параметра.значення);
        якщо результат_компіляції_значення.успіх == 0 {
          вернути результат_компіляції_значення;
        }
        має_значення_за_замовчуванням = 1;
      } інакше {
        вказівка_створити_пусто(М, код, пусто);
      }
      вказівка_зберегти_параметр_дії(М, код, параметр.місцезнаходження, пх, слово, тип_може_бути_пусто, має_значення_за_замовчуванням);
      пх = пх + 1;
    }
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_вернути(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<ВернутиАСДДані>;
    ціль контекст_дії = отримати_контекст_компіляції_дії(контекст);
    якщо контекст_дії == пусто {
      вернути помилка_компіляції(асд.місцезнаходження, ю8"Вернути можна використовувати тільки всередині дії");
    }
    якщо дані.значення == пусто {
      вказівка_створити_пусто(М, код, пусто);
    } інакше {
      ціль результат_компіляції_значення = скомпілювати(М, контекст, код, дані.значення);
      якщо результат_компіляції_значення.успіх == 0 {
        вернути результат_компіляції_значення;
      }
    }
    вказівка_вернути(М, код, асд.місцезнаходження);
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_створити_дію_для_структури(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<СтворитиДіюДляСтруктуриАСДДані>;
    ціль результат_компіляції_структури = скомпілювати(М, контекст, код, дані.для_структури);
    якщо результат_компіляції_структури.успіх == 0 {
      вернути результат_компіляції_структури;
    }
    ціль результат_компіляції_дії = скомпілювати(М, контекст, код, дані.значення_дії);
    якщо результат_компіляції_дії.успіх == 0 {
      вернути результат_компіляції_дії;
    }
    вказівка_створити_дію_для_структури(М, код, асд.місцезнаходження);
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_створити_модуль(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<СтворитиМодульАСДДані>;
    ціль код_тіла = створити_вектор<Вказівка>();
    ціль результат_компіляції_тіла = скомпілювати_тіло(М, контекст, код_тіла, дані.тіло);
    якщо результат_компіляції_тіла.успіх == 0 {
      вернути результат_компіляції_тіла;
    }
    якщо дані.ідентифікатор == пусто {
      вказівка_створити_модуль(М, код, асд.місцезнаходження, пусто, код_тіла);
    } інакше {
      ціль ідентифікатор = дані.ідентифікатор.дані як комірка<ІдентифікаторАСДДані>;
      ціль слово = отримати_або_створити_слово(М, ідентифікатор.назва);
      вказівка_створити_модуль(М, код, асд.місцезнаходження, слово, код_тіла);
    }
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_дати(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<ДатиАСДДані>;
    змінна х = 0;
    поки х < дані.елементи.розмір {
      ціль елемент = дані.елементи.елементи[х];
      ціль дані_елемента = елемент.дані як комірка<ЕлементДатиАСДДані>;
      ціль результат_компіляції_субʼєкта = скомпілювати(М, контекст, код, дані_елемента.субʼєкт);
      якщо результат_компіляції_субʼєкта.успіх == 0 {
          вернути результат_компіляції_субʼєкта;
      }
      ціль ідентифікатор = дані_елемента.ідентифікатор.дані як комірка<ІдентифікаторАСДДані>;
      ціль слово = отримати_або_створити_слово(М, ідентифікатор.назва);
      вказівка_дати(М, код, асд.місцезнаходження, слово);
      х = х + 1;
    }
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_створити_список(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<СтворитиСписокАСДДані>;
    вказівка_створити_список(М, код, асд.місцезнаходження);
    змінна х = 0;
    поки х < дані.елементи.розмір {
      ціль елемент = дані.елементи.елементи[х];
      ціль результат_компіляції_елемента = скомпілювати(М, контекст, код, елемент);
      якщо результат_компіляції_елемента.успіх == 0 {
        вернути результат_компіляції_елемента;
      }
      вказівка_додати_елемент_до_списку(М, код, елемент.місцезнаходження);
      х = х + 1;
    }
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_створити_словник(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<СтворитиСловникАСДДані>;
    вказівка_створити_словник(М, код, асд.місцезнаходження);
    змінна х = 0;
    поки х < дані.елементи.розмір {
      ціль елемент = дані.елементи.елементи[х];
      ціль елемент_дані = елемент.дані як комірка<ЕлементСловникаАСДДані>;
      ціль результат_компіляції_ключа = скомпілювати(М, контекст, код, елемент_дані.ключ);
      якщо результат_компіляції_ключа.успіх == 0 {
        вернути результат_компіляції_ключа;
      }
      ціль результат_компіляції_значення = скомпілювати(М, контекст, код, елемент_дані.значення);
      якщо результат_компіляції_значення.успіх == 0 {
        вернути результат_компіляції_значення;
      }
      вказівка_додати_елемент_до_словника(М, код, елемент.місцезнаходження);
      х = х + 1;
    }
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_виконати_дію(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<ВиконатиДіюАСДДані>;
    змінна х = 0;
    поки х < дані.аргументи.розмір {
      ціль аргумент = дані.аргументи.елементи[х];
      якщо аргумент.вид == АСДВидАргументВиконанняДіїЗНазвою {
        ціль аргумент_дані = аргумент.дані як комірка<АргументВиконанняДіїЗНазвоюАСДДані>;
        ціль результат_компіляції_аргумента = скомпілювати(М, контекст, код, аргумент_дані.значення);
        якщо результат_компіляції_аргумента.успіх == 0 {
          вернути результат_компіляції_аргумента;
        }
        ціль ідентифікатор = аргумент_дані.ідентифікатор.дані як комірка<ІдентифікаторАСДДані>;
        ціль слово = отримати_або_створити_слово(М, ідентифікатор.назва);
        вказівка_створити_слово(М, код, пусто, слово);
      } інакше {
        ціль результат_компіляції_аргумента = скомпілювати(М, контекст, код, аргумент);
        якщо результат_компіляції_аргумента.успіх == 0 {
          вернути результат_компіляції_аргумента;
        }
      }
      х = х + 1;
    }
    ціль результат_компіляції_субʼєкта = скомпілювати(М, контекст, код, дані.субʼєкт);
    якщо результат_компіляції_субʼєкта.успіх == 0 {
      вернути результат_компіляції_субʼєкта;
    }
    вказівка_виконати_дію(М, код, асд.місцезнаходження, дані.аргументи.розмір);
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_операція(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<ОпераціяАСДДані>;
    ціль результат_компіляції_ліво = скомпілювати(М, контекст, код, дані.ліво);
    якщо результат_компіляції_ліво.успіх == 0 {
      вернути результат_компіляції_ліво;
    }
    якщо дані.операція == ОпераціяПеревіритиЧиОбоєТак {
      ціль позиція_вказівки_стрибнути_якщо_ні = код.довжина;
      вказівка_стрибнути_якщо_ні_х(М, код, асд.місцезнаходження, 0);
      вказівка_забрати(М, код, асд.місцезнаходження);
      ціль результат_компіляції_право = скомпілювати(М, контекст, код, дані.право);
      якщо результат_компіляції_право.успіх == 0 {
        вернути результат_компіляції_право;
      }
      код.дані[позиція_вказівки_стрибнути_якщо_ні].дані = код.довжина;
      вернути успіх_компіляції();
    } інакше якщо дані.операція == ОпераціяПеревіритиЧиЯкийсьТак {
      ціль позиція_вказівки_стрибнути_якщо_так = код.довжина;
      вказівка_стрибнути_якщо_так_х(М, код, асд.місцезнаходження, 0);
      вказівка_забрати(М, код, асд.місцезнаходження);
      ціль результат_компіляції_право = скомпілювати(М, контекст, код, дані.право);
      якщо результат_компіляції_право.успіх == 0 {
        вернути результат_компіляції_право;
      }
      код.дані[позиція_вказівки_стрибнути_якщо_так].дані = код.довжина;
      вернути успіх_компіляції();
    }
    ціль результат_компіляції_право = скомпілювати(М, контекст, код, дані.право);
    якщо результат_компіляції_право.успіх == 0 {
      вернути результат_компіляції_право;
    }
    якщо дані.операція == ОпераціяДодати {
      вказівка_додати(М, код, асд.місцезнаходження);
    } інакше якщо дані.операція == ОпераціяВідняти {
      вказівка_відняти(М, код, асд.місцезнаходження);
    } інакше якщо дані.операція == ОпераціяПомножити {
      вказівка_помножити(М, код, асд.місцезнаходження);
    } інакше якщо дані.операція == ОпераціяПоділити {
      вказівка_поділити(М, код, асд.місцезнаходження);
    } інакше якщо дані.операція == ОпераціяПоділитиЗаМодулем {
      вказівка_поділити_за_модулем(М, код, асд.місцезнаходження);
    } інакше якщо дані.операція == ОпераціяПоділитиНаціло {
      вказівка_поділити_націло(М, код, асд.місцезнаходження);
    } інакше якщо дані.операція == ОпераціяПіднестиДоСтепеня {
      вказівка_піднести_до_степеня(М, код, асд.місцезнаходження);
    } інакше якщо дані.операція == ОпераціяДвійковеІ {
      вказівка_двійкове_і(М, код, асд.місцезнаходження);
    } інакше якщо дані.операція == ОпераціяДвійковеАбо {
      вказівка_двійкове_або(М, код, асд.місцезнаходження);
    } інакше якщо дані.операція == ОпераціяДвійковеВиключнеАбо {
      вказівка_двійкове_виключне_або(М, код, асд.місцезнаходження);
    } інакше якщо дані.операція == ОпераціяДвійковийЗсувВліво {
      вказівка_двійковий_зсув_вліво(М, код, асд.місцезнаходження);
    } інакше якщо дані.операція == ОпераціяДвійковийЗсувВправо {
      вказівка_двійковий_зсув_вправо(М, код, асд.місцезнаходження);
    } інакше якщо дані.операція == ОпераціяДвійковийЗсувВправоЗЗаповненням {
      вказівка_двійковий_зсув_вправо_з_заповненням(М, код, асд.місцезнаходження);
    } інакше якщо дані.операція == ОпераціяПорівнятиЧиРівно {
      вказівка_порівняти_чи_рівно(М, код, асд.місцезнаходження);
    } інакше якщо дані.операція == ОпераціяПорівнятиЧиНеРівно {
      вказівка_порівняти_чи_рівно(М, код, асд.місцезнаходження);
      вказівка_заперечити(М, код, асд.місцезнаходження);
    } інакше якщо дані.операція == ОпераціяПорівнятиЧиБільше {
      вказівка_порівняти_чи_більше(М, код, асд.місцезнаходження);
    } інакше якщо дані.операція == ОпераціяПорівнятиЧиМенше {
      вказівка_порівняти_чи_менше(М, код, асд.місцезнаходження);
    } інакше якщо дані.операція == ОпераціяПорівнятиЧиНеБільше {
      вказівка_порівняти_чи_більше(М, код, асд.місцезнаходження);
      вказівка_заперечити(М, код, асд.місцезнаходження);
    } інакше якщо дані.операція == ОпераціяПорівнятиЧиНеМенше {
      вказівка_порівняти_чи_менше(М, код, асд.місцезнаходження);
      вказівка_заперечити(М, код, асд.місцезнаходження);
    } інакше якщо дані.операція == ОпераціяПорівнятиЧиЄ {
      вказівка_порівняти_чи_є(М, код, асд.місцезнаходження);
    } інакше якщо дані.операція == ОпераціяПорівнятиЧиНеЄ {
      вказівка_порівняти_чи_є(М, код, асд.місцезнаходження);
      вказівка_заперечити(М, код, асд.місцезнаходження);
    } інакше якщо дані.операція == ОпераціяПорівнятиЧиМістить {
      вказівка_порівняти_чи_містить(М, код, асд.місцезнаходження);
    } інакше якщо дані.операція == ОпераціяПорівнятиЧиНеМістить {
      вказівка_порівняти_чи_містить(М, код, асд.місцезнаходження);
      вказівка_заперечити(М, код, асд.місцезнаходження);
    } інакше {
      вернути помилка_компіляції(асд.місцезнаходження, ю8"Невідома бінарна операція");
    }
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_само_операція(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<СамоОпераціяАСДДані>;
    ціль результат_компіляції_значення = скомпілювати(М, контекст, код, дані.значення);
    якщо результат_компіляції_значення.успіх == 0 {
      вернути результат_компіляції_значення;
    }
    якщо дані.операція == СамоОпераціяЗробитиВідʼємним {
      вказівка_зробити_відʼємним(М, код, асд.місцезнаходження);
    } інакше якщо дані.операція == СамоОпераціяДвійковеНі {
      вказівка_двійкове_ні(М, код, асд.місцезнаходження);
    } інакше якщо дані.операція == СамоОпераціяЗаперечити {
      вказівка_заперечити(М, код, асд.місцезнаходження);
    } інакше {
      вернути помилка_компіляції(асд.місцезнаходження, ю8"Невідома унарна операція");
    }
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_створити_бога(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<СтворитиБогаАСДДані>;
    вернути помилка_компіляції(асд.місцезнаходження, ю8"Не втілено");
  }

  місцева дія скомпілювати_створити_шаблон_структури(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<СтворитиШаблонСтруктуриАСДДані>;
    вернути помилка_компіляції(асд.місцезнаходження, ю8"Не втілено");
  }

  місцева дія скомпілювати_створити_шаблон_дії(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<СтворитиШаблонДіїАСДДані>;
    вернути помилка_компіляції(асд.місцезнаходження, ю8"Не втілено");
  }

  місцева дія скомпілювати_виконати_шаблон(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<ВиконатиШаблонАСДДані>;
    вернути помилка_компіляції(асд.місцезнаходження, ю8"Не втілено");
  }

  місцева дія скомпілювати_значення_якщо(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<ЗначенняЯкщоАСДДані>;
    ціль результат_компіляції_умови = скомпілювати(М, контекст, код, дані.умова);
    якщо результат_компіляції_умови.успіх == 0 {
      вернути результат_компіляції_умови;
    }
    ціль позиція_вказівки_якщо_ні = код.довжина;
    вказівка_стрибнути_якщо_ні(М, код, асд.місцезнаходження, 0);
    ціль результат_компіляції_значення_якщо_так = скомпілювати(М, контекст, код, дані.якщо_так);
    якщо результат_компіляції_значення_якщо_так.успіх == 0 {
      вернути результат_компіляції_значення_якщо_так;
    }
    ціль позиція_вказівки_якщо_так = код.довжина;
    вказівка_стрибнути(М, код, асд.місцезнаходження, 0);
    код.дані[позиція_вказівки_якщо_ні].дані = код.довжина;
    ціль результат_компіляції_значення_якщо_ні = скомпілювати(М, контекст, код, дані.якщо_ні);
    якщо результат_компіляції_значення_якщо_ні.успіх == 0 {
      вернути результат_компіляції_значення_якщо_ні;
    }
    код.дані[позиція_вказівки_якщо_так].дані = код.довжина;
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_чекати(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<ЧекатиАСДДані>;
    вернути помилка_компіляції(асд.місцезнаходження, ю8"Не втілено");
  }

  місцева дія скомпілювати_як(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<ЯкАСДДані>;
    вернути помилка_компіляції(асд.місцезнаходження, ю8"Не втілено");
  }

  місцева дія скомпілювати_якщо(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<ЯкщоАСДДані>;
    ціль результат_компіляції_умови = скомпілювати(М, контекст, код, дані.умова);
    якщо результат_компіляції_умови.успіх == 0 {
      вернути результат_компіляції_умови;
    }
    ціль позиція_вказівки_якщо_ні = код.довжина;
    вказівка_стрибнути_якщо_ні(М, код, асд.місцезнаходження, 0);
    ціль результат_компіляції_тіла = скомпілювати_тіло(М, контекст, код, дані.тіло);
    якщо результат_компіляції_тіла.успіх == 0 {
      вернути результат_компіляції_тіла;
    }
    ціль позиція_вказівки_якщо_так = код.довжина;
    вказівка_стрибнути(М, код, асд.місцезнаходження, 0);
    код.дані[позиція_вказівки_якщо_ні].дані = код.довжина;
    ціль результат_компіляції_тіла_інакше = скомпілювати_тіло(М, контекст, код, дані.тіло_інакше);
    якщо результат_компіляції_тіла_інакше.успіх == 0 {
      вернути результат_компіляції_тіла;
    }
    код.дані[позиція_вказівки_якщо_так].дані = код.довжина;
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_поки(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<ПокиАСДДані>;
    ціль позиція_вказівки_початку_циклу = код.довжина;
    ціль позиція_вказівки_якщо_ні = 0;
    якщо дані.умова != пусто {
      ціль результат_компіляції_умови = скомпілювати(М, контекст, код, дані.умова);
      якщо результат_компіляції_умови.успіх == 0 {
        вернути результат_компіляції_умови;
      }
      позиція_вказівки_якщо_ні = код.довжина;
      вказівка_стрибнути_якщо_ні(М, код, асд.місцезнаходження, 0);
    }
    ціль контекст_циклу = створити_контекст_компіляції_циклу(контекст);
    ціль результат_компіляції_тіла = скомпілювати_тіло(М, контекст_циклу, код, дані.тіло);
    якщо результат_компіляції_тіла.успіх == 0 {
      звільнити_контекст_компіляції(контекст_циклу);
      вернути результат_компіляції_тіла;
    }
    вказівка_стрибнути(М, код, асд.місцезнаходження, позиція_вказівки_початку_циклу);
    якщо дані.умова != пусто {
      код.дані[позиція_вказівки_якщо_ні].дані = код.довжина;
    }
    заповнити_позиції_вказівок_контексту_циклу(контекст_циклу, код, позиція_вказівки_початку_циклу, код.довжина);
    звільнити_контекст_компіляції(контекст_циклу);
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_взяти(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<ВзятиАСДДані>;
    змінна слово_репозиторія: комірка<Слово> = пусто;
    якщо дані.ідентифікатор_репозиторія != пусто {
      ціль ідентифікатор_дані = дані.ідентифікатор_репозиторія.дані як комірка<ІдентифікаторАСДДані>;
      слово_репозиторія = отримати_або_створити_слово(М, ідентифікатор_дані.назва);
    }
    змінна слово_назви: комірка<Слово> = пусто;
    якщо дані.ідентифікатор_назви != пусто {
      ціль ідентифікатор_дані = дані.ідентифікатор_назви.дані як комірка<ІдентифікаторАСДДані>;
      слово_назви = отримати_або_створити_слово(М, ідентифікатор_дані.назва);
    }
    вказівка_створити_слово(М, код, асд.місцезнаходження, слово_репозиторія);
    змінна х = 0;
    поки х < дані.шлях.розмір {
      ціль частина_шляху = дані.шлях.елементи[х];
      ціль ідентифікатор_дані = частина_шляху.дані як комірка<ІдентифікаторАСДДані>;
      ціль слово_частини_шляху = отримати_або_створити_слово(М, ідентифікатор_дані.назва);
      вказівка_створити_слово(М, код, асд.місцезнаходження, слово_частини_шляху);
      х = х + 1;
    }
    вказівка_створити_число(М, код, асд.місцезнаходження, дані.шлях.розмір);
    вказівка_взяти(М, код, асд.місцезнаходження);
    якщо дані.елементи.розмір == 0 {
      вказівка_визначити_субʼєкт(М, код, асд.місцезнаходження, слово_назви);
    } інакше {
      змінна х = 0;
      поки х < дані.елементи.розмір {
        ціль елемент_взяти = дані.елементи.елементи[х];
        ціль дані_елемента_взяти = елемент_взяти.дані як комірка<ЕлементВзятиАСДДані>;
        ціль дані_ідентифікатора_властивості_елемента = дані_елемента_взяти.ідентифікатор_властивості.дані як комірка<ІдентифікаторАСДДані>;
        ціль дані_ідентифікатора_назви_елемента = дані_елемента_взяти.ідентифікатор_назви.дані як комірка<ІдентифікаторАСДДані>;
        вказівка_дублювати(М, код, асд.місцезнаходження);
        вказівка_отримати_властивість(М, код, елемент_взяти.місцезнаходження, отримати_або_створити_слово(М, дані_ідентифікатора_властивості_елемента.назва));
        вказівка_визначити_субʼєкт(М, код, елемент_взяти.місцезнаходження, отримати_або_створити_слово(М, дані_ідентифікатора_назви_елемента.назва));
        х = х + 1;
      }
      вказівка_забрати(М, код, асд.місцезнаходження);
    }
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_спробувати(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<СпробуватиАСДДані>;
    змінна слово: комірка<Слово> = пусто;
    якщо дані.ідентифікатор_зловити != пусто {
      ціль ідентифікатор = дані.ідентифікатор_зловити.дані як комірка<ІдентифікаторАСДДані>;
      слово = отримати_або_створити_слово(М, ідентифікатор.назва);
    }
    ціль позиція_вказівки_початку_спроби = код.довжина;
    вказівка_почати_спробу(М, код, асд.місцезнаходження, 0, слово);
    ціль результат_компіляції_тіла = скомпілювати_тіло(М, контекст, код, дані.тіло);
    якщо результат_компіляції_тіла.успіх == 0 {
      вернути результат_компіляції_тіла;
    }
    ціль позиція_вказівки_кінця_спроби = код.довжина;
    вказівка_закінчити_спробу(М, код, асд.місцезнаходження, 0);
    ціль дані_вказівки_почати_спробу = код.дані[позиція_вказівки_початку_спроби].дані як комірка<ДаніВказівкиПочатиСпробу>;
    дані_вказівки_почати_спробу.позиція = код.довжина;
    ціль результат_компіляції_тіла_зловити = скомпілювати_тіло(М, контекст, код, дані.тіло_зловити);
    якщо результат_компіляції_тіла_зловити.успіх == 0 {
      вернути результат_компіляції_тіла_зловити;
    }
    код.дані[позиція_вказівки_кінця_спроби].дані = код.довжина;
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_впасти(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<ВпастиАСДДані>;
    ціль результат_компіляції_значення = скомпілювати(М, контекст, код, дані.значення);
    якщо результат_компіляції_значення.успіх == 0 {
      вернути результат_компіляції_значення;
    }
    вказівка_впасти(М, код, асд.місцезнаходження);
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_перебрати(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<ПеребратиАСДДані>;
    ціль слово_значення = отримати_або_створити_слово(М, ю8"значення");
    ціль слово_далі = отримати_або_створити_слово(М, ю8"далі");
    ціль ідентифікатор = дані.ідентифікатор.дані як комірка<ІдентифікаторАСДДані>;
    ціль слово = отримати_або_створити_слово(М, ідентифікатор.назва);
    ціль результат_компіляції_значення = скомпілювати(М, контекст, код, дані.значення);
    якщо результат_компіляції_значення.успіх == 0 {
      вернути результат_компіляції_значення;
    }
    вказівка_отримати_перебір(М, код, асд.місцезнаходження);
    вказівка_дублювати(М, код, асд.місцезнаходження);
    вказівка_отримати_властивість(М, код, асд.місцезнаходження, слово_далі);
    ціль позиція_вказівки_початку_циклу = код.довжина;
    вказівка_дублювати(М, код, асд.місцезнаходження);
    вказівка_виконати_дію(М, код, асд.місцезнаходження, 0);
    ціль позиція_вказівки_якщо_ні = код.довжина;
    вказівка_стрибнути_якщо_ні(М, код, асд.місцезнаходження, 0);
    вказівка_дублювати__1(М, код, асд.місцезнаходження);
    вказівка_отримати_властивість(М, код, асд.місцезнаходження, слово_значення);
    вказівка_визначити_субʼєкт(М, код, асд.місцезнаходження, слово);
    ціль контекст_циклу = створити_контекст_компіляції_циклу(контекст);
    ціль результат_компіляції_тіла = скомпілювати_тіло(М, контекст_циклу, код, дані.тіло);
    якщо результат_компіляції_тіла.успіх == 0 {
      звільнити_контекст_компіляції(контекст_циклу);
      вернути результат_компіляції_тіла;
    }
    вказівка_стрибнути(М, код, асд.місцезнаходження, позиція_вказівки_початку_циклу);
    код.дані[позиція_вказівки_якщо_ні].дані = код.довжина;
    заповнити_позиції_вказівок_контексту_циклу(контекст_циклу, код, позиція_вказівки_початку_циклу, код.довжина);
    звільнити_контекст_компіляції(контекст_циклу);
    вказівка_забрати(М, код, асд.місцезнаходження);
    вказівка_забрати(М, код, асд.місцезнаходження);
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_перебрати_діапазон(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<ПеребратиДіапазонАСДДані>;
    ціль ідентифікатор = дані.ідентифікатор.дані як комірка<ІдентифікаторАСДДані>;
    ціль слово = отримати_або_створити_слово(М, ідентифікатор.назва);
    ціль результат_компіляції_від = скомпілювати(М, контекст, код, дані.від);
    якщо результат_компіляції_від.успіх == 0 {
      вернути результат_компіляції_від;
    }
    ціль результат_компіляції_до = скомпілювати(М, контекст, код, дані.до);
    якщо результат_компіляції_до.успіх == 0 {
      вернути результат_компіляції_до;
    }
    вказівка_створити_число(М, код, асд.місцезнаходження, 1.0);
    вказівка_додати(М, код, асд.місцезнаходження);
    ціль позиція_вказівки_початку_циклу = код.довжина;
    вказівка_дублювати__1(М, код, асд.місцезнаходження);
    вказівка_визначити_субʼєкт(М, код, асд.місцезнаходження, слово);
    вказівка_дублювати__1(М, код, асд.місцезнаходження); // від
    вказівка_створити_число(М, код, асд.місцезнаходження, 1.0);
    вказівка_додати(М, код, асд.місцезнаходження); // від + 1
    вказівка_скопіювати__2(М, код, асд.місцезнаходження); // заміна від
    вказівка_дублювати__1(М, код, асд.місцезнаходження); // до
    вказівка_порівняти_чи_більше(М, код, асд.місцезнаходження);
    ціль позиція_вказівки_якщо_так = код.довжина;
    вказівка_стрибнути_якщо_так(М, код, асд.місцезнаходження, 0);
    ціль контекст_циклу = створити_контекст_компіляції_циклу(контекст);
    ціль результат_компіляції_тіла = скомпілювати_тіло(М, контекст_циклу, код, дані.тіло);
    якщо результат_компіляції_тіла.успіх == 0 {
      звільнити_контекст_компіляції(контекст_циклу);
      вернути результат_компіляції_тіла;
    }
    вказівка_стрибнути(М, код, асд.місцезнаходження, позиція_вказівки_початку_циклу);
    код.дані[позиція_вказівки_якщо_так].дані = код.довжина;
    заповнити_позиції_вказівок_контексту_циклу(контекст_циклу, код, позиція_вказівки_початку_циклу, код.довжина);
    звільнити_контекст_компіляції(контекст_циклу);
    вказівка_забрати(М, код, асд.місцезнаходження);
    вказівка_забрати(М, код, асд.місцезнаходження);
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_пропустити(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<ПропуститиАСДДані>;
    ціль контекст_циклу = отримати_контекст_компіляції_циклу(контекст);
    якщо контекст_циклу == пусто {
      вернути помилка_компіляції(асд.місцезнаходження, ю8"Пропустити можна використовувати тільки всередині циклу");
    }
    додати_до_вектору<позитивне>(контекст_циклу.цикл_позиції_вказівок_пропустити, код.довжина);
    вказівка_стрибнути(М, код, асд.місцезнаходження, 0);
    вернути успіх_компіляції();
  }

  місцева дія скомпілювати_перервати(М: комірка<Машина>, контекст: комірка<КонтекстКомпіляції>, код: комірка<вектор<Вказівка>>, асд: комірка<АСДЗначення>): РезультатКомпіляції {
    ціль дані = асд.дані як комірка<ПерерватиАСДДані>;
    ціль контекст_циклу = отримати_контекст_компіляції_циклу(контекст);
    якщо контекст_циклу == пусто {
      вернути помилка_компіляції(асд.місцезнаходження, ю8"Перервати можна використовувати тільки всередині циклу");
    }
    додати_до_вектору<позитивне>(контекст_циклу.цикл_позиції_вказівок_перервати, код.довжина);
    вказівка_стрибнути(М, код, асд.місцезнаходження, 0);
    вернути успіх_компіляції();
  }
}