взяти визначення біб;

структура вектор<Т> {
  дані: памʼять<Т>;
  довжина: позитивне;
  вмісткість: позитивне;
}

дія створити_вектор<Т>(): комірка<вектор<Т>> {
  ціль в = виділити<вектор<Т>>();
  в.дані = пусто;
  в.довжина = 0;
  в.вмісткість = 0;
  вернути в;
}

дія зробити_вектор<Т>(): вектор<Т> {
  ціль в = вектор<Т> {};
  в.дані = пусто;
  в.довжина = 0;
  в.вмісткість = 0;
  вернути в;
}

дія додати_до_вектору<Т>(с: комірка<вектор<Т>>, значення: Т) {
  якщо с.довжина == с.вмісткість {
    якщо с.вмісткість == 0 {
      с.дані = виділити<Т>(1);
    } інакше {
      с.дані = перевиділити<Т>(с.дані, с.вмісткість як ц32 + 1);
    }
    с.вмісткість = с.вмісткість + 1;
  }
  с.дані[с.довжина] = значення;
  с.довжина = с.довжина + 1;
}

дія обернути_вектор<Т>(с: комірка<вектор<Т>>) {
  змінна х: ціле = 0;
  змінна у = с.довжина як ціле - 1;
  поки х < у {
    змінна тимчасова = с.дані[х];
    с.дані[х] = с.дані[у];
    с.дані[у] = тимчасова;
    х = х + 1;
    у = у - 1;
  }
}

дія звільнити_вектор<Т>(с: комірка<вектор<Т>>) {
  звільнити(с.дані);
  звільнити(с);
}

дія клонувати_вектор<Т>(с: комірка<вектор<Т>>): комірка<вектор<Т>> {
  ціль клон = створити_вектор<Т>();
  клон.довжина = с.довжина;
  клон.вмісткість = с.вмісткість;
  якщо с.вмісткість > 0 {
    клон.дані = виділити<Т>(с.вмісткість як ц32);
    змінна х: ціле = 0;
    поки х < с.довжина як ціле {
      клон.дані[х] = с.дані[х];
      х = х + 1;
    }
  }
  вернути клон;
}

структура ЕлементКарти<К, З> {
  ключ: К;
  значення: З;
}

структура карта<К, З> {
  елементи: комірка<вектор<ЕлементКарти<К, З>>>;
  перевірити_ключ: (К, К) -> ціле;
}

дія створити_карту<К, З>(перевірити_ключ: (К, К) -> ціле): комірка<карта<К, З>> {
  ціль с = виділити<карта<К, З>>();
  с.елементи = створити_вектор<ЕлементКарти<К, З>>();
  с.перевірити_ключ = перевірити_ключ;
  вернути с;
}

дія отримати_значення_з_карти<К, З>(с: комірка<карта<К, З>>, ключ: К, пусте_значення: З): З {
  змінна х: ціле = 0;
  поки х < с.елементи.довжина як ціле {
    якщо с.перевірити_ключ(с.елементи.дані[х].ключ, ключ) == 1 {
      вернути с.елементи.дані[х].значення;
    }
    х = х + 1;
  }
  вернути пусте_значення;
}

дія перевірити_чи_карта_містить_значення<К, З>(с: комірка<карта<К, З>>, ключ: К): ціле {
  змінна х: ціле = 0;
  поки х < с.елементи.довжина як ціле {
    якщо с.перевірити_ключ(с.елементи.дані[х].ключ, ключ) == 1 {
      вернути 1;
    }
    х = х + 1;
  }
  вернути 0;
}

дія змінити_значення_карти<К, З>(с: комірка<карта<К, З>>, ключ: К, значення: З): ціле {
  змінна х: ціле = 0;
  поки х < с.елементи.довжина як ціле {
    якщо с.перевірити_ключ(с.елементи.дані[х].ключ, ключ) == 1 {
      с.елементи.дані[х].значення = значення;
      вернути с.елементи.довжина;
    }
    х = х + 1;
  }
  додати_до_вектору<ЕлементКарти<К, З>>(с.елементи, ЕлементКарти<К, З> { ключ, значення });
  вернути с.елементи.довжина;
}

дія видалити_з_карти<К, З>(с: комірка<карта<К, З>>, ключ: К): позитивне {
  змінна х: ціле = 0;
  поки х < с.елементи.довжина як ціле {
    якщо с.перевірити_ключ(с.елементи.дані[х].ключ, ключ) == 1 {
      змінна у = х;
      поки у < с.елементи.довжина як ціле - 1 {
        с.елементи.дані[у] = с.елементи.дані[у + 1];
        у = у + 1;
      }
      с.елементи.довжина = с.елементи.довжина - 1;
      вернути 1;
    }
    х = х + 1;
  }
  вернути 0;
}

дія звільнити_карту<К, З>(с: комірка<карта<К, З>>) {
  звільнити_вектор<ЕлементКарти<К, З>>(с.елементи);
  звільнити(с);
}

синонім буфер_ю8 = вектор<п8>;

дія створити_буфер_ю8(): комірка<вектор<п8>> {
  вернути створити_вектор<п8>();
}

дія додати_до_буфера_ю8(буфер: комірка<вектор<п8>>, значення: памʼять<п8>) {
  змінна х: ціле = 0;
  поки значення[х] != 0 {
    додати_до_вектору<п8>(буфер, значення[х]);
    х = х + 1;
  }
}

дія додати_символ_до_буфера_ю8(буфер: комірка<вектор<п8>>, значення: п8) {
  додати_до_вектору<п8>(буфер, значення);
}

дія звільнити_буфер_ю8(буфер: комірка<вектор<п8>>) {
  звільнити_вектор<п8>(буфер);
}

дія створити_ю8_сі_з_буфера(буфер: комірка<вектор<п8>>): памʼять<п8> {
  ціль значення = виділити<п8>(буфер.довжина як ц32 + 1);
  змінна х: ціле = 0;
  поки х < буфер.довжина як ціле {
    значення[х] = буфер.дані[х];
    х = х + 1;
  }
  значення[буфер.довжина] = 0;
  вернути значення;
}

зовнішня дія strcmp(ю81: памʼять<п8>, ю82: памʼять<п8>): ціле;

зовнішня дія перетворити_ю8_в_дійсне(ю8: памʼять<п8>): дійсне;
зовнішня дія прочитати_файл(шлях: памʼять<п8>): памʼять<п8>;
зовнішня дія перетворити_позитивне_в_ю8(значення: позитивне): памʼять<п8>;
зовнішня дія перетворити_дійсне_в_ю8(значення: дійсне): памʼять<п8>;
зовнішня дія довжина_ю8(ю8: памʼять<п8>): позитивне;

структура ВитнутийРядокДляПомилки {
  новий_стовпець: позитивне;
  значення: памʼять<п8>;
}
місцева дія витнути_рядок_для_помилки(значення: памʼять<п8>, рядок: позитивне, стовпець: позитивне): ВитнутийРядокДляПомилки;

зовнішня дія повторити_ю8(значення: памʼять<п8>, разів: позитивне, після: памʼять<п8>): памʼять<п8>;
зовнішня дія зʼєднати_ю8(значення: памʼять<п8>, значення2: памʼять<п8>): памʼять<п8>;

зовнішня дія нормалізувати_шлях(шлях: памʼять<п8>): памʼять<п8>;
зовнішня дія отримати_папку_шляху(шлях: памʼять<п8>): памʼять<п8>;
зовнішня дія зʼєднати_шлях(шлях: памʼять<п8>, шлях2: памʼять<п8>): памʼять<п8>;
зовнішня дія отримати_назву_файлу(шлях: памʼять<п8>): памʼять<п8>;
зовнішня дія отримати_назву_файлу_без_розширення(шлях: памʼять<п8>): памʼять<п8>;
зовнішня дія отримати_відносний_шлях(шлях: памʼять<п8>): памʼять<п8>;
зовнішня дія отримати_шлях_до_папки_запуску(): памʼять<п8>;
зовнішня дія перевірити_чи_файл_існує(шлях: памʼять<п8>): логічне;

зовнішня дія читати_з_входу(префікс: памʼять<п8>): памʼять<п8>;

зовнішня дія завантажити_динамічну_бібліотеку(шлях: памʼять<п8>): невідома_комірка;
зовнішня дія отримати_символ_з_динамічної_бібліотеки(дб: невідома_комірка, назва: памʼять<п8>): невідома_комірка;
зовнішня дія завантажити_динамічну_бібліотеку_як_розширення_мавки(шлях: памʼять<п8>): невідома_комірка;

зовнішня дія двійкове_ні(значення: ціле): ціле;
