////
// Автор це Богданович Давид Когут Прихожденко та Організація Мавки та Організація Організацій
////

взяти визначення МаМа;

секція МаМа {
  місцева дія виділити_машину(): адреса<Машина> {
    ціль М = виділити<Машина>();
    М.утилізатор = зробити_утилізатор();
    М.БН = зробити_базу_назв();
    М.НаО = зробити_накопичувач<адреса<Обʼєкт>>();
    М.НаРАрг = зробити_накопичувач<адреса<Реєстр<адреса<Назва>, адреса<Обʼєкт>>>>();
    М.НаРПар = зробити_накопичувач<адреса<Реєстр<адреса<Назва>, Параметр>>>();
    М.ТрК = пусто;
    М.історія = зробити_накопичувач<ЕлементІсторіїВиконання>();
    М.НаН = зробити_накопичувач<адреса<Назва>>();
    М.НаОТ = зробити_накопичувач<адреса<Обʼєкт>>();
    М.глобальне_середовище = виділити_середовище(М, пусто);
    М.стан_падіння = ні;
    М.місцезнаходження_падіння = пусто;
    М.сховище_констант = зробити_накопичувач<адреса<Обʼєкт>>();
    М.сховище_кодів = зробити_накопичувач<адреса<Код>>();
    М.обробник_отримання_шляху_до_модуля = пусто;
    М.обробник_взяття_модуля = пусто;
    М.обробник_взяття_біб = пусто;
    М.взяті_модулі = зробити_реєстр<Ю8, адреса<ОбʼєктМодуля>>(перевірити_чи_ю8_рівні);
    М.дані_виконувача = пусто;

    // § Створення обʼєктів "обʼєкт" та "Структура":
    //   "обʼєкт" це Структура що не має предка.
    //   "Структура" це Структура що має предок "обʼєкт".
    //   Мають виконуватись наступні умови:
    //     1. обʼєкт є обʼєкт
    //     2. обʼєкт є Структура
    //     3. Структура є обʼєкт
    //     4. Структура є Структура
    М.обʼєкт_структури_обʼєкт = виділити_обʼєкт_структури(М, М.БН.С.обʼєкт, пусто);
    М.обʼєкт_структури_Структура = виділити_обʼєкт_структури(М, М.БН.С.Структура, пусто);
    М.обʼєкт_структури_обʼєкт.тип = М.обʼєкт_структури_Структура;
    М.обʼєкт_структури_обʼєкт.предок = пусто;
    М.обʼєкт_структури_Структура.тип = М.обʼєкт_структури_Структура;
    М.обʼєкт_структури_Структура.предок = М.обʼєкт_структури_обʼєкт;

    М.обʼєкт_структури_Дія = виділити_обʼєкт_структури(М, М.БН.С.Дія, М.обʼєкт_структури_обʼєкт);
    М.обʼєкт_структури_НативнаДія = виділити_обʼєкт_структури(М, М.БН.С.НативнаДія, М.обʼєкт_структури_обʼєкт);
    М.обʼєкт_структури_число = створити_структуру_числа(М);
    М.обʼєкт_структури_текст = виділити_обʼєкт_структури(М, М.БН.С.текст, М.обʼєкт_структури_обʼєкт);
    М.обʼєкт_структури_юнікод = виділити_обʼєкт_структури(М, М.БН.С.юнікод, М.обʼєкт_структури_обʼєкт);
    М.обʼєкт_структури_Модуль = виділити_обʼєкт_структури(М, М.БН.С.Модуль, М.обʼєкт_структури_обʼєкт);
    М.обʼєкт_структури_список = виділити_обʼєкт_структури(М, М.БН.С.список, М.обʼєкт_структури_обʼєкт);
    М.обʼєкт_структури_словник = виділити_обʼєкт_структури(М, М.БН.С.словник, М.обʼєкт_структури_обʼєкт);
    М.обʼєкт_структури_логічне = виділити_обʼєкт_структури(М, М.БН.С.логічне, М.обʼєкт_структури_обʼєкт);

    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.обʼєкт, М.обʼєкт_структури_обʼєкт як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.Структура, М.обʼєкт_структури_Структура як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.НативнаДія, М.обʼєкт_структури_НативнаДія як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.Дія, М.обʼєкт_структури_Дія як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.число, М.обʼєкт_структури_число як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.текст, М.обʼєкт_структури_текст як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.юнікод, М.обʼєкт_структури_юнікод як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.Модуль, М.обʼєкт_структури_Модуль як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.список, М.обʼєкт_структури_список як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.словник, М.обʼєкт_структури_словник як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.логічне, М.обʼєкт_структури_логічне як адреса<Обʼєкт>);

    М.обʼєкт_логічного_так = виділити_обʼєкт_логічного(М, так);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.так, М.обʼєкт_логічного_так як адреса<Обʼєкт>);
    М.обʼєкт_логічного_ні = виділити_обʼєкт_логічного(М, ні);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.ні, М.обʼєкт_логічного_ні як адреса<Обʼєкт>);
    вернути М;
  }

  місцева дія звільнити_машину(М: адреса<Машина>) {
    // ...
  }

  місцева дія увімкнути_стан_падіння(М: адреса<Машина>, місцезнаходження_падіння: адреса<МісцезнаходженняПадіння>) {
    М.стан_падіння = так;
    М.місцезнаходження_падіння = пусто;
  }

  місцева дія покласти_константу(М: адреса<Машина>, обʼєкт: адреса<Обʼєкт>): п32 {
    покласти_в_накопичувач<адреса<Обʼєкт>>(М.сховище_констант::адреса, обʼєкт);
    вернути М.сховище_констант.розмір як п32 - 1;
  }

  структура Спроба {
    позиція_вказівки_зловити: п32;
    розмір_накопичувача_виконання: п32;
  }

  місцева дія виконати_код(М: адреса<Машина>, середовище: адреса<Середовище>, код: адреса<Код>, обʼєкт_дії: адреса<ОбʼєктДії>, обʼєкт_модуля: адреса<ОбʼєктМодуля>, обʼєкт_я: адреса<Обʼєкт>): обʼєкт_або_стан_падіння {
    ціль нове_середовище = виділити_середовище(М, середовище);
    нове_середовище.обʼєкт_модуля = обʼєкт_модуля;
    нове_середовище.обʼєкт_я = обʼєкт_я;
    покласти_в_накопичувач<МаМа::ЕлементІсторіїВиконання>(М.історія::адреса, МаМа::ЕлементІсторіїВиконання {
      обʼєкт_дії = обʼєкт_дії,
      середовище = нове_середовище
    });
    ціль результат = виконати_код_в_середовищі(М, нове_середовище, код);
    забрати_з_накопичувача<МаМа::ЕлементІсторіїВиконання>(М.історія::адреса);
    вернути результат;
  }

  місцева дія виконати_код_в_середовищі(М: адреса<Машина>, середовище: адреса<Середовище>, код: адреса<Код>): обʼєкт_або_стан_падіння {
    ціль спроби = зробити_накопичувач<Спроба>();
    ціль позиція_вказівки: п32 = 0;
    поки позиція_вказівки < код.накопичувач_вказівок.розмір {
      якщо М.утилізатор.кількість_обʼєктів >= М.утилізатор.кількість_обʼєктів_щоб_запустити_утилізацію {
        утилізувати(М);
      }
      якщо М.утилізатор.кількість_середовищ >= М.утилізатор.кількість_середовищ_щоб_запустити_утилізацію {
        утилізувати(М);
      }
      ціль вказівка = код.накопичувач_вказівок.дані[позиція_вказівки];
      якщо вказівка == ВПокластиПусто {
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, пусто);
      } інакше якщо вказівка == ВПокластиТак {
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_логічного_так як адреса<Обʼєкт>);
      } інакше якщо вказівка == ВПокластиНі {
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_логічного_ні як адреса<Обʼєкт>);
      } інакше якщо вказівка == ВПокластиКонстанту {
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_константи = код.накопичувач_вказівок.дані[позиція_вказівки];
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.сховище_констант.дані[позиція_константи]);
      } інакше якщо вказівка == ВСтворитиДію {
        ціль реєстр_параметрів = забрати_з_накопичувача<адреса<Реєстр<адреса<Назва>, Параметр>>>(М.НаРПар::адреса);
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_коду = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль код = М.сховище_кодів.дані[позиція_коду];
        ціль типи_результату = зробити_накопичувач<адреса<ОбʼєктСтруктури>>();
        змінна ціль пт: позитивне = 0;
        поки пт < М.НаОТ.розмір {
          ціль обʼєкт = М.НаОТ.дані[пт];
          якщо обʼєкт.тип != М.обʼєкт_структури_Структура {
            увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки));
            вернути виділити_обʼєкт_юнікоду_з_ю8(М, ю8"Тип результату має бути структурою") як адреса<Обʼєкт>;
          }
          покласти_в_накопичувач<адреса<ОбʼєктСтруктури>>(типи_результату::адреса, обʼєкт як адреса<ОбʼєктСтруктури>);
          пт += 1;
        }
        М.НаОТ.розмір = 0;
        ціль обʼєкт_дії = виділити_обʼєкт_дії(М, назва, реєстр_параметрів, середовище, код, типи_результату);
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, обʼєкт_дії як адреса<Обʼєкт>);
      } інакше якщо вказівка == ВСтворитиСтруктуру {
        ціль реєстр_параметрів = забрати_з_накопичувача<адреса<Реєстр<адреса<Назва>, Параметр>>>(М.НаРПар::адреса);
        ціль обʼєкт_предка = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        якщо обʼєкт_предка.тип != М.обʼєкт_структури_Структура {
          увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки));
          вернути виділити_обʼєкт_юнікоду_з_ю8(М, ю8"Предок має бути структурою") як адреса<Обʼєкт>;
        }
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        ціль обʼєкт_структури = виділити_обʼєкт_структури(М, назва, обʼєкт_предка як адреса<ОбʼєктСтруктури>);
        змінна ціль пп: позитивне = 0;
        поки пп < реєстр_параметрів.розмір {
          ціль елемент_реєстру = отримати_з_реєстру<адреса<Назва>, Параметр>(обʼєкт_структури.параметри, реєстр_параметрів.елементи[пп].ключ);
          якщо елемент_реєстру == пусто {
            змінити_в_реєстрі<адреса<Назва>, Параметр>(обʼєкт_структури.параметри, реєстр_параметрів.елементи[пп].ключ, реєстр_параметрів.елементи[пп].значення);
          } інакше {
            увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки));
            вернути виділити_обʼєкт_юнікоду_з_ю8(М, ю8"Параметр вже визначено") як адреса<Обʼєкт>;
          }
          пп += 1;
        }
        звільнити_реєстр<адреса<Назва>, Параметр>(реєстр_параметрів);
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, обʼєкт_структури як адреса<Обʼєкт>);
      } інакше якщо вказівка == ВСтворитиМодуль {
        ціль позиція_цієї_вказівки = позиція_вказівки;
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_коду = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль код_модуля = М.сховище_кодів.дані[позиція_коду];
        ціль обʼєкт_модуля = виділити_обʼєкт_модуля(М, назва);
        ціль результат_виконання = виконати_код(М, середовище, код_модуля, пусто, обʼєкт_модуля, пусто);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_цієї_вказівки);
          }
          вернути результат_виконання;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, обʼєкт_модуля як адреса<Обʼєкт>);
      } інакше якщо вказівка == ВСтворитиСписок {
        позиція_вказівки = позиція_вказівки + 1;
        ціль розмір_списку = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль обʼєкт_списку = виділити_обʼєкт_списку(М, розмір_списку);
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, обʼєкт_списку як адреса<Обʼєкт>);
      } інакше якщо вказівка == ВПокластиВСписок {
        ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт_списку = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса) як адреса<ОбʼєктСписку>;
        покласти_в_накопичувач<адреса<Обʼєкт>>(обʼєкт_списку.елементи::адреса, значення);
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, обʼєкт_списку як адреса<Обʼєкт>);
      } інакше якщо вказівка == ВСтворитиСловник {
        позиція_вказівки = позиція_вказівки + 1;
        ціль розмір_словника = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль обʼєкт_словника = виділити_обʼєкт_словника(М, розмір_словника);
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, обʼєкт_словника як адреса<Обʼєкт>);
      } інакше якщо вказівка == ВПокластиВСловник {
        ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль ключ = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт_словника = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса) як адреса<ОбʼєктСловника>;
        змінити_в_реєстрі2<адреса<Обʼєкт>, адреса<Обʼєкт>>(обʼєкт_словника.елементи::адреса, ключ, значення);
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, обʼєкт_словника як адреса<Обʼєкт>);
      } інакше якщо вказівка == ВПокластиСтруктуруОбʼєкт {
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_структури_обʼєкт як адреса<Обʼєкт>);
      } інакше якщо вказівка == ВПокластиЯ {
        змінна ціль поточне_середовище = середовище;
        змінна ціль обʼєкт_я: адреса<Обʼєкт> = пусто;
        поки поточне_середовище != пусто {
          якщо поточне_середовище.обʼєкт_я != пусто {
            обʼєкт_я = поточне_середовище.обʼєкт_я;
            поточне_середовище = пусто;
          } інакше {
            поточне_середовище = поточне_середовище.батьківське;
          }
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, обʼєкт_я);
      } інакше якщо вказівка == ВВизначити {
        ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        змінити_в_середовищі(М, середовище, назва, значення);
      } інакше якщо вказівка == ВЗвернутись {
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, знайти_в_середовищі(середовище, назва));
      } інакше якщо вказівка == ВВиконати {
        ціль позиція_цієї_вказівки = позиція_вказівки;
        позиція_вказівки = позиція_вказівки + 1;
        ціль кількість_аргументів = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль аргументи = зробити_накопичувач<адреса<Обʼєкт>>();
        змінна ціль па: п32 = 0;
        поки па < кількість_аргументів {
          ціль аргумент = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
          покласти_в_накопичувач<адреса<Обʼєкт>>(аргументи::адреса, аргумент);
          па += 1;
        }
        обернути_накопичувач<адреса<Обʼєкт>>(аргументи::адреса);
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат_виконання = обʼєкт_виконати(обʼєкт, М, пусто, аргументи::адреса, пусто);
        звільнити_значення_накопичувача<адреса<Обʼєкт>>(аргументи);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_цієї_вказівки);
          }
          вернути результат_виконання;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат_виконання);
      } інакше якщо вказівка == ВВиконатиЗНазвами {
        ціль позиція_цієї_вказівки = позиція_вказівки;
        ціль іменовані_аргументи = забрати_з_накопичувача<адреса<Реєстр<адреса<Назва>, адреса<Обʼєкт>>>>(М.НаРАрг::адреса);
        позиція_вказівки = позиція_вказівки + 1;
        ціль кількість_аргументів = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль аргументи = зробити_накопичувач<адреса<Обʼєкт>>();
        змінна ціль па: п32 = 0;
        поки па < кількість_аргументів {
          ціль аргумент = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
          покласти_в_накопичувач<адреса<Обʼєкт>>(аргументи::адреса, аргумент);
          па += 1;
        }
        обернути_накопичувач<адреса<Обʼєкт>>(аргументи::адреса);
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат_виконання = обʼєкт_виконати(обʼєкт, М, пусто, аргументи::адреса, іменовані_аргументи);
        звільнити_значення_накопичувача<адреса<Обʼєкт>>(аргументи);
        звільнити_реєстр<адреса<Назва>, адреса<Обʼєкт>>(іменовані_аргументи);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_цієї_вказівки);
          }
          вернути результат_виконання;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат_виконання);
      } інакше якщо вказівка == ВОтриматиВластивість {
        ціль позиція_цієї_вказівки = позиція_вказівки;
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        ціль результат_отримання_властивості = обʼєкт_отримати_властивість(обʼєкт, М, назва);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_цієї_вказівки);
          }
          вернути результат_отримання_властивості;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат_отримання_властивості);
      } інакше якщо вказівка == ВЗмінитиВластивість {
        ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        ціль результат_зміни_властивості = обʼєкт_змінити_властивість(обʼєкт, М, назва, значення);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат_зміни_властивості;
        }
      } інакше якщо вказівка == ВВиконатиВластивість {
        ціль позиція_цієї_вказівки = позиція_вказівки;
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        позиція_вказівки = позиція_вказівки + 1;
        ціль кількість_аргументів = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль аргументи = зробити_накопичувач<адреса<Обʼєкт>>();
        змінна ціль па: п32 = 0;
        поки па < кількість_аргументів {
          ціль аргумент = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
          покласти_в_накопичувач<адреса<Обʼєкт>>(аргументи::адреса, аргумент);
          па += 1;
        }
        обернути_накопичувач<адреса<Обʼєкт>>(аргументи::адреса);
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат_виконання = обʼєкт_виконати_властивість(обʼєкт, М, назва, аргументи::адреса, пусто);
        звільнити_значення_накопичувача<адреса<Обʼєкт>>(аргументи);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_цієї_вказівки);
          }
          вернути результат_виконання;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат_виконання);
      } інакше якщо вказівка == ВВиконатиВластивістьЗНазвами {
        ціль позиція_цієї_вказівки = позиція_вказівки;
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        ціль іменовані_аргументи = забрати_з_накопичувача<адреса<Реєстр<адреса<Назва>, адреса<Обʼєкт>>>>(М.НаРАрг::адреса);
        позиція_вказівки = позиція_вказівки + 1;
        ціль кількість_аргументів = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль аргументи = зробити_накопичувач<адреса<Обʼєкт>>();
        змінна ціль па: п32 = 0;
        поки па < кількість_аргументів {
          ціль аргумент = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
          покласти_в_накопичувач<адреса<Обʼєкт>>(аргументи::адреса, аргумент);
          па += 1;
        }
        обернути_накопичувач<адреса<Обʼєкт>>(аргументи::адреса);
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат_виконання = обʼєкт_виконати_властивість(обʼєкт, М, назва, аргументи::адреса, іменовані_аргументи);
        звільнити_значення_накопичувача<адреса<Обʼєкт>>(аргументи);
        звільнити_реєстр<адреса<Назва>, адреса<Обʼєкт>>(іменовані_аргументи);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_цієї_вказівки);
          }
          вернути результат_виконання;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат_виконання);
      } інакше якщо вказівка == ВОтриматиЕлемент {
        ціль ключ = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат_отримання_елемента = обʼєкт_отримати_елемент(обʼєкт, М, ключ);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат_отримання_елемента;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат_отримання_елемента);
      } інакше якщо вказівка == ВЗмінитиЕлемент {
        ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль ключ = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат_зміни_елемента = обʼєкт_змінити_елемент(обʼєкт, М, ключ, значення);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат_зміни_елемента;
        }
      } інакше якщо вказівка == ВОтриматиПеребір {
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат_отримання_перебору = обʼєкт_отримати_перебір(обʼєкт, М);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат_отримання_перебору;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат_отримання_перебору);
      } інакше якщо вказівка == ВДодати {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_додати(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
      } інакше якщо вказівка == ВВідняти {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_відняти(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
      } інакше якщо вказівка == ВПомножити {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_помножити(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
      } інакше якщо вказівка == ВПоділити {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_поділити(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
      } інакше якщо вказівка == ВОтриматиОстачуДілення {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_отримати_остачу_ділення(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
      } інакше якщо вказівка == ВОтриматиЧасткуДілення {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_отримати_частку_ділення(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
      } інакше якщо вказівка == ВПіднестиДоСтепеня {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_піднести_до_степеня(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
      } інакше якщо вказівка == ВЗсунутиВліво {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_зсунути_вліво(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
      } інакше якщо вказівка == ВЗсунутиВправо {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_зсунути_вправо(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
      } інакше якщо вказівка == ВЗсунутиВправоЗіЗаповненням {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_зсунути_вправо_зі_заповненням(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
      } інакше якщо вказівка == ВДвійковеІ {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_двійкове_і(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
      } інакше якщо вказівка == ВДвійковеАБО {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_двійкове_або(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
      } інакше якщо вказівка == ВДвійковеВиключнеАБО {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_двійкове_виключне_або(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
      } інакше якщо вказівка == ВДвійковеНЕ {
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_двійкове_не(обʼєкт, М);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
      } інакше якщо вказівка == ВМенше {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_менше(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
      } інакше якщо вказівка == ВБільше {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_більше(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
      } інакше якщо вказівка == ВНеБільше {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_більше(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        якщо перевірити_чи_обʼєкт_виражається_логічним_так(результат, М) {
          покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_логічного_ні як адреса<Обʼєкт>);
        } інакше {
          покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_логічного_так як адреса<Обʼєкт>);
        }
      } інакше якщо вказівка == ВНеМенше {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_менше(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        якщо перевірити_чи_обʼєкт_виражається_логічним_так(результат, М) {
          покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_логічного_ні як адреса<Обʼєкт>);
        } інакше {
          покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_логічного_так як адреса<Обʼєкт>);
        }
      } інакше якщо вказівка == ВРівно {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_рівно(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
      } інакше якщо вказівка == ВНеРівно {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_рівно(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        якщо перевірити_чи_обʼєкт_виражається_логічним_так(результат, М) {
          покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_логічного_ні як адреса<Обʼєкт>);
        } інакше {
          покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_логічного_так як адреса<Обʼєкт>);
        }
      } інакше якщо вказівка == ВМістить {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_містить(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
      } інакше якщо вказівка == ВНеМістить {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_містить(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        якщо перевірити_чи_обʼєкт_виражається_логічним_так(результат, М) {
          покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_логічного_ні як адреса<Обʼєкт>);
        } інакше {
          покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_логічного_так як адреса<Обʼєкт>);
        }
      } інакше якщо вказівка == ВЄ {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_є(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
      } інакше якщо вказівка == ВНеЄ {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_є(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        якщо перевірити_чи_обʼєкт_виражається_логічним_так(результат, М) {
          покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_логічного_ні як адреса<Обʼєкт>);
        } інакше {
          покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_логічного_так як адреса<Обʼєкт>);
        }
      } інакше якщо вказівка == ВВідʼємне {
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_відʼємне(обʼєкт, М);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
      } інакше якщо вказівка == ВДодатнє {
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_додатнє(обʼєкт, М);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
      } інакше якщо вказівка == ВЗаперечити {
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = обʼєкт_заперечити(обʼєкт, М);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
      } інакше якщо вказівка == ВПочатиСпробу {
        ціль позиція_вказівки_зловити = код.накопичувач_вказівок.дані[позиція_вказівки + 1];
        позиція_вказівки = позиція_вказівки + 1;
        покласти_в_накопичувач<Спроба>(спроби::адреса, Спроба {
          позиція_вказівки_зловити = позиція_вказівки_зловити,
          розмір_накопичувача_виконання = М.НаО.розмір як п32,
        });
      } інакше якщо вказівка == ВВпасти {
        увімкнути_стан_падіння(М, пусто);
        М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
        вернути виділити_обʼєкт_юнікоду_з_ю8(М, ю8"Впасти не втілено") як адреса<Обʼєкт>;
      } інакше якщо вказівка == ВЗакінчитиСпробу {
        ціль позиція_вказівки_виходу = код.накопичувач_вказівок.дані[позиція_вказівки + 1];
        позиція_вказівки = позиція_вказівки + 1;
        забрати_з_накопичувача<Спроба>(спроби::адреса);
        позиція_вказівки = позиція_вказівки_виходу - 1;
      } інакше якщо вказівка == ВВзяти {
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви_типу = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва_типу = М.БН.дані.дані[позиція_назви_типу];
        ціль накопичувач_назв = зробити_накопичувач<адреса<Назва>>();
        змінна ціль пнн: позитивне = 0;
        поки пнн < М.НаН.розмір {
          покласти_в_накопичувач<адреса<Назва>>(накопичувач_назв::адреса, М.НаН.дані[пнн]);
          пнн += 1;
        }
        М.НаН.розмір = 0;
        змінна ціль обʼєкт_модуля: адреса<Обʼєкт> = пусто;
        якщо назва_типу == М.БН.С.модуль {
          обʼєкт_модуля = МаМа::взяти_модуль(М, середовище, пусто, накопичувач_назв);
        } інакше якщо назва_типу == М.БН.С.біб {
          обʼєкт_модуля = МаМа::взяти_біб(М, накопичувач_назв);
        } інакше якщо назва_типу == М.БН.С.пак {
          обʼєкт_модуля = МаМа::взяти_модуль(М, середовище, накопичувач_назв.дані[0], накопичувач_назв);
        } інакше {
          // потім: помилка
        }
        звільнити_значення_накопичувача<адреса<Назва>>(накопичувач_назв);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути обʼєкт_модуля;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, обʼєкт_модуля);
      } інакше якщо вказівка == ВДати {
        позиція_вказівки = позиція_вказівки + 1;
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        якщо середовище.обʼєкт_модуля == пусто {
          увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки));
          вернути виділити_обʼєкт_юнікоду_з_ю8(М, ю8"Вказівка \"дати\" працює лише в середовищі модуля") як адреса<Обʼєкт>;
        }
        змінити_в_реєстрі<адреса<Назва>, адреса<Обʼєкт>>(середовище.обʼєкт_модуля.властивості::адреса, назва, обʼєкт);
      } інакше якщо вказівка == ВПокластиРеєстрАргументівЗНазвами {
        ціль іменовані_аргументи = виділити_реєстр<адреса<Назва>, адреса<Обʼєкт>>(перевірити_чи_назви_рівні);
        покласти_в_накопичувач<адреса<Реєстр<адреса<Назва>, адреса<Обʼєкт>>>>(М.НаРАрг::адреса, іменовані_аргументи);
      } інакше якщо вказівка == ВЗареєструватиАргументЗНазвою {
        ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        змінити_в_реєстрі<адреса<Назва>, адреса<Обʼєкт>>(М.НаРАрг.дані[М.НаРАрг.розмір - 1], назва, значення);
      } інакше якщо вказівка == ВПокластиРеєстрПараметрів {
        ціль реєстр_параметрів = виділити_реєстр<адреса<Назва>, Параметр>(перевірити_чи_назви_рівні);
        покласти_в_накопичувач<адреса<Реєстр<адреса<Назва>, Параметр>>>(М.НаРПар::адреса, реєстр_параметрів);
      } інакше якщо вказівка == ВЗареєструватиПараметр {
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        позиція_вказівки = позиція_вказівки + 1;
        ціль кількість_типів = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль типи = зробити_накопичувач<адреса<ОбʼєктСтруктури>>();
        змінна ціль пт: п32 = 0;
        поки пт < кількість_типів {
          ціль тип = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
          якщо тип.тип != М.обʼєкт_структури_Структура {
            увімкнути_стан_падіння(М, пусто);
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
            вернути виділити_обʼєкт_юнікоду_з_ю8(М, ю8"Тип параметра має бути структурою") як адреса<Обʼєкт>;
          }
          покласти_в_накопичувач<адреса<ОбʼєктСтруктури>>(типи::адреса, тип як адреса<ОбʼєктСтруктури>);
          пт = пт + 1;
        }
        обернути_накопичувач<адреса<ОбʼєктСтруктури>>(типи::адреса);
        ціль код_значення_за_замовчуванням = М.ТрК;
        М.ТрК = пусто;
        ціль параметр = Параметр {
          типи = типи,
          код_значення_за_замовчуванням = код_значення_за_замовчуванням,
        };
        змінити_в_реєстрі<адреса<Назва>, Параметр>(М.НаРПар.дані[М.НаРПар.розмір - 1], назва, параметр);
      } інакше якщо вказівка == ВТриматиКод {
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_коду = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль код = М.сховище_кодів.дані[позиція_коду];
        М.ТрК = код;
      } інакше якщо вказівка == ВНакопичитиНазву {
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        покласти_в_накопичувач<адреса<Назва>>(М.НаН::адреса, М.БН.дані.дані[позиція_назви]);
      } інакше якщо вказівка == ВСтрибнути {
        ціль позиція_вказівки_стрибка = код.накопичувач_вказівок.дані[позиція_вказівки + 1];
        позиція_вказівки = позиція_вказівки + 1;
        позиція_вказівки = позиція_вказівки_стрибка - 1;
      } інакше якщо вказівка == ВСтрибнутиЯкщоНі {
        ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль позиція_вказівки_стрибка = код.накопичувач_вказівок.дані[позиція_вказівки + 1];
        позиція_вказівки = позиція_вказівки + 1;
        якщо перевірити_чи_обʼєкт_виражається_логічним_так(значення, М) == ні {
          позиція_вказівки = позиція_вказівки_стрибка - 1;
        }
      } інакше якщо вказівка == ВЗабрати {
        забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      } інакше {
        увімкнути_стан_падіння(М, пусто);
        М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
        вернути виділити_обʼєкт_юнікоду_з_ю8(М, ю8"Виявлено невідому вказівку") як адреса<Обʼєкт>;
      }
      позиція_вказівки = позиція_вказівки + 1;
    }
    звільнити_значення_накопичувача<Спроба>(спроби);
    вернути пусто;
  }

  дія отримати_назву_паку_з_середовища(М: адреса<Машина>, середовище: адреса<Середовище>): адреса<Назва> {
    змінна ціль поточне_середовище = середовище;
    поки поточне_середовище != пусто {
      якщо поточне_середовище.обʼєкт_модуля != пусто {
        якщо поточне_середовище.обʼєкт_модуля.назва_паку != пусто {
          вернути поточне_середовище.обʼєкт_модуля.назва_паку;
        }
      }
      поточне_середовище = поточне_середовище.батьківське;
    }
    вернути пусто;
  }

  місцева дія взяти_модуль(М: адреса<Машина>, середовище: адреса<Середовище>, назва_паку: адреса<Назва>, шлях: Накопичувач<адреса<Назва>>): обʼєкт_або_стан_падіння {
    якщо назва_паку == пусто {
      назва_паку = отримати_назву_паку_з_середовища(М, середовище);
    }
    якщо М.обробник_отримання_шляху_до_модуля == пусто {
      вернути виділити_обʼєкт_юнікоду_з_ю8(М, ю8"Обробник отримання шляху до модуля не втілено в Машині") як адреса<Обʼєкт>;
    }
    ціль шлях_до_модуля: памʼять<п8> = пусто;
    якщо М.обробник_отримання_шляху_до_модуля(М, назва_паку, шлях, шлях_до_модуля::адреса) == ні {
      // потім: помилка
    }
    ціль елемент_взятого_модуля = отримати_з_реєстру<Ю8, адреса<ОбʼєктМодуля>>(М.взяті_модулі::адреса, шлях_до_модуля);
    якщо елемент_взятого_модуля != пусто {
      вернути елемент_взятого_модуля.значення як адреса<Обʼєкт>;
    }
    якщо М.обробник_взяття_модуля == пусто {
      вернути виділити_обʼєкт_юнікоду_з_ю8(М, ю8"Обробник взяття модуля не втілено в Машині") як адреса<Обʼєкт>;
    }
    ціль обʼєкт_модуля = виділити_обʼєкт_модуля(М, шлях.дані[шлях.розмір - 1]);
    якщо назва_паку != пусто {
      обʼєкт_модуля.назва_паку = назва_паку;
    }
    змінити_в_реєстрі<Ю8, адреса<ОбʼєктМодуля>>(М.взяті_модулі::адреса, шлях_до_модуля, обʼєкт_модуля);
    ціль результат_обробника_взяття_модуля = М.обробник_взяття_модуля(М, обʼєкт_модуля, шлях_до_модуля);
    якщо М.стан_падіння {
      вернути результат_обробника_взяття_модуля;
    }
    вернути обʼєкт_модуля як адреса<Обʼєкт>;
  }

  місцева дія взяти_модуль_за_шляхом(М: адреса<Машина>, середовище: адреса<Середовище>, назва_модуля: адреса<Назва>, шлях_до_модуля: Ю8): обʼєкт_або_стан_падіння {
    ціль елемент_взятого_модуля = отримати_з_реєстру<Ю8, адреса<ОбʼєктМодуля>>(М.взяті_модулі::адреса, шлях_до_модуля);
    якщо елемент_взятого_модуля != пусто {
      вернути елемент_взятого_модуля.значення як адреса<Обʼєкт>;
    }
    якщо М.обробник_взяття_модуля == пусто {
      вернути виділити_обʼєкт_юнікоду_з_ю8(М, ю8"Обробник взяття модуля не втілено в Машині") як адреса<Обʼєкт>;
    }
    ціль обʼєкт_модуля = виділити_обʼєкт_модуля(М, назва_модуля);
    змінити_в_реєстрі<Ю8, адреса<ОбʼєктМодуля>>(М.взяті_модулі::адреса, шлях_до_модуля, обʼєкт_модуля);
    ціль результат_обробника_взяття_модуля = М.обробник_взяття_модуля(М, обʼєкт_модуля, шлях_до_модуля);
    якщо М.стан_падіння {
      вернути результат_обробника_взяття_модуля;
    }
    вернути обʼєкт_модуля як адреса<Обʼєкт>;
  }

  місцева дія взяти_біб(М: адреса<Машина>, шлях: Накопичувач<адреса<Назва>>): обʼєкт_або_стан_падіння {
    ціль шлях_до_модуля: памʼять<п8> = ю8"біб:/..."; // потім: втілити
    ціль елемент_взятого_модуля = отримати_з_реєстру<Ю8, адреса<ОбʼєктМодуля>>(М.взяті_модулі::адреса, шлях_до_модуля);
    якщо елемент_взятого_модуля != пусто {
      вернути елемент_взятого_модуля.значення як адреса<Обʼєкт>;
    }
    якщо М.обробник_взяття_біб == пусто {
      вернути виділити_обʼєкт_юнікоду_з_ю8(М, ю8"Обробник взяття біб не втілено в Машині") як адреса<Обʼєкт>;
    }
    ціль обʼєкт_модуля = виділити_обʼєкт_модуля(М, шлях.дані[шлях.розмір - 1]);
    змінити_в_реєстрі<Ю8, адреса<ОбʼєктМодуля>>(М.взяті_модулі::адреса, шлях_до_модуля, обʼєкт_модуля);
    ціль результат_обробника_взяття_модуля = М.обробник_взяття_біб(М, обʼєкт_модуля, шлях);
    якщо М.стан_падіння {
      вернути результат_обробника_взяття_модуля;
    }
    вернути обʼєкт_модуля як адреса<Обʼєкт>;
  }
}