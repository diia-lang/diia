////
// Автор це Богданович Давид Когут Прихожденко та Організація Мавки та Організація Організацій
////

взяти визначення МаМа;

секція МаМа {
  місцева дія виділити_машину(): адреса<Машина> {
    ціль М = виділити<Машина>();
    М.утилізатор = зробити_утилізатор();
    М.БН = зробити_базу_назв();
    М.НаВикО = зробити_накопичувач<адреса<Обʼєкт>>();
    М.НаВикРАрг = зробити_накопичувач<адреса<Реєстр<адреса<Назва>, адреса<Обʼєкт>>>>();
    М.НаВикРПар = зробити_накопичувач<адреса<Реєстр<адреса<Назва>, Параметр>>>();
    М.ТрВикК = пусто;
    М.НаВикІст = зробити_накопичувач<ЕлементІсторіїВиконання>();
    М.глобальне_середовище = виділити_середовище(М, пусто);
    М.стан_падіння = ні;
    М.місцезнаходження_падіння = пусто;
    М.НаКомКонст = зробити_накопичувач<адреса<Обʼєкт>>();
    М.НаКомК = зробити_накопичувач<адреса<Код>>();

    // § Створення обʼєктів "обʼєкт" та "Структура":
    //   "обʼєкт" це Структура що не має предка.
    //   "Структура" це Структура що має предок "обʼєкт".
    //   Мають виконуватись наступні умови:
    //     1. обʼєкт є обʼєкт
    //     2. обʼєкт є Структура
    //     3. Структура є обʼєкт
    //     4. Структура є Структура
    М.обʼєкт_структури_обʼєкт = виділити_обʼєкт_структури(М, М.БН.С.обʼєкт, пусто);
    М.обʼєкт_структури_Структура = виділити_обʼєкт_структури(М, М.БН.С.Структура, пусто);
    М.обʼєкт_структури_обʼєкт.тип = М.обʼєкт_структури_Структура;
    М.обʼєкт_структури_обʼєкт.предок = пусто;
    М.обʼєкт_структури_Структура.тип = М.обʼєкт_структури_Структура;
    М.обʼєкт_структури_Структура.предок = М.обʼєкт_структури_обʼєкт;

    М.обʼєкт_структури_Дія = виділити_обʼєкт_структури(М, М.БН.С.Дія, М.обʼєкт_структури_обʼєкт);
    М.обʼєкт_структури_НативнаДія = виділити_обʼєкт_структури(М, М.БН.С.НативнаДія, М.обʼєкт_структури_обʼєкт);
    М.обʼєкт_структури_число = створити_структуру_числа(М);
    М.обʼєкт_структури_текст = виділити_обʼєкт_структури(М, М.БН.С.текст, М.обʼєкт_структури_обʼєкт);

    змінити_в_середовищі(М.глобальне_середовище, М.БН.С.обʼєкт, М.обʼєкт_структури_обʼєкт як адреса<Обʼєкт>);
    змінити_в_середовищі(М.глобальне_середовище, М.БН.С.Структура, М.обʼєкт_структури_Структура як адреса<Обʼєкт>);
    змінити_в_середовищі(М.глобальне_середовище, М.БН.С.НативнаДія, М.обʼєкт_структури_НативнаДія як адреса<Обʼєкт>);
    змінити_в_середовищі(М.глобальне_середовище, М.БН.С.Дія, М.обʼєкт_структури_Дія як адреса<Обʼєкт>);
    змінити_в_середовищі(М.глобальне_середовище, М.БН.С.число, М.обʼєкт_структури_число як адреса<Обʼєкт>);
    змінити_в_середовищі(М.глобальне_середовище, М.БН.С.текст, М.обʼєкт_структури_текст як адреса<Обʼєкт>);
    вернути М;
  }

  місцева дія увімкнути_стан_падіння(М: адреса<Машина>) {
    М.стан_падіння = так;
    М.місцезнаходження_падіння = пусто;
  }

  структура Спроба {
    позиція_вказівки_зловити: п32;
    розмір_накопичувача_виконання: п32;
  }

  місцева дія виконати_код(М: адреса<Машина>, середовище: адреса<Середовище>, код: адреса<Код>): обʼєкт_або_стан_падіння {
    ціль нове_середовище = виділити_середовище(М, середовище);
    покласти_в_накопичувач<МаМа::ЕлементІсторіїВиконання>(М.НаВикІст::адреса, МаМа::ЕлементІсторіїВиконання {
      обʼєкт_дії = пусто,
      середовище = нове_середовище
    });
    ціль результат = виконати_код_в_середовищі(М, нове_середовище, код);
    забрати_з_накопичувача<МаМа::ЕлементІсторіїВиконання>(М.НаВикІст::адреса);
    вернути результат;
  }

  місцева дія виконати_код_в_середовищі(М: адреса<Машина>, середовище: адреса<Середовище>, код: адреса<Код>): обʼєкт_або_стан_падіння {
    ціль спроби = зробити_накопичувач<Спроба>();
    ціль позиція_вказівки: п32 = 0;
    поки позиція_вказівки < код.накопичувач_вказівок.розмір {
      якщо М.утилізатор.кількість_обʼєктів >= М.утилізатор.кількість_обʼєктів_щоб_запустити_утилізацію {
        утилізувати(М);
      }
      якщо М.утилізатор.кількість_середовищ >= М.утилізатор.кількість_середовищ_щоб_запустити_утилізацію {
        утилізувати(М);
      }
      ціль вказівка = код.накопичувач_вказівок.дані[позиція_вказівки];
      якщо вказівка == ВВизначити {
        ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        змінити_в_середовищі(середовище, назва, значення);
      } інакше якщо вказівка == ВЗвернутись {
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, знайти_в_середовищі(середовище, назва));
      } інакше якщо вказівка == ВПокластиКонстанту {
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_константи = код.накопичувач_вказівок.дані[позиція_вказівки];
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, М.НаКомКонст.дані[позиція_константи]);
      } інакше якщо вказівка == ВДодати {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль результат_додавання = обʼєкт_додати(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат_додавання;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, результат_додавання);
      } інакше якщо вказівка == ВВиконати {
        ціль позиція_цієї_вказівки = позиція_вказівки;
        позиція_вказівки = позиція_вказівки + 1;
        ціль кількість_аргументів = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль аргументи = зробити_накопичувач<адреса<Обʼєкт>>();
        змінна ціль па: п32 = 0;
        поки па < кількість_аргументів {
          ціль аргумент = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
          покласти_в_накопичувач<адреса<Обʼєкт>>(аргументи::адреса, аргумент);
          па += 1;
        }
        обернути_накопичувач<адреса<Обʼєкт>>(аргументи::адреса);
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль результат_виконання = обʼєкт_виконати(обʼєкт, М, пусто, аргументи::адреса, пусто);
        звільнити_значення_накопичувача<адреса<Обʼєкт>>(аргументи);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_цієї_вказівки);
          }
          вернути результат_виконання;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, результат_виконання);
      } інакше якщо вказівка == ВПопроситиВиконати {
        ціль позиція_цієї_вказівки = позиція_вказівки;
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        позиція_вказівки = позиція_вказівки + 1;
        ціль кількість_аргументів = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль аргументи = зробити_накопичувач<адреса<Обʼєкт>>();
        змінна ціль па: п32 = 0;
        поки па < кількість_аргументів {
          ціль аргумент = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
          покласти_в_накопичувач<адреса<Обʼєкт>>(аргументи::адреса, аргумент);
          па += 1;
        }
        обернути_накопичувач<адреса<Обʼєкт>>(аргументи::адреса);
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль обʼєкт_властивості = обʼєкт_отримати_властивість(обʼєкт, М, назва);
        ціль результат_виконання = обʼєкт_виконати(обʼєкт_властивості, М, обʼєкт, аргументи::адреса, пусто);
        звільнити_значення_накопичувача<адреса<Обʼєкт>>(аргументи);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_цієї_вказівки);
          }
          вернути результат_виконання;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, результат_виконання);
      } інакше якщо вказівка == ВВиконатиЗНазвами {
        ціль позиція_цієї_вказівки = позиція_вказівки;
        ціль іменовані_аргументи = забрати_з_накопичувача<адреса<Реєстр<адреса<Назва>, адреса<Обʼєкт>>>>(М.НаВикРАрг::адреса);
        позиція_вказівки = позиція_вказівки + 1;
        ціль кількість_аргументів = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль аргументи = зробити_накопичувач<адреса<Обʼєкт>>();
        змінна ціль па: п32 = 0;
        поки па < кількість_аргументів {
          ціль аргумент = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
          покласти_в_накопичувач<адреса<Обʼєкт>>(аргументи::адреса, аргумент);
          па += 1;
        }
        обернути_накопичувач<адреса<Обʼєкт>>(аргументи::адреса);
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль результат_виконання = обʼєкт_виконати(обʼєкт, М, пусто, аргументи::адреса, іменовані_аргументи);
        звільнити_значення_накопичувача<адреса<Обʼєкт>>(аргументи);
        звільнити_реєстр<адреса<Назва>, адреса<Обʼєкт>>(іменовані_аргументи);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_цієї_вказівки);
          }
          вернути результат_виконання;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, результат_виконання);
      } інакше якщо вказівка == ВПопроситиВиконатиЗНазвами {
        ціль позиція_цієї_вказівки = позиція_вказівки;
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        ціль іменовані_аргументи = забрати_з_накопичувача<адреса<Реєстр<адреса<Назва>, адреса<Обʼєкт>>>>(М.НаВикРАрг::адреса);
        позиція_вказівки = позиція_вказівки + 1;
        ціль кількість_аргументів = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль аргументи = зробити_накопичувач<адреса<Обʼєкт>>();
        змінна ціль па: п32 = 0;
        поки па < кількість_аргументів {
          ціль аргумент = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
          покласти_в_накопичувач<адреса<Обʼєкт>>(аргументи::адреса, аргумент);
          па += 1;
        }
        обернути_накопичувач<адреса<Обʼєкт>>(аргументи::адреса);
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль обʼєкт_властивості = обʼєкт_отримати_властивість(обʼєкт, М, назва);
        ціль результат_виконання = обʼєкт_виконати(обʼєкт_властивості, М, обʼєкт, аргументи::адреса, іменовані_аргументи);
        звільнити_значення_накопичувача<адреса<Обʼєкт>>(аргументи);
        звільнити_реєстр<адреса<Назва>, адреса<Обʼєкт>>(іменовані_аргументи);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_цієї_вказівки);
          }
          вернути результат_виконання;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, результат_виконання);
      } інакше якщо вказівка == ВПопроситиВластивість {
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, обʼєкт_отримати_властивість(обʼєкт, М, назва));
      } інакше якщо вказівка == ВПопроситиЗмінитиВластивість {
        ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        ціль результат_зміни_властивості = обʼєкт_змінити_властивість(обʼєкт, М, назва, значення);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат_зміни_властивості;
        }
      } інакше якщо вказівка == ВПокластиРеєстрАргументівЗНазвами {
        ціль іменовані_аргументи = виділити_реєстр<адреса<Назва>, адреса<Обʼєкт>>(перевірити_чи_назви_рівні);
        покласти_в_накопичувач<адреса<Реєстр<адреса<Назва>, адреса<Обʼєкт>>>>(М.НаВикРАрг::адреса, іменовані_аргументи);
      } інакше якщо вказівка == ВЗареєструватиАргументЗНазвою {
        ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        змінити_в_реєстрі<адреса<Назва>, адреса<Обʼєкт>>(М.НаВикРАрг.дані[М.НаВикРАрг.розмір - 1], назва, значення);
      } інакше якщо вказівка == ВПокластиПусто {
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, пусто);
      } інакше якщо вказівка == ВПокластиРеєстрПараметрів {
        ціль реєстр_параметрів = виділити_реєстр<адреса<Назва>, Параметр>(перевірити_чи_назви_рівні);
        покласти_в_накопичувач<адреса<Реєстр<адреса<Назва>, Параметр>>>(М.НаВикРПар::адреса, реєстр_параметрів);
      } інакше якщо вказівка == ВЗареєструватиПараметр {
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        позиція_вказівки = позиція_вказівки + 1;
        ціль кількість_типів = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль типи = зробити_накопичувач<адреса<ОбʼєктСтруктури>>();
        змінна ціль пт: п32 = 0;
        поки пт < кількість_типів {
          ціль тип = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
          якщо тип.тип != М.обʼєкт_структури_Структура {
            увімкнути_стан_падіння(М);
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
            вернути виділити_обʼєкт_тексту_з_ю8(М, ю8"Тип параметра має бути структурою") як адреса<Обʼєкт>;
          }
          покласти_в_накопичувач<адреса<ОбʼєктСтруктури>>(типи::адреса, тип як адреса<ОбʼєктСтруктури>);
          пт = пт + 1;
        }
        обернути_накопичувач<адреса<ОбʼєктСтруктури>>(типи::адреса);
        ціль код_значення_за_замовчуванням = М.ТрВикК;
        М.ТрВикК = пусто;
        ціль параметр = Параметр {
          типи = типи,
          код_значення_за_замовчуванням = код_значення_за_замовчуванням,
        };
        змінити_в_реєстрі<адреса<Назва>, Параметр>(М.НаВикРПар.дані[М.НаВикРПар.розмір - 1], назва, параметр);
      } інакше якщо вказівка == ВСтворитиСтруктуру {
        ціль реєстр_параметрів = забрати_з_накопичувача<адреса<Реєстр<адреса<Назва>, Параметр>>>(М.НаВикРПар::адреса);
        ціль обʼєкт_предка = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        якщо обʼєкт_предка.тип != М.обʼєкт_структури_Структура {
          увімкнути_стан_падіння(М);
          М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          вернути виділити_обʼєкт_тексту_з_ю8(М, ю8"Предок має бути структурою") як адреса<Обʼєкт>;
        }
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        ціль обʼєкт_структури = виділити_обʼєкт_структури(М, назва, обʼєкт_предка як адреса<ОбʼєктСтруктури>);
        змінна ціль пп: позитивне = 0;
        поки пп < реєстр_параметрів.розмір {
          змінити_в_реєстрі<адреса<Назва>, Параметр>(обʼєкт_структури.параметри, реєстр_параметрів.елементи[пп].ключ, реєстр_параметрів.елементи[пп].значення);
          пп += 1;
        }
        звільнити_реєстр<адреса<Назва>, Параметр>(реєстр_параметрів);
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, обʼєкт_структури як адреса<Обʼєкт>);
      } інакше якщо вказівка == ВСтворитиДію {
        ціль реєстр_параметрів = забрати_з_накопичувача<адреса<Реєстр<адреса<Назва>, Параметр>>>(М.НаВикРПар::адреса);
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки + 1];
        позиція_вказівки = позиція_вказівки + 1;
        ціль назва = М.БН.дані.дані[позиція_назви];
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_підкоду = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль підкод = М.НаКомК.дані[позиція_підкоду];
        // потім: треба ще тип результату
        ціль обʼєкт_дії = виділити_обʼєкт_дії(М, назва, реєстр_параметрів, середовище, підкод);
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, обʼєкт_дії як адреса<Обʼєкт>);
      } інакше якщо вказівка == ВТриматиКод {
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_підкоду = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль підкод = М.НаКомК.дані[позиція_підкоду];
        М.ТрВикК = підкод;
      } інакше якщо вказівка == ВПочатиСпробу {
        ціль позиція_вказівки_зловити = код.накопичувач_вказівок.дані[позиція_вказівки + 1];
        позиція_вказівки = позиція_вказівки + 1;
        покласти_в_накопичувач<Спроба>(спроби::адреса, Спроба {
          позиція_вказівки_зловити = позиція_вказівки_зловити,
          розмір_накопичувача_виконання = М.НаВикО.розмір як п32,
        });
      } інакше якщо вказівка == ВЗакінчитиСпробу {
        ціль позиція_вказівки_виходу = код.накопичувач_вказівок.дані[позиція_вказівки + 1];
        позиція_вказівки = позиція_вказівки + 1;
        забрати_з_накопичувача<Спроба>(спроби::адреса);
        позиція_вказівки = позиція_вказівки_виходу - 1;
      } інакше якщо вказівка == ВСтрибнути {
        ціль позиція_вказівки_стрибка = код.накопичувач_вказівок.дані[позиція_вказівки + 1];
        позиція_вказівки = позиція_вказівки + 1;
        позиція_вказівки = позиція_вказівки_стрибка - 1;
      } інакше якщо вказівка == ВСтрибнутиЯкщоНі {
        ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль позиція_вказівки_стрибка = код.накопичувач_вказівок.дані[позиція_вказівки + 1];
        позиція_вказівки = позиція_вказівки + 1;
        якщо обʼєкт_може_бути_так(значення, М) == ні {
          позиція_вказівки = позиція_вказівки_стрибка - 1;
        }
      } інакше якщо вказівка == ВВпасти {
        увімкнути_стан_падіння(М);
        М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
        вернути виділити_обʼєкт_тексту_з_ю8(М, ю8"Впасти не втілено") як адреса<Обʼєкт>;
      } інакше якщо вказівка == ВЗабрати {
        забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
      } інакше {
        увімкнути_стан_падіння(М);
        М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
        вернути виділити_обʼєкт_тексту_з_ю8(М, ю8"Виявлено невідому вказівку") як адреса<Обʼєкт>;
      }
      позиція_вказівки = позиція_вказівки + 1;
    }
    звільнити_значення_накопичувача<Спроба>(спроби);
    вернути пусто;
  }
}