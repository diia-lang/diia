////
// Автор це Богданович Давид Когут Прихожденко та Організація Мавки та Організація Організацій
////

взяти визначення МаМа;

секція МаМа {
  місцева дія виділити_машину(): адреса<Машина> {
    ціль М = виділити<Машина>();
    М.утилізатор = зробити_утилізатор();
    М.БН = зробити_базу_назв();
    М.НаВикО = зробити_накопичувач<адреса<Обʼєкт>>();
    М.НаВикРАрг = зробити_накопичувач<адреса<Реєстр<адреса<Назва>, адреса<Обʼєкт>>>>();
    М.НаВикРПар = зробити_накопичувач<адреса<Реєстр<адреса<Назва>, Параметр>>>();
    М.ТрВикК = пусто;
    М.НаВикІст = зробити_накопичувач<ЕлементІсторіїВиконання>();
    М.НаВикНаз = зробити_накопичувач<адреса<Назва>>();
    М.глобальне_середовище = виділити_середовище(М, пусто);
    М.стан_падіння = ні;
    М.місцезнаходження_падіння = пусто;
    М.НаКомКонст = зробити_накопичувач<адреса<Обʼєкт>>();
    М.НаКомК = зробити_накопичувач<адреса<Код>>();
    М.обробник_взяття_модуля = пусто;
    М.обробник_взяття_біб = пусто;
    М.взяті_модулі = зробити_реєстр<Ю8, адреса<ОбʼєктМодуля>>(перевірити_чи_ю8_рівні);
    М.взяті_модулі_біб = зробити_реєстр<Ю8, адреса<ОбʼєктМодуля>>(перевірити_чи_ю8_рівні);
    М.дані_виконувача = пусто;

    // § Створення обʼєктів "обʼєкт" та "Структура":
    //   "обʼєкт" це Структура що не має предка.
    //   "Структура" це Структура що має предок "обʼєкт".
    //   Мають виконуватись наступні умови:
    //     1. обʼєкт є обʼєкт
    //     2. обʼєкт є Структура
    //     3. Структура є обʼєкт
    //     4. Структура є Структура
    М.обʼєкт_структури_обʼєкт = виділити_обʼєкт_структури(М, М.БН.С.обʼєкт, пусто);
    М.обʼєкт_структури_Структура = виділити_обʼєкт_структури(М, М.БН.С.Структура, пусто);
    М.обʼєкт_структури_обʼєкт.тип = М.обʼєкт_структури_Структура;
    М.обʼєкт_структури_обʼєкт.предок = пусто;
    М.обʼєкт_структури_Структура.тип = М.обʼєкт_структури_Структура;
    М.обʼєкт_структури_Структура.предок = М.обʼєкт_структури_обʼєкт;

    М.обʼєкт_структури_Дія = виділити_обʼєкт_структури(М, М.БН.С.Дія, М.обʼєкт_структури_обʼєкт);
    М.обʼєкт_структури_НативнаДія = виділити_обʼєкт_структури(М, М.БН.С.НативнаДія, М.обʼєкт_структури_обʼєкт);
    М.обʼєкт_структури_число = створити_структуру_числа(М);
    М.обʼєкт_структури_текст = виділити_обʼєкт_структури(М, М.БН.С.текст, М.обʼєкт_структури_обʼєкт);
    М.обʼєкт_структури_юнікод = виділити_обʼєкт_структури(М, М.БН.С.юнікод, М.обʼєкт_структури_обʼєкт);
    М.обʼєкт_структури_Модуль = виділити_обʼєкт_структури(М, М.БН.С.Модуль, М.обʼєкт_структури_обʼєкт);
    М.обʼєкт_структури_список = виділити_обʼєкт_структури(М, М.БН.С.список, М.обʼєкт_структури_обʼєкт);
    М.обʼєкт_структури_словник = виділити_обʼєкт_структури(М, М.БН.С.словник, М.обʼєкт_структури_обʼєкт);
    М.обʼєкт_структури_логічне = виділити_обʼєкт_структури(М, М.БН.С.логічне, М.обʼєкт_структури_обʼєкт);

    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.обʼєкт, М.обʼєкт_структури_обʼєкт як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.Структура, М.обʼєкт_структури_Структура як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.НативнаДія, М.обʼєкт_структури_НативнаДія як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.Дія, М.обʼєкт_структури_Дія як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.число, М.обʼєкт_структури_число як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.текст, М.обʼєкт_структури_текст як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.юнікод, М.обʼєкт_структури_юнікод як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.Модуль, М.обʼєкт_структури_Модуль як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.список, М.обʼєкт_структури_список як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.словник, М.обʼєкт_структури_словник як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.логічне, М.обʼєкт_структури_логічне як адреса<Обʼєкт>);

    М.обʼєкт_логічного_так = виділити_обʼєкт_логічного(М, так);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.так, М.обʼєкт_логічного_так як адреса<Обʼєкт>);
    М.обʼєкт_логічного_ні = виділити_обʼєкт_логічного(М, ні);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.ні, М.обʼєкт_логічного_ні як адреса<Обʼєкт>);
    вернути М;
  }

  місцева дія звільнити_машину(М: адреса<Машина>) {
    // ...
  }

  місцева дія увімкнути_стан_падіння(М: адреса<Машина>, місцезнаходження_падіння: адреса<МісцезнаходженняПадіння>) {
    М.стан_падіння = так;
    М.місцезнаходження_падіння = пусто;
  }

  місцева дія покласти_константу(М: адреса<Машина>, обʼєкт: адреса<Обʼєкт>): п32 {
    покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаКомКонст::адреса, обʼєкт);
    вернути М.НаКомКонст.розмір як п32 - 1;
  }

  структура Спроба {
    позиція_вказівки_зловити: п32;
    розмір_накопичувача_виконання: п32;
  }

  місцева дія виконати_код(М: адреса<Машина>, середовище: адреса<Середовище>, код: адреса<Код>): обʼєкт_або_стан_падіння {
    ціль нове_середовище = виділити_середовище(М, середовище);
    покласти_в_накопичувач<МаМа::ЕлементІсторіїВиконання>(М.НаВикІст::адреса, МаМа::ЕлементІсторіїВиконання {
      обʼєкт_дії = пусто,
      середовище = нове_середовище
    });
    ціль результат = виконати_код_в_середовищі(М, нове_середовище, код);
    забрати_з_накопичувача<МаМа::ЕлементІсторіїВиконання>(М.НаВикІст::адреса);
    вернути результат;
  }

  місцева дія виконати_код_в_середовищі(М: адреса<Машина>, середовище: адреса<Середовище>, код: адреса<Код>): обʼєкт_або_стан_падіння {
    ціль спроби = зробити_накопичувач<Спроба>();
    ціль позиція_вказівки: п32 = 0;
    поки позиція_вказівки < код.накопичувач_вказівок.розмір {
      якщо М.утилізатор.кількість_обʼєктів >= М.утилізатор.кількість_обʼєктів_щоб_запустити_утилізацію {
        утилізувати(М);
      }
      якщо М.утилізатор.кількість_середовищ >= М.утилізатор.кількість_середовищ_щоб_запустити_утилізацію {
        утилізувати(М);
      }
      ціль вказівка = код.накопичувач_вказівок.дані[позиція_вказівки];
      якщо вказівка == ВВизначити {
        ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        змінити_в_середовищі(М, середовище, назва, значення);
      } інакше якщо вказівка == ВЗвернутись {
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, знайти_в_середовищі(середовище, назва));
      } інакше якщо вказівка == ВПокластиКонстанту {
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_константи = код.накопичувач_вказівок.дані[позиція_вказівки];
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, М.НаКомКонст.дані[позиція_константи]);
      } інакше якщо вказівка == ВДодати {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль результат = обʼєкт_додати(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, результат);
      } інакше якщо вказівка == ВВідняти {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль результат = обʼєкт_відняти(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, результат);
      } інакше якщо вказівка == ВПомножити {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль результат = обʼєкт_помножити(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, результат);
      } інакше якщо вказівка == ВПоділити {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль результат = обʼєкт_поділити(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, результат);
      } інакше якщо вказівка == ВПоділитиЗаМодулем {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль результат = обʼєкт_поділити_за_модулем(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, результат);
      } інакше якщо вказівка == ВПоділитиНаціло {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль результат = обʼєкт_поділити_націло(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, результат);
      } інакше якщо вказівка == ВЗсунутиВліво {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль результат = обʼєкт_зсунути_вліво(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, результат);
      } інакше якщо вказівка == ВЗсунутиВправо {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль результат = обʼєкт_зсунути_вправо(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, результат);
      } інакше якщо вказівка == ВЗсунутиВправоЗнаково {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль результат = обʼєкт_зсунути_вправо_знаково(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, результат);
      } інакше якщо вказівка == ВМенше {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль результат = обʼєкт_менше(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, результат);
      } інакше якщо вказівка == ВБільше {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль результат = обʼєкт_більше(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, результат);
      } інакше якщо вказівка == ВНеБільше {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль результат = обʼєкт_не_більше(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, результат);
      } інакше якщо вказівка == ВНеМенше {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль результат = обʼєкт_не_менше(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, результат);
      } інакше якщо вказівка == ВРівно {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль результат = обʼєкт_рівно(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, результат);
      } інакше якщо вказівка == ВНеРівно {
        ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль результат = обʼєкт_не_рівно(обʼєкт_1, М, обʼєкт_2);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, результат);
      } інакше якщо вказівка == ВВиконати {
        ціль позиція_цієї_вказівки = позиція_вказівки;
        позиція_вказівки = позиція_вказівки + 1;
        ціль кількість_аргументів = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль аргументи = зробити_накопичувач<адреса<Обʼєкт>>();
        змінна ціль па: п32 = 0;
        поки па < кількість_аргументів {
          ціль аргумент = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
          покласти_в_накопичувач<адреса<Обʼєкт>>(аргументи::адреса, аргумент);
          па += 1;
        }
        обернути_накопичувач<адреса<Обʼєкт>>(аргументи::адреса);
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль результат_виконання = обʼєкт_виконати(обʼєкт, М, пусто, аргументи::адреса, пусто);
        звільнити_значення_накопичувача<адреса<Обʼєкт>>(аргументи);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_цієї_вказівки);
          }
          вернути результат_виконання;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, результат_виконання);
      } інакше якщо вказівка == ВПопроситиВиконати {
        ціль позиція_цієї_вказівки = позиція_вказівки;
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        позиція_вказівки = позиція_вказівки + 1;
        ціль кількість_аргументів = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль аргументи = зробити_накопичувач<адреса<Обʼєкт>>();
        змінна ціль па: п32 = 0;
        поки па < кількість_аргументів {
          ціль аргумент = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
          покласти_в_накопичувач<адреса<Обʼєкт>>(аргументи::адреса, аргумент);
          па += 1;
        }
        обернути_накопичувач<адреса<Обʼєкт>>(аргументи::адреса);
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль обʼєкт_властивості = обʼєкт_отримати_властивість(обʼєкт, М, назва);
        ціль результат_виконання = обʼєкт_виконати(обʼєкт_властивості, М, обʼєкт, аргументи::адреса, пусто);
        звільнити_значення_накопичувача<адреса<Обʼєкт>>(аргументи);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_цієї_вказівки);
          }
          вернути результат_виконання;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, результат_виконання);
      } інакше якщо вказівка == ВВиконатиЗНазвами {
        ціль позиція_цієї_вказівки = позиція_вказівки;
        ціль іменовані_аргументи = забрати_з_накопичувача<адреса<Реєстр<адреса<Назва>, адреса<Обʼєкт>>>>(М.НаВикРАрг::адреса);
        позиція_вказівки = позиція_вказівки + 1;
        ціль кількість_аргументів = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль аргументи = зробити_накопичувач<адреса<Обʼєкт>>();
        змінна ціль па: п32 = 0;
        поки па < кількість_аргументів {
          ціль аргумент = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
          покласти_в_накопичувач<адреса<Обʼєкт>>(аргументи::адреса, аргумент);
          па += 1;
        }
        обернути_накопичувач<адреса<Обʼєкт>>(аргументи::адреса);
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль результат_виконання = обʼєкт_виконати(обʼєкт, М, пусто, аргументи::адреса, іменовані_аргументи);
        звільнити_значення_накопичувача<адреса<Обʼєкт>>(аргументи);
        звільнити_реєстр<адреса<Назва>, адреса<Обʼєкт>>(іменовані_аргументи);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_цієї_вказівки);
          }
          вернути результат_виконання;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, результат_виконання);
      } інакше якщо вказівка == ВПопроситиВиконатиЗНазвами {
        ціль позиція_цієї_вказівки = позиція_вказівки;
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        ціль іменовані_аргументи = забрати_з_накопичувача<адреса<Реєстр<адреса<Назва>, адреса<Обʼєкт>>>>(М.НаВикРАрг::адреса);
        позиція_вказівки = позиція_вказівки + 1;
        ціль кількість_аргументів = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль аргументи = зробити_накопичувач<адреса<Обʼєкт>>();
        змінна ціль па: п32 = 0;
        поки па < кількість_аргументів {
          ціль аргумент = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
          покласти_в_накопичувач<адреса<Обʼєкт>>(аргументи::адреса, аргумент);
          па += 1;
        }
        обернути_накопичувач<адреса<Обʼєкт>>(аргументи::адреса);
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль обʼєкт_властивості = обʼєкт_отримати_властивість(обʼєкт, М, назва);
        ціль результат_виконання = обʼєкт_виконати(обʼєкт_властивості, М, обʼєкт, аргументи::адреса, іменовані_аргументи);
        звільнити_значення_накопичувача<адреса<Обʼєкт>>(аргументи);
        звільнити_реєстр<адреса<Назва>, адреса<Обʼєкт>>(іменовані_аргументи);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_цієї_вказівки);
          }
          вернути результат_виконання;
        }
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, результат_виконання);
      } інакше якщо вказівка == ВПопроситиВластивість {
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, обʼєкт_отримати_властивість(обʼєкт, М, назва));
      } інакше якщо вказівка == ВПопроситиЗмінитиВластивість {
        ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        ціль результат_зміни_властивості = обʼєкт_змінити_властивість(обʼєкт, М, назва, значення);
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути результат_зміни_властивості;
        }
      } інакше якщо вказівка == ВПокластиРеєстрАргументівЗНазвами {
        ціль іменовані_аргументи = виділити_реєстр<адреса<Назва>, адреса<Обʼєкт>>(перевірити_чи_назви_рівні);
        покласти_в_накопичувач<адреса<Реєстр<адреса<Назва>, адреса<Обʼєкт>>>>(М.НаВикРАрг::адреса, іменовані_аргументи);
      } інакше якщо вказівка == ВЗареєструватиАргументЗНазвою {
        ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        змінити_в_реєстрі<адреса<Назва>, адреса<Обʼєкт>>(М.НаВикРАрг.дані[М.НаВикРАрг.розмір - 1], назва, значення);
      } інакше якщо вказівка == ВПокластиПусто {
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, пусто);
      } інакше якщо вказівка == ВПокластиРеєстрПараметрів {
        ціль реєстр_параметрів = виділити_реєстр<адреса<Назва>, Параметр>(перевірити_чи_назви_рівні);
        покласти_в_накопичувач<адреса<Реєстр<адреса<Назва>, Параметр>>>(М.НаВикРПар::адреса, реєстр_параметрів);
      } інакше якщо вказівка == ВЗареєструватиПараметр {
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        позиція_вказівки = позиція_вказівки + 1;
        ціль кількість_типів = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль типи = зробити_накопичувач<адреса<ОбʼєктСтруктури>>();
        змінна ціль пт: п32 = 0;
        поки пт < кількість_типів {
          ціль тип = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
          якщо тип.тип != М.обʼєкт_структури_Структура {
            увімкнути_стан_падіння(М, пусто);
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
            вернути виділити_обʼєкт_тексту_з_ю8(М, ю8"Тип параметра має бути структурою") як адреса<Обʼєкт>;
          }
          покласти_в_накопичувач<адреса<ОбʼєктСтруктури>>(типи::адреса, тип як адреса<ОбʼєктСтруктури>);
          пт = пт + 1;
        }
        обернути_накопичувач<адреса<ОбʼєктСтруктури>>(типи::адреса);
        ціль код_значення_за_замовчуванням = М.ТрВикК;
        М.ТрВикК = пусто;
        ціль параметр = Параметр {
          типи = типи,
          код_значення_за_замовчуванням = код_значення_за_замовчуванням,
        };
        змінити_в_реєстрі<адреса<Назва>, Параметр>(М.НаВикРПар.дані[М.НаВикРПар.розмір - 1], назва, параметр);
      } інакше якщо вказівка == ВСтворитиСтруктуру {
        ціль реєстр_параметрів = забрати_з_накопичувача<адреса<Реєстр<адреса<Назва>, Параметр>>>(М.НаВикРПар::адреса);
        ціль обʼєкт_предка = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        якщо обʼєкт_предка.тип != М.обʼєкт_структури_Структура {
          увімкнути_стан_падіння(М, пусто);
          М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          вернути виділити_обʼєкт_тексту_з_ю8(М, ю8"Предок має бути структурою") як адреса<Обʼєкт>;
        }
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        ціль обʼєкт_структури = виділити_обʼєкт_структури(М, назва, обʼєкт_предка як адреса<ОбʼєктСтруктури>);
        змінна ціль пп: позитивне = 0;
        поки пп < реєстр_параметрів.розмір {
          змінити_в_реєстрі<адреса<Назва>, Параметр>(обʼєкт_структури.параметри, реєстр_параметрів.елементи[пп].ключ, реєстр_параметрів.елементи[пп].значення);
          пп += 1;
        }
        звільнити_реєстр<адреса<Назва>, Параметр>(реєстр_параметрів);
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, обʼєкт_структури як адреса<Обʼєкт>);
      } інакше якщо вказівка == ВСтворитиДію {
        ціль реєстр_параметрів = забрати_з_накопичувача<адреса<Реєстр<адреса<Назва>, Параметр>>>(М.НаВикРПар::адреса);
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки + 1];
        позиція_вказівки = позиція_вказівки + 1;
        ціль назва = М.БН.дані.дані[позиція_назви];
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_підкоду = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль підкод = М.НаКомК.дані[позиція_підкоду];
        // потім: треба ще тип результату
        ціль обʼєкт_дії = виділити_обʼєкт_дії(М, назва, реєстр_параметрів, середовище, підкод);
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, обʼєкт_дії як адреса<Обʼєкт>);
      } інакше якщо вказівка == ВТриматиКод {
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_підкоду = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль підкод = М.НаКомК.дані[позиція_підкоду];
        М.ТрВикК = підкод;
      } інакше якщо вказівка == ВПочатиСпробу {
        ціль позиція_вказівки_зловити = код.накопичувач_вказівок.дані[позиція_вказівки + 1];
        позиція_вказівки = позиція_вказівки + 1;
        покласти_в_накопичувач<Спроба>(спроби::адреса, Спроба {
          позиція_вказівки_зловити = позиція_вказівки_зловити,
          розмір_накопичувача_виконання = М.НаВикО.розмір як п32,
        });
      } інакше якщо вказівка == ВЗакінчитиСпробу {
        ціль позиція_вказівки_виходу = код.накопичувач_вказівок.дані[позиція_вказівки + 1];
        позиція_вказівки = позиція_вказівки + 1;
        забрати_з_накопичувача<Спроба>(спроби::адреса);
        позиція_вказівки = позиція_вказівки_виходу - 1;
      } інакше якщо вказівка == ВСтрибнути {
        ціль позиція_вказівки_стрибка = код.накопичувач_вказівок.дані[позиція_вказівки + 1];
        позиція_вказівки = позиція_вказівки + 1;
        позиція_вказівки = позиція_вказівки_стрибка - 1;
      } інакше якщо вказівка == ВСтрибнутиЯкщоНі {
        ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль позиція_вказівки_стрибка = код.накопичувач_вказівок.дані[позиція_вказівки + 1];
        позиція_вказівки = позиція_вказівки + 1;
        якщо обʼєкт_може_бути_так(значення, М) == ні {
          позиція_вказівки = позиція_вказівки_стрибка - 1;
        }
      } інакше якщо вказівка == ВВпасти {
        увімкнути_стан_падіння(М, пусто);
        М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
        вернути виділити_обʼєкт_тексту_з_ю8(М, ю8"Впасти не втілено") як адреса<Обʼєкт>;
      } інакше якщо вказівка == ВЗабрати {
        забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
      } інакше якщо вказівка == ВНакопичитиНазву {
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        покласти_в_накопичувач<адреса<Назва>>(М.НаВикНаз::адреса, М.БН.дані.дані[позиція_назви]);
      } інакше якщо вказівка == ВВзяти {
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви_типу = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва_типу = М.БН.дані.дані[позиція_назви_типу];
        ціль накопичувач_назв_ю8 = зробити_накопичувач<Ю8>();
        змінна ціль пнн: позитивне = 0;
        поки пнн < М.НаВикНаз.розмір {
          ціль ю8 = отримати_ю8_з_назви(М.НаВикНаз.дані[пнн]);
          покласти_в_накопичувач<Ю8>(накопичувач_назв_ю8::адреса, ю8);
          пнн += 1;
        }
        М.НаВикНаз.розмір = 0;
        змінна ціль обʼєкт_модуля: адреса<Обʼєкт> = пусто;
        якщо назва_типу == М.БН.С.модуль {
          обʼєкт_модуля = МаМа::взяти_модуль(М, пусто, накопичувач_назв_ю8);
        } інакше якщо назва_типу == М.БН.С.біб {
          обʼєкт_модуля = МаМа::взяти_біб(М, накопичувач_назв_ю8);
        } інакше якщо назва_типу == М.БН.С.пак {
          обʼєкт_модуля = МаМа::взяти_модуль(М, накопичувач_назв_ю8.дані[0], накопичувач_назв_ю8);
        } інакше {
          // потім: помилка
        }
        якщо М.стан_падіння {
          якщо М.місцезнаходження_падіння == пусто {
            М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
          }
          вернути обʼєкт_модуля;
        }
        звільнити_значення_накопичувача<Ю8>(накопичувач_назв_ю8);
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, обʼєкт_модуля);
      } інакше якщо вказівка == ВДати {
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        // потім: отримати модуль і змінити там властивість
      } інакше якщо вказівка == ВСтворитиМодуль {
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль назва = М.БН.дані.дані[позиція_назви];
        позиція_вказівки = позиція_вказівки + 1;
        ціль позиція_коду = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль код_модуля = М.НаКомК.дані[позиція_коду];
        ціль обʼєкт_модуля = виділити_обʼєкт_модуля(М, назва);
        // потім: виконати код модуля
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, обʼєкт_модуля як адреса<Обʼєкт>);
      } інакше якщо вказівка == ВСтворитиСписок {
        позиція_вказівки = позиція_вказівки + 1;
        ціль розмір_списку = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль обʼєкт_списку = виділити_обʼєкт_списку(М, розмір_списку);
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, обʼєкт_списку як адреса<Обʼєкт>);
      } інакше якщо вказівка == ВСтворитиСловник {
        позиція_вказівки = позиція_вказівки + 1;
        ціль розмір_словника = код.накопичувач_вказівок.дані[позиція_вказівки];
        ціль обʼєкт_словника = виділити_обʼєкт_словника(М, розмір_словника);
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, обʼєкт_словника як адреса<Обʼєкт>);
      } інакше якщо вказівка == ВПокластиВСписок {
        ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса);
        ціль обʼєкт_списку = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаВикО::адреса) як адреса<ОбʼєктСписку>;
        покласти_в_накопичувач<адреса<Обʼєкт>>(обʼєкт_списку.елементи::адреса, значення);
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаВикО::адреса, обʼєкт_списку як адреса<Обʼєкт>);
      } інакше {
        увімкнути_стан_падіння(М, пусто);
        М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки);
        вернути виділити_обʼєкт_тексту_з_ю8(М, ю8"Виявлено невідому вказівку") як адреса<Обʼєкт>;
      }
      позиція_вказівки = позиція_вказівки + 1;
    }
    звільнити_значення_накопичувача<Спроба>(спроби);
    вернути пусто;
  }

  місцева дія взяти_модуль(М: адреса<Машина>, назва_паку: Ю8, шлях: Накопичувач<Ю8>): обʼєкт_або_стан_падіння {
    // потім: обробляти назву паку
    ціль накопичувач_шляху_з_крапками_ю8 = зробити_накопичувач_ю8();
    змінна ціль пш: позитивне = 0;
    поки пш < шлях.розмір {
      покласти_в_накопичувач_ю8(накопичувач_шляху_з_крапками_ю8::адреса, шлях.дані[пш]);
      якщо пш != шлях.розмір - 1 {
        покласти_в_накопичувач_ю8(накопичувач_шляху_з_крапками_ю8::адреса, ю8".");
      }
      пш += 1;
    }
    ціль шлях_з_крапками = виділити_ю8_з_накопичувача_ю8(накопичувач_шляху_з_крапками_ю8::адреса); // не треба звільняти!!!
    звільнити_значення_накопичувача_ю8(накопичувач_шляху_з_крапками_ю8);
    ціль елемент_взятого_модуля = отримати_з_реєстру<Ю8, адреса<ОбʼєктМодуля>>(М.взяті_модулі::адреса, шлях_з_крапками);
    якщо елемент_взятого_модуля != пусто {
      вернути елемент_взятого_модуля.значення як адреса<Обʼєкт>;
    }
    якщо М.обробник_взяття_модуля == пусто {
      вернути виділити_обʼєкт_тексту_з_ю8(М, ю8"Обробник взяття модуля не втілено в Машині") як адреса<Обʼєкт>;
    }
    ціль обʼєкт_модуля = виділити_обʼєкт_модуля(М, назва(М, шлях.дані[шлях.розмір - 1]));
    змінити_в_реєстрі<Ю8, адреса<ОбʼєктМодуля>>(М.взяті_модулі::адреса, шлях_з_крапками, обʼєкт_модуля);
    ціль результат_обробника_взяття_модуля = М.обробник_взяття_модуля(М, обʼєкт_модуля, назва_паку, шлях);
    якщо М.стан_падіння {
      вернути результат_обробника_взяття_модуля;
    }
    вернути обʼєкт_модуля як адреса<Обʼєкт>;
  }

  місцева дія взяти_біб(М: адреса<Машина>, шлях: Накопичувач<Ю8>): обʼєкт_або_стан_падіння {
    якщо М.обробник_взяття_біб == пусто {
      вернути виділити_обʼєкт_тексту_з_ю8(М, ю8"Обробник взяття біб не втілено в Машині") як адреса<Обʼєкт>;
    }
    ціль обʼєкт_модуля = виділити_обʼєкт_модуля(М, назва(М, шлях.дані[шлях.розмір - 1]));
    ціль результат_обробника_взяття_біб = М.обробник_взяття_біб(М, обʼєкт_модуля, шлях);
    якщо М.стан_падіння {
      вернути результат_обробника_взяття_біб;
    }
    вернути обʼєкт_модуля як адреса<Обʼєкт>;
  }
}