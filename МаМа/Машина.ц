взяти визначення МаМа;

секція МаМа {
  місцева дія виділити_машину(): адреса<Машина> {
    ціль М = виділити<Машина>();
    М.утилізатор = зробити_утилізатор();
    М.БН = зробити_базу_назв();
    М.НатО = зробити_накопичувач<адреса<Обʼєкт>>();
    М.НаО = зробити_накопичувач<адреса<Обʼєкт>>();
    М.НаРАрг = зробити_накопичувач<адреса<Реєстр<адреса<Назва>, адреса<Обʼєкт>>>>();
    М.НаРПар = зробити_накопичувач<адреса<Реєстр<адреса<Назва>, Параметр>>>();
    М.ТрК = пусто;
    М.ТрН = пусто;
    М.історія = зробити_накопичувач<ЕлементІсторіїВиконання>();
    М.НаН = зробити_накопичувач<адреса<Назва>>();
    М.НаОТ = зробити_накопичувач<адреса<Обʼєкт>>();
    М.глобальне_середовище = виділити_середовище(М, пусто);
    М.стан_падіння = позитивне(ні);
    М.місцезнаходження_падіння = пусто;
    М.історія_виконання_перед_падінням = зробити_накопичувач<адреса<Обʼєкт>>();
    М.сховище_констант = зробити_накопичувач<адреса<Обʼєкт>>();
    М.сховище_кодів = зробити_накопичувач<адреса<Код>>();
    М.обробник_отримання_шляху_до_модуля = пусто;
    М.обробник_взяття_модуля = пусто;
    М.обробник_взяття_біб = пусто;
    М.взяті_модулі = зробити_реєстр<Ю8, адреса<ОбʼєктМодуля>>(перевірити_чи_ю8_рівні);
    М.дані_виконувача = пусто;

    // § Створення обʼєктів "обʼєкт" та "Структура":
    //   "обʼєкт" це Структура що не має предка.
    //   "Структура" це Структура що має предок "обʼєкт".
    //   Мають виконуватись наступні умови:
    //     1. обʼєкт є обʼєкт
    //     2. обʼєкт є Структура
    //     3. Структура є обʼєкт
    //     4. Структура є Структура
    М.обʼєкт_структури_обʼєкт = виділити_обʼєкт_структури(М, М.БН.С.обʼєкт, пусто);
    М.обʼєкт_структури_Структура = виділити_обʼєкт_структури(М, М.БН.С.Структура, пусто);
    М.обʼєкт_структури_обʼєкт.тип = М.обʼєкт_структури_Структура;
    М.обʼєкт_структури_обʼєкт.предок = пусто;
    М.обʼєкт_структури_Структура.тип = М.обʼєкт_структури_Структура;
    М.обʼєкт_структури_Структура.предок = М.обʼєкт_структури_обʼєкт;

    М.обʼєкт_структури_Дія = виділити_обʼєкт_структури(М, М.БН.С.Дія, М.обʼєкт_структури_обʼєкт);
    М.обʼєкт_структури_НативнаДія = виділити_обʼєкт_структури(М, М.БН.С.НативнаДія, М.обʼєкт_структури_обʼєкт);
    М.обʼєкт_структури_число = створити_структуру_числа(М);
    М.обʼєкт_структури_текст = створити_структуру_тексту(М);
    М.обʼєкт_структури_юнікод = створити_структуру_юнікоду(М);
    М.обʼєкт_структури_Модуль = створити_структуру_модуля(М);
    М.обʼєкт_структури_список = створити_структуру_списку(М);
    М.обʼєкт_структури_словник = створити_структуру_словника(М);
    М.обʼєкт_структури_логічне = створити_структуру_логічного(М);
    М.обʼєкт_структури_байти = створити_структуру_байтів(М);

    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.обʼєкт, М.обʼєкт_структури_обʼєкт як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.Структура, М.обʼєкт_структури_Структура як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.НативнаДія, М.обʼєкт_структури_НативнаДія як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.Дія, М.обʼєкт_структури_Дія як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.число, М.обʼєкт_структури_число як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.текст, М.обʼєкт_структури_текст як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.юнікод, М.обʼєкт_структури_юнікод як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.Модуль, М.обʼєкт_структури_Модуль як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.список, М.обʼєкт_структури_список як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.словник, М.обʼєкт_структури_словник як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.логічне, М.обʼєкт_структури_логічне як адреса<Обʼєкт>);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.байти, М.обʼєкт_структури_байти як адреса<Обʼєкт>);

    М.обʼєкт_логічного_так = виділити_обʼєкт_логічного(М, так);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.так, М.обʼєкт_логічного_так як адреса<Обʼєкт>);
    М.обʼєкт_логічного_ні = виділити_обʼєкт_логічного(М, ні);
    змінити_в_середовищі(М, М.глобальне_середовище, М.БН.С.ні, М.обʼєкт_логічного_ні як адреса<Обʼєкт>);
    вернути М;
  }

  місцева дія звільнити_машину(М: адреса<Машина>) {
    // ...
  }

  місцева дія увімкнути_стан_падіння(М: адреса<Машина>, місцезнаходження_падіння: адреса<МісцезнаходженняПадіння>) {
    М.стан_падіння = позитивне(так);
    М.місцезнаходження_падіння = місцезнаходження_падіння;
//    М.історія_виконання_перед_падінням = ...;
  }

  місцева дія вимкнути_стан_падіння(М: адреса<Машина>) {
    М.стан_падіння = позитивне(ні);
    якщо М.місцезнаходження_падіння != пусто {
      звільнити_місцезнаходження_падіння(М.місцезнаходження_падіння);
      М.місцезнаходження_падіння = пусто;
    }
    М.історія_виконання_перед_падінням.розмір = 0;
  }

  місцева дія покласти_константу(М: адреса<Машина>, обʼєкт: адреса<Обʼєкт>): позитивне {
    покласти_в_накопичувач<адреса<Обʼєкт>>(М.сховище_констант::адреса, обʼєкт);
    вернути М.сховище_констант.розмір - 1;
  }

  місцева дія покласти_тимчасове_середовище(М: адреса<Машина>): адреса<Середовище> {
    ціль нове_середовище = виділити_середовище(М, М.глобальне_середовище);
    покласти_в_накопичувач<ЕлементІсторіїВиконання>(М.історія::адреса, ЕлементІсторіїВиконання {
      обʼєкт_дії = пусто,
      середовище = нове_середовище
    });
    вернути нове_середовище;
  }

  місцева дія забрати_тимчасове_середовище(М: адреса<Машина>) {
    забрати_з_накопичувача<ЕлементІсторіїВиконання>(М.історія::адреса);
  }

  місцева дія зберегти_обʼєкт(М: адреса<Машина>, обʼєкт: адреса<Обʼєкт>) {
    покласти_в_накопичувач<адреса<Обʼєкт>>(М.НатО::адреса, обʼєкт);
  }

  місцева дія видалити_збережений_обʼєкт(М: адреса<Машина>) {
    забрати_з_накопичувача<адреса<Обʼєкт>>(М.НатО::адреса);
  }

  місцева дія виконати_код(М: адреса<Машина>, середовище: адреса<Середовище>, код: адреса<Код>, обʼєкт_дії: адреса<ОбʼєктДії>, обʼєкт_модуля: адреса<ОбʼєктМодуля>, обʼєкт_я: адреса<Обʼєкт>): обʼєкт_або_стан_падіння {
    ціль нове_середовище = виділити_середовище(М, середовище);
    нове_середовище.обʼєкт_модуля = обʼєкт_модуля;
    нове_середовище.обʼєкт_я = обʼєкт_я;
    покласти_в_накопичувач<ЕлементІсторіїВиконання>(М.історія::адреса, ЕлементІсторіїВиконання {
      обʼєкт_дії = обʼєкт_дії,
      середовище = нове_середовище
    });
    ціль результат = виконати_код_в_середовищі(М, нове_середовище, код);
    забрати_з_накопичувача<ЕлементІсторіїВиконання>(М.історія::адреса);
    вернути результат;
  }

  структура Спроба {
    назва_зловити: адреса<Назва>;
    позиція_вказівки_зловити: позитивне;
    СРНМ: СтанРозмірівНакопичувачівМашини;
  }

  дія обробити_стан_падіння(М: адреса<Машина>, середовище: адреса<Середовище>, код: адреса<Код>, обʼєкт_помилки: адреса<Обʼєкт>, позиція_вказівки_падіння: позитивне, адреса_на_спроби: адреса<Накопичувач<Спроба>>, адреса_на_позицію_вказівки: адреса<позитивне>): логічне {
    якщо адреса_на_спроби.розмір > 0 {
      ціль спроба = забрати_з_накопичувача<Спроба>(адреса_на_спроби);
      якщо спроба.назва_зловити != пусто {
        змінити_в_середовищі(М, середовище, спроба.назва_зловити, обʼєкт_помилки);
      }
      адреса_на_позицію_вказівки::вміст = спроба.позиція_вказівки_зловити;
      відновити_СРНМ(М, спроба.СРНМ);
      вимкнути_стан_падіння(М);
      вернути так;
    }
    якщо М.місцезнаходження_падіння == пусто {
      М.місцезнаходження_падіння = виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки_падіння);
    }
    вернути ні;
  }

  місцева дія виконати_код_в_середовищі(М: адреса<Машина>, середовище: адреса<Середовище>, код: адреса<Код>): обʼєкт_або_стан_падіння {
//    надрукувати_код(код);
    якщо код.накопичувач_вказівок.розмір == 0 {
      вернути пусто;
    }
    ціль СРНМ = зберегти_СРНМ(М);
    ціль спроби = зробити_накопичувач<Спроба>();
    змінна ціль обʼєкт_результату: адреса<Обʼєкт> = пусто;
    змінна ціль позиція_вказівки: позитивне = 0;
    виконання_вказівки:
    утилізувати(М);
    якщо М.утилізатор.кількість_обʼєктів >= М.утилізатор.кількість_обʼєктів_щоб_запустити_утилізацію {
      утилізувати(М);
    }
    якщо М.утилізатор.кількість_середовищ >= М.утилізатор.кількість_середовищ_щоб_запустити_утилізацію {
      утилізувати(М);
    }
    якщо позиція_вказівки >= код.накопичувач_вказівок.розмір {
      стрибнути вихід;
    }
    ціль вказівка = код.накопичувач_вказівок.дані[позиція_вказівки];
    якщо вказівка == ВПокластиПусто {
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, пусто);
    } інакше якщо вказівка == ВПокластиТак {
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_логічного_так як адреса<Обʼєкт>);
    } інакше якщо вказівка == ВПокластиНі {
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_логічного_ні як адреса<Обʼєкт>);
    } інакше якщо вказівка == ВПокластиКонстанту {
      позиція_вказівки += 1;
      ціль позиція_константи = код.накопичувач_вказівок.дані[позиція_вказівки];
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.сховище_констант.дані[позиція_константи]);
    } інакше якщо вказівка == ВСтворитиДію {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      ціль реєстр_параметрів = забрати_з_накопичувача<адреса<Реєстр<адреса<Назва>, Параметр>>>(М.НаРПар::адреса);
      ціль назва = М.ТрН;
      М.ТрН = пусто;
      позиція_вказівки += 1;
      ціль позиція_коду = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль код = М.сховище_кодів.дані[позиція_коду];
      ціль типи_результату = зробити_накопичувач<адреса<ОбʼєктСтруктури>>();
      змінна ціль пт: позитивне = 0;
      поки пт < М.НаОТ.розмір {
        ціль обʼєкт = М.НаОТ.дані[пт];
        якщо обʼєкт == пусто {
          покласти_в_накопичувач<адреса<ОбʼєктСтруктури>>(типи_результату::адреса, пусто);
          пт += 1;
        } інакше якщо обʼєкт.тип == М.обʼєкт_структури_Структура {
          покласти_в_накопичувач<адреса<ОбʼєктСтруктури>>(типи_результату::адреса, обʼєкт як адреса<ОбʼєктСтруктури>);
          пт += 1;
        } інакше {
          ціль обʼєкт_помилки = виділити_обʼєкт_тексту_з_ю8(М, ю8"Тип результату має бути структурою") як адреса<Обʼєкт>;
          увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки));
          якщо обробити_стан_падіння(М, середовище, код, обʼєкт_помилки, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
            обʼєкт_результату = обʼєкт_помилки;
            звільнити_реєстр_параметрів(реєстр_параметрів);
            звільнити_значення_накопичувача<адреса<ОбʼєктСтруктури>>(типи_результату);
            стрибнути вихід;
          }
          звільнити_реєстр_параметрів(реєстр_параметрів);
          звільнити_значення_накопичувача<адреса<ОбʼєктСтруктури>>(типи_результату);
          стрибнути виконання_вказівки;
        }
      }
      М.НаОТ.розмір = 0;
      ціль обʼєкт_дії = виділити_обʼєкт_дії(М, назва, реєстр_параметрів, середовище, код, типи_результату);
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, обʼєкт_дії як адреса<Обʼєкт>);
    } інакше якщо вказівка == ВСтворитиСтруктуру {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      ціль реєстр_параметрів = забрати_з_накопичувача<адреса<Реєстр<адреса<Назва>, Параметр>>>(М.НаРПар::адреса);
      ціль обʼєкт_предка = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      якщо обʼєкт_предка == пусто {
        ціль обʼєкт_помилки = виділити_обʼєкт_тексту_з_ю8(М, ю8"Предок не може бути пусто") як адреса<Обʼєкт>;
        увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки));
        якщо обробити_стан_падіння(М, середовище, код, обʼєкт_помилки, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = обʼєкт_помилки;
          звільнити_реєстр_параметрів(реєстр_параметрів);
          стрибнути вихід;
        }
        звільнити_реєстр_параметрів(реєстр_параметрів);
        стрибнути виконання_вказівки;
      } інакше {
        якщо обʼєкт_предка.тип == М.обʼєкт_структури_Структура {
          ціль назва = М.ТрН;
          М.ТрН = пусто;
          ціль обʼєкт_структури = виділити_обʼєкт_структури(М, назва, обʼєкт_предка як адреса<ОбʼєктСтруктури>);
          змінна ціль пп: позитивне = 0;
          поки пп < реєстр_параметрів.розмір {
            ціль назва_параметра = реєстр_параметрів.елементи[пп].ключ;
            ціль параметр = реєстр_параметрів.елементи[пп].значення;
            ціль елемент_реєстру = отримати_з_реєстру<адреса<Назва>, Параметр>(обʼєкт_структури.параметри, назва_параметра);
            якщо елемент_реєстру == пусто {
              змінити_в_реєстрі<адреса<Назва>, Параметр>(обʼєкт_структури.параметри, назва_параметра, Параметр {
                типи = зробити_копію_накопичувача<адреса<ОбʼєктСтруктури>>(параметр.типи),
                код_значення_за_замовчуванням = параметр.код_значення_за_замовчуванням
              });
            } інакше {
              ціль обʼєкт_помилки = виділити_обʼєкт_тексту_з_ю8(М, ю8"Параметр вже визначено") як адреса<Обʼєкт>;
              увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_цієї_вказівки));
              якщо обробити_стан_падіння(М, середовище, код, обʼєкт_помилки, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
                обʼєкт_результату = обʼєкт_помилки;
                звільнити_реєстр_параметрів(реєстр_параметрів);
                стрибнути вихід;
              }
              звільнити_реєстр_параметрів(реєстр_параметрів);
              стрибнути виконання_вказівки;
            }
            пп += 1;
          }
          звільнити_реєстр_параметрів(реєстр_параметрів);
          покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, обʼєкт_структури як адреса<Обʼєкт>);
        } інакше {
          ціль обʼєкт_помилки = виділити_обʼєкт_тексту_з_ю8(М, ю8"Предок має бути структурою") як адреса<Обʼєкт>;
          увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_цієї_вказівки));
          якщо обробити_стан_падіння(М, середовище, код, обʼєкт_помилки, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
            обʼєкт_результату = обʼєкт_помилки;
            звільнити_реєстр_параметрів(реєстр_параметрів);
            стрибнути вихід;
          }
          звільнити_реєстр_параметрів(реєстр_параметрів);
          стрибнути виконання_вказівки;
        }
      }
    } інакше якщо вказівка == ВСтворитиМодуль {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      ціль назва = М.ТрН;
      М.ТрН = пусто;
      позиція_вказівки += 1;
      ціль позиція_коду = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль код_модуля = М.сховище_кодів.дані[позиція_коду];
      ціль обʼєкт_модуля = виділити_обʼєкт_модуля(М, назва);
      зберегти_обʼєкт(М, обʼєкт_модуля як адреса<Обʼєкт>);
      ціль результат_виконання = виконати_код(М, середовище, код_модуля, пусто, обʼєкт_модуля, обʼєкт_модуля як адреса<Обʼєкт>);
      видалити_збережений_обʼєкт(М);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат_виконання, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат_виконання;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, обʼєкт_модуля як адреса<Обʼєкт>);
    } інакше якщо вказівка == ВСтворитиСписок {
      позиція_вказівки += 1;
      ціль розмір_списку = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль обʼєкт_списку = виділити_обʼєкт_списку(М);
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, обʼєкт_списку як адреса<Обʼєкт>);
    } інакше якщо вказівка == ВПокластиВСписок {
      ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт_списку = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса) як адреса<ОбʼєктСписку>;
      покласти_в_накопичувач<адреса<Обʼєкт>>(обʼєкт_списку.елементи::адреса, значення);
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, обʼєкт_списку як адреса<Обʼєкт>);
    } інакше якщо вказівка == ВСтворитиСловник {
      позиція_вказівки += 1;
      ціль розмір_словника = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль обʼєкт_словника = виділити_обʼєкт_словника(М);
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, обʼєкт_словника як адреса<Обʼєкт>);
    } інакше якщо вказівка == ВПокластиВСловник {
      ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль ключ = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт_словника = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса) як адреса<ОбʼєктСловника>;
      змінити_в_реєстрі2<адреса<Обʼєкт>, адреса<Обʼєкт>>(обʼєкт_словника.елементи::адреса, ключ, значення);
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, обʼєкт_словника як адреса<Обʼєкт>);
    } інакше якщо вказівка == ВПокластиСтруктуруОбʼєкт {
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_структури_обʼєкт як адреса<Обʼєкт>);
    } інакше якщо вказівка == ВПокластиЯ {
      змінна ціль поточне_середовище = середовище;
      змінна ціль обʼєкт_я: адреса<Обʼєкт> = пусто;
      поки поточне_середовище != пусто {
        якщо поточне_середовище.обʼєкт_я != пусто {
          обʼєкт_я = поточне_середовище.обʼєкт_я;
          поточне_середовище = пусто;
        } інакше {
          поточне_середовище = поточне_середовище.батьківське;
        }
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, обʼєкт_я);
    } інакше якщо вказівка == ВЗаписатиМетод {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва = М.БН.дані.дані[позиція_назви];
      ціль обʼєкт_структури = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      якщо обʼєкт_структури.тип == М.обʼєкт_структури_Структура {
        ціль обʼєкт_дії = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        ціль результат = додати_метод_до_обʼєкта_структури(обʼєкт_структури як адреса<ОбʼєктСтруктури>, М, назва, обʼєкт_дії);
        якщо М.стан_падіння == позитивне(так) {
          якщо обробити_стан_падіння(М, середовище, код, результат, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
            обʼєкт_результату = результат;
            стрибнути вихід;
          }
          позиція_вказівки -= 1;
        } інакше {
          покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, обʼєкт_структури);
        }
      } інакше {
        ціль обʼєкт_помилки = виділити_обʼєкт_тексту_з_ю8(М, ю8"Обʼєкт має бути структурою") як адреса<Обʼєкт>;
        увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_цієї_вказівки));
        якщо обробити_стан_падіння(М, середовище, код, обʼєкт_помилки, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = обʼєкт_помилки;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
    } інакше якщо вказівка == ВВизначити {
      ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва = М.БН.дані.дані[позиція_назви];
      змінити_в_середовищі(М, середовище, назва, значення);
    } інакше якщо вказівка == ВЗвернутись {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва = М.БН.дані.дані[позиція_назви];
      ціль елемент_середовища = знайти_елемент_в_середовищі(середовище, назва);
      якщо елемент_середовища == пусто {
        ціль обʼєкт_помилки = виділити_обʼєкт_тексту_з_ю8(М, ю8"Субʼєкт не визначено") як адреса<Обʼєкт>;
        увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_цієї_вказівки));
        якщо обробити_стан_падіння(М, середовище, код, обʼєкт_помилки, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = обʼєкт_помилки;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      } інакше {
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, елемент_середовища.значення);
      }
    } інакше якщо вказівка == ВВиконати {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      позиція_вказівки += 1;
      ціль кількість_аргументів = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль аргументи = зробити_накопичувач<адреса<Обʼєкт>>();
      змінна ціль па: позитивне = 0;
      поки па < кількість_аргументів {
        ціль аргумент = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        покласти_в_накопичувач<адреса<Обʼєкт>>(аргументи::адреса, аргумент);
        па += 1;
      }
      обернути_накопичувач<адреса<Обʼєкт>>(аргументи::адреса);
      ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат_виконання = обʼєкт_виконати(обʼєкт, М, пусто, аргументи::адреса, пусто);
      звільнити_значення_накопичувача<адреса<Обʼєкт>>(аргументи);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат_виконання, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат_виконання;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат_виконання);
    } інакше якщо вказівка == ВВиконатиЗНазвами {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      ціль іменовані_аргументи = забрати_з_накопичувача<адреса<Реєстр<адреса<Назва>, адреса<Обʼєкт>>>>(М.НаРАрг::адреса);
      позиція_вказівки += 1;
      ціль кількість_аргументів = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль аргументи = зробити_накопичувач<адреса<Обʼєкт>>();
      змінна ціль па: позитивне = 0;
      поки па < кількість_аргументів {
        ціль аргумент = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        покласти_в_накопичувач<адреса<Обʼєкт>>(аргументи::адреса, аргумент);
        па += 1;
      }
      обернути_накопичувач<адреса<Обʼєкт>>(аргументи::адреса);
      ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат_виконання = обʼєкт_виконати(обʼєкт, М, пусто, аргументи::адреса, іменовані_аргументи);
      звільнити_значення_накопичувача<адреса<Обʼєкт>>(аргументи);
      звільнити_реєстр<адреса<Назва>, адреса<Обʼєкт>>(іменовані_аргументи);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат_виконання, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат_виконання;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат_виконання);
    } інакше якщо вказівка == ВОтриматиВластивість {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва = М.БН.дані.дані[позиція_назви];
      ціль результат_отримання_властивості = обʼєкт_отримати_властивість(обʼєкт, М, назва);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат_отримання_властивості, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат_отримання_властивості;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат_отримання_властивості);
    } інакше якщо вказівка == ВЗмінитиВластивість {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва = М.БН.дані.дані[позиція_назви];
      ціль результат_зміни_властивості = обʼєкт_змінити_властивість(обʼєкт, М, назва, значення);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат_зміни_властивості, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат_зміни_властивості;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
    } інакше якщо вказівка == ВВиконатиВластивість {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва = М.БН.дані.дані[позиція_назви];
      позиція_вказівки += 1;
      ціль кількість_аргументів = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль аргументи = зробити_накопичувач<адреса<Обʼєкт>>();
      змінна ціль па: позитивне = 0;
      поки па < кількість_аргументів {
        ціль аргумент = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        покласти_в_накопичувач<адреса<Обʼєкт>>(аргументи::адреса, аргумент);
        па += 1;
      }
      обернути_накопичувач<адреса<Обʼєкт>>(аргументи::адреса);
      ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат_виконання = обʼєкт_виконати_властивість(обʼєкт, М, назва, аргументи::адреса, пусто);
      звільнити_значення_накопичувача<адреса<Обʼєкт>>(аргументи);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат_виконання, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат_виконання;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат_виконання);
    } інакше якщо вказівка == ВВиконатиВластивістьЗНазвами {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва = М.БН.дані.дані[позиція_назви];
      ціль іменовані_аргументи = забрати_з_накопичувача<адреса<Реєстр<адреса<Назва>, адреса<Обʼєкт>>>>(М.НаРАрг::адреса);
      позиція_вказівки += 1;
      ціль кількість_аргументів = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль аргументи = зробити_накопичувач<адреса<Обʼєкт>>();
      змінна ціль па: позитивне = 0;
      поки па < кількість_аргументів {
        ціль аргумент = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        покласти_в_накопичувач<адреса<Обʼєкт>>(аргументи::адреса, аргумент);
        па += 1;
      }
      обернути_накопичувач<адреса<Обʼєкт>>(аргументи::адреса);
      ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат_виконання = обʼєкт_виконати_властивість(обʼєкт, М, назва, аргументи::адреса, іменовані_аргументи);
      звільнити_значення_накопичувача<адреса<Обʼєкт>>(аргументи);
      звільнити_реєстр<адреса<Назва>, адреса<Обʼєкт>>(іменовані_аргументи);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат_виконання, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат_виконання;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат_виконання);
    } інакше якщо вказівка == ВОтриматиЕлемент {
      ціль ключ = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат_отримання_елемента = обʼєкт_отримати_елемент(обʼєкт, М, ключ);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат_отримання_елемента, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат_отримання_елемента;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат_отримання_елемента);
    } інакше якщо вказівка == ВЗмінитиЕлемент {
      ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль ключ = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат_зміни_елемента = обʼєкт_змінити_елемент(обʼєкт, М, ключ, значення);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат_зміни_елемента, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат_зміни_елемента;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
    } інакше якщо вказівка == ВОтриматиПеребір {
      ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат_отримання_перебору = обʼєкт_отримати_перебір(обʼєкт, М);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат_отримання_перебору, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат_отримання_перебору;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат_отримання_перебору);
    } інакше якщо вказівка == ВВизначитиЗзовні {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва = М.БН.дані.дані[позиція_назви];
      якщо середовище.батьківське == пусто {
        ціль обʼєкт_помилки = виділити_обʼєкт_тексту_з_ю8(М, ю8"Середовище є кореневим") як адреса<Обʼєкт>;
        увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_цієї_вказівки));
        якщо обробити_стан_падіння(М, середовище, код, обʼєкт_помилки, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = обʼєкт_помилки;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      } інакше {
        змінити_в_середовищі(М, середовище.батьківське, назва, значення);
      }
    } інакше якщо вказівка == ВВиконатиЗПредка {
      ПОМЕРТИ(ю8"Виконання з предка не втілено!");
    } інакше якщо вказівка == ВВиконатиЗПредкаЗНазвами {
      ПОМЕРТИ(ю8"Виконання з предка не втілено!");
    } інакше якщо вказівка == ВВидалити {
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва = М.БН.дані.дані[позиція_назви];
      якщо видалити_з_середовища(М, середовище, назва) {
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_логічного_так як адреса<Обʼєкт>);
      } інакше {
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_логічного_ні як адреса<Обʼєкт>);
      }
    } інакше якщо вказівка == ВВидалитиВластивість {
      ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва = М.БН.дані.дані[позиція_назви];
      ціль результат_видалення_властивості = обʼєкт_видалити_властивість(обʼєкт, М, назва);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат_видалення_властивості, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат_видалення_властивості;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат_видалення_властивості);
    } інакше якщо вказівка == ВВидалитиЕлемент {
      ціль ключ = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат_видалення_елемента = обʼєкт_видалити_елемент(обʼєкт, М, ключ);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат_видалення_елемента, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат_видалення_елемента;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат_видалення_елемента);
    } інакше якщо вказівка == ВДодати {
      ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_додати(обʼєкт_1, М, обʼєкт_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
    } інакше якщо вказівка == ВВідняти {
      ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_відняти(обʼєкт_1, М, обʼєкт_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
    } інакше якщо вказівка == ВПомножити {
      ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_помножити(обʼєкт_1, М, обʼєкт_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
    } інакше якщо вказівка == ВПоділити {
      ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_поділити(обʼєкт_1, М, обʼєкт_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
    } інакше якщо вказівка == ВОтриматиОстачуДілення {
      ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_отримати_остачу_ділення(обʼєкт_1, М, обʼєкт_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
    } інакше якщо вказівка == ВОтриматиНеповнуЧасткуДілення {
      ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_отримати_неповну_частку_ділення(обʼєкт_1, М, обʼєкт_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
    } інакше якщо вказівка == ВПіднестиДоСтепеня {
      ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_піднести_до_степеня(обʼєкт_1, М, обʼєкт_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
    } інакше якщо вказівка == ВЗсунутиВліво {
      ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_зсунути_вліво(обʼєкт_1, М, обʼєкт_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
    } інакше якщо вказівка == ВЗсунутиВправо {
      ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_зсунути_вправо(обʼєкт_1, М, обʼєкт_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
    } інакше якщо вказівка == ВЗсунутиВправоЗіЗаповненням {
      ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_зсунути_вправо_зі_заповненням(обʼєкт_1, М, обʼєкт_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
    } інакше якщо вказівка == ВДвійковеІ {
      ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_двійкове_і(обʼєкт_1, М, обʼєкт_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
    } інакше якщо вказівка == ВДвійковеАБО {
      ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_двійкове_або(обʼєкт_1, М, обʼєкт_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
    } інакше якщо вказівка == ВДвійковеВиключнеАБО {
      ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_двійкове_виключне_або(обʼєкт_1, М, обʼєкт_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
    } інакше якщо вказівка == ВДвійковеНЕ {
      ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_двійкове_не(обʼєкт, М);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
    } інакше якщо вказівка == ВМенше {
      ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_менше(обʼєкт_1, М, обʼєкт_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
    } інакше якщо вказівка == ВБільше {
      ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_більше(обʼєкт_1, М, обʼєкт_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
    } інакше якщо вказівка == ВНеБільше {
      ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_більше(обʼєкт_1, М, обʼєкт_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      якщо перевірити_чи_обʼєкт_виражається_логічним_так(результат, М) {
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_логічного_ні як адреса<Обʼєкт>);
      } інакше {
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_логічного_так як адреса<Обʼєкт>);
      }
    } інакше якщо вказівка == ВНеМенше {
      ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_менше(обʼєкт_1, М, обʼєкт_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      якщо перевірити_чи_обʼєкт_виражається_логічним_так(результат, М) {
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_логічного_ні як адреса<Обʼєкт>);
      } інакше {
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_логічного_так як адреса<Обʼєкт>);
      }
    } інакше якщо вказівка == ВРівно {
      ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_рівно(обʼєкт_1, М, обʼєкт_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
    } інакше якщо вказівка == ВНеРівно {
      ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_рівно(обʼєкт_1, М, обʼєкт_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      якщо перевірити_чи_обʼєкт_виражається_логічним_так(результат, М) {
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_логічного_ні як адреса<Обʼєкт>);
      } інакше {
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_логічного_так як адреса<Обʼєкт>);
      }
    } інакше якщо вказівка == ВМістить {
      ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_містить(обʼєкт_1, М, обʼєкт_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
    } інакше якщо вказівка == ВНеМістить {
      ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_містить(обʼєкт_1, М, обʼєкт_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      якщо перевірити_чи_обʼєкт_виражається_логічним_так(результат, М) {
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_логічного_ні як адреса<Обʼєкт>);
      } інакше {
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_логічного_так як адреса<Обʼєкт>);
      }
    } інакше якщо вказівка == ВЄ {
      ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_є(обʼєкт_1, М, обʼєкт_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
    } інакше якщо вказівка == ВНеЄ {
      ціль обʼєкт_2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт_1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_є(обʼєкт_1, М, обʼєкт_2);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      якщо перевірити_чи_обʼєкт_виражається_логічним_так(результат, М) {
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_логічного_ні як адреса<Обʼєкт>);
      } інакше {
        покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, М.обʼєкт_логічного_так як адреса<Обʼєкт>);
      }
    } інакше якщо вказівка == ВВідʼємне {
      ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_відʼємне(обʼєкт, М);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
    } інакше якщо вказівка == ВЧислове {
      ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_числове(обʼєкт, М);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
    } інакше якщо вказівка == ВЗаперечити {
      ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_заперечити(обʼєкт, М);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
    } інакше якщо вказівка == ВЗбільшити {
      ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_збільшити(обʼєкт, М);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
    } інакше якщо вказівка == ВЗбільшитиПопереднє {
      ціль обʼєкт2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_збільшити(обʼєкт1, М);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, обʼєкт2);
    } інакше якщо вказівка == ВЗбільшити {
      ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль результат = обʼєкт_зменшити(обʼєкт, М);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат);
    } інакше якщо вказівка == ВПочатиСпробу {
      позиція_вказівки += 1;
      ціль позиція_вказівки_зловити = код.накопичувач_вказівок.дані[позиція_вказівки];
      покласти_в_накопичувач<Спроба>(спроби::адреса, Спроба {
        назва_зловити = пусто,
        позиція_вказівки_зловити = позиція_вказівки_зловити,
        СРНМ = зберегти_СРНМ(М)
      });
    } інакше якщо вказівка == ВПочатиСпробуЗНазвою {
      позиція_вказівки += 1;
      ціль позиція_вказівки_зловити = код.накопичувач_вказівок.дані[позиція_вказівки];
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва_зловити = М.БН.дані.дані[позиція_назви];
      покласти_в_накопичувач<Спроба>(спроби::адреса, Спроба {
        назва_зловити = назва_зловити,
        позиція_вказівки_зловити = позиція_вказівки_зловити,
        СРНМ = зберегти_СРНМ(М)
      });
    } інакше якщо вказівка == ВПеребратиДалі {
      ціль обʼєкт_перебору = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, обʼєкт_перебору);
      ціль результат_виконання = обʼєкт_виконати_властивість(обʼєкт_перебору, М, М.БН.С.далі, пусто, пусто);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, результат_виконання, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = результат_виконання;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, результат_виконання);
    } інакше якщо вказівка == ВВпасти {
      ціль обʼєкт_помилки = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки));
      якщо обробити_стан_падіння(М, середовище, код, обʼєкт_помилки, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
        обʼєкт_результату = обʼєкт_помилки;
        стрибнути вихід;
      }
      стрибнути виконання_вказівки;
    } інакше якщо вказівка == ВЗакінчитиСпробу {
      ціль позиція_вказівки_виходу = код.накопичувач_вказівок.дані[позиція_вказівки + 1];
      забрати_з_накопичувача<Спроба>(спроби::адреса);
      позиція_вказівки = позиція_вказівки_виходу;
      стрибнути виконання_вказівки;
    } інакше якщо вказівка == ВВзяти {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      позиція_вказівки += 1;
      ціль позиція_назви_типу = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва_типу = М.БН.дані.дані[позиція_назви_типу];
      ціль накопичувач_назв = зробити_накопичувач<адреса<Назва>>();
      змінна ціль пнн: позитивне = 0;
      поки пнн < М.НаН.розмір {
        покласти_в_накопичувач<адреса<Назва>>(накопичувач_назв::адреса, М.НаН.дані[пнн]);
        пнн += 1;
      }
      М.НаН.розмір = 0;
      змінна ціль обʼєкт_модуля: адреса<Обʼєкт> = пусто;
      якщо назва_типу == М.БН.С.модуль {
        обʼєкт_модуля = взяти_модуль(М, середовище, пусто, накопичувач_назв);
      } інакше якщо назва_типу == М.БН.С.біб {
        обʼєкт_модуля = взяти_біб(М, накопичувач_назв);
      } інакше якщо назва_типу == М.БН.С.пак {
        обʼєкт_модуля = взяти_модуль(М, середовище, накопичувач_назв.дані[0], накопичувач_назв);
      } інакше {
        звільнити_значення_накопичувача<адреса<Назва>>(накопичувач_назв);
        ціль обʼєкт_помилки = виділити_обʼєкт_тексту_з_ю8(М, ю8"Невідомий репозиторій взяття") як адреса<Обʼєкт>;
        увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки));
        якщо обробити_стан_падіння(М, середовище, код, обʼєкт_помилки, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = обʼєкт_помилки;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      звільнити_значення_накопичувача<адреса<Назва>>(накопичувач_назв);
      якщо М.стан_падіння == позитивне(так) {
        якщо обробити_стан_падіння(М, середовище, код, обʼєкт_модуля, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = обʼєкт_модуля;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      }
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, обʼєкт_модуля);
    } інакше якщо вказівка == ВДати {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      позиція_вказівки += 1;
      ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва = М.БН.дані.дані[позиція_назви];
      якщо середовище.обʼєкт_модуля == пусто {
        ціль обʼєкт_помилки = виділити_обʼєкт_тексту_з_ю8(М, ю8"Вказівка \"дати\" працює лише в середовищі модуля") як адреса<Обʼєкт>;
        увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки));
        якщо обробити_стан_падіння(М, середовище, код, обʼєкт_помилки, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
          обʼєкт_результату = обʼєкт_помилки;
          стрибнути вихід;
        }
        стрибнути виконання_вказівки;
      } інакше {
        змінити_в_реєстрі<адреса<Назва>, адреса<Обʼєкт>>(середовище.обʼєкт_модуля.властивості::адреса, назва, обʼєкт);
      }
    } інакше якщо вказівка == ВПокластиРеєстрАргументівЗНазвами {
      ціль іменовані_аргументи = виділити_реєстр<адреса<Назва>, адреса<Обʼєкт>>(перевірити_чи_назви_рівні);
      покласти_в_накопичувач<адреса<Реєстр<адреса<Назва>, адреса<Обʼєкт>>>>(М.НаРАрг::адреса, іменовані_аргументи);
    } інакше якщо вказівка == ВЗареєструватиАргументЗНазвою {
      ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва = М.БН.дані.дані[позиція_назви];
      змінити_в_реєстрі<адреса<Назва>, адреса<Обʼєкт>>(М.НаРАрг.дані[М.НаРАрг.розмір - 1], назва, значення);
    } інакше якщо вказівка == ВПокластиРеєстрПараметрів {
      ціль реєстр_параметрів = виділити_реєстр<адреса<Назва>, Параметр>(перевірити_чи_назви_рівні);
      покласти_в_накопичувач<адреса<Реєстр<адреса<Назва>, Параметр>>>(М.НаРПар::адреса, реєстр_параметрів);
    } інакше якщо вказівка == ВЗареєструватиПараметр {
      ціль позиція_цієї_вказівки = позиція_вказівки;
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль назва = М.БН.дані.дані[позиція_назви];
      позиція_вказівки += 1;
      ціль кількість_типів = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль типи = зробити_накопичувач<адреса<ОбʼєктСтруктури>>();
      змінна ціль пт: позитивне = 0;
      поки пт < кількість_типів {
        ціль тип = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
        якщо тип == пусто {
          покласти_в_накопичувач<адреса<ОбʼєктСтруктури>>(типи::адреса, тип як адреса<ОбʼєктСтруктури>);
          пт = пт + 1;
        } інакше якщо тип.тип == М.обʼєкт_структури_Структура {
          покласти_в_накопичувач<адреса<ОбʼєктСтруктури>>(типи::адреса, тип як адреса<ОбʼєктСтруктури>);
          пт = пт + 1;
        } інакше {
          ціль обʼєкт_помилки = виділити_обʼєкт_тексту_з_ю8(М, ю8"Тип параметра має бути структурою") як адреса<Обʼєкт>;
          увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_цієї_вказівки));
          якщо обробити_стан_падіння(М, середовище, код, обʼєкт_помилки, позиція_цієї_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
            обʼєкт_результату = обʼєкт_помилки;
            звільнити_значення_накопичувача<адреса<ОбʼєктСтруктури>>(типи);
            стрибнути вихід;
          }
          звільнити_значення_накопичувача<адреса<ОбʼєктСтруктури>>(типи);
          стрибнути виконання_вказівки;
        }
      }
      обернути_накопичувач<адреса<ОбʼєктСтруктури>>(типи::адреса);
      ціль код_значення_за_замовчуванням = М.ТрК;
      М.ТрК = пусто;
      ціль параметр = Параметр {
        типи = типи,
        код_значення_за_замовчуванням = код_значення_за_замовчуванням,
      };
      змінити_в_реєстрі<адреса<Назва>, Параметр>(М.НаРПар.дані[М.НаРПар.розмір - 1], назва, параметр);
    } інакше якщо вказівка == ВТриматиКод {
      позиція_вказівки += 1;
      ціль позиція_коду = код.накопичувач_вказівок.дані[позиція_вказівки];
      ціль код = М.сховище_кодів.дані[позиція_коду];
      М.ТрК = код;
    } інакше якщо вказівка == ВНакопичитиНазву {
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      покласти_в_накопичувач<адреса<Назва>>(М.НаН::адреса, М.БН.дані.дані[позиція_назви]);
    } інакше якщо вказівка == ВТриматиНазву {
      позиція_вказівки += 1;
      ціль позиція_назви = код.накопичувач_вказівок.дані[позиція_вказівки];
      М.ТрН = М.БН.дані.дані[позиція_назви];
    } інакше якщо вказівка == ВСтрибнути {
      ціль позиція_вказівки_стрибка = код.накопичувач_вказівок.дані[позиція_вказівки + 1];
      позиція_вказівки = позиція_вказівки_стрибка;
      стрибнути виконання_вказівки;
    } інакше якщо вказівка == ВСтрибнутиЯкщоНі {
      ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      позиція_вказівки += 1;
      ціль позиція_вказівки_стрибка = код.накопичувач_вказівок.дані[позиція_вказівки];
      якщо перевірити_чи_обʼєкт_виражається_логічним_так(значення, М) == ні {
        позиція_вказівки = позиція_вказівки_стрибка;
        стрибнути виконання_вказівки;
      }
    } інакше якщо вказівка == ВСтрибнутиЯкщоНіЗалишивши {
      ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, значення);
      позиція_вказівки += 1;
      ціль позиція_вказівки_стрибка = код.накопичувач_вказівок.дані[позиція_вказівки];
      якщо перевірити_чи_обʼєкт_виражається_логічним_так(значення, М) == ні {
        позиція_вказівки = позиція_вказівки_стрибка;
        стрибнути виконання_вказівки;
      }
    } інакше якщо вказівка == ВСтрибнутиЯкщоТак {
      ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      позиція_вказівки += 1;
      ціль позиція_вказівки_стрибка = код.накопичувач_вказівок.дані[позиція_вказівки];
      якщо перевірити_чи_обʼєкт_виражається_логічним_так(значення, М) {
        позиція_вказівки = позиція_вказівки_стрибка;
        стрибнути виконання_вказівки;
      }
    } інакше якщо вказівка == ВСтрибнутиЯкщоТакЗалишивши {
      ціль значення = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, значення);
      позиція_вказівки += 1;
      ціль позиція_вказівки_стрибка = код.накопичувач_вказівок.дані[позиція_вказівки];
      якщо перевірити_чи_обʼєкт_виражається_логічним_так(значення, М) {
        позиція_вказівки = позиція_вказівки_стрибка;
        стрибнути виконання_вказівки;
      }
    } інакше якщо вказівка == ВДублювати {
      ціль обʼєкт = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, обʼєкт);
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, обʼєкт);
    } інакше якщо вказівка == ВДублюватиПопереднє {
      ціль обʼєкт2 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      ціль обʼєкт1 = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, обʼєкт1);
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, обʼєкт2);
      покласти_в_накопичувач<адреса<Обʼєкт>>(М.НаО::адреса, обʼєкт1);
    } інакше якщо вказівка == ВЗабрати {
      забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
    } інакше якщо вказівка == ВВернути {
      обʼєкт_результату = забрати_з_накопичувача<адреса<Обʼєкт>>(М.НаО::адреса);
      стрибнути вихід;
    } інакше {
      надрукувати_п64(п64(вказівка));
      ціль обʼєкт_помилки = виділити_обʼєкт_тексту_з_ю8(М, ю8"Виявлено невідому вказівку") як адреса<Обʼєкт>;
      увімкнути_стан_падіння(М, виділити_місцезнаходження_падіння_з_вказівки_або_пусто(М, код, позиція_вказівки));
      якщо обробити_стан_падіння(М, середовище, код, обʼєкт_помилки, позиція_вказівки, спроби::адреса, позиція_вказівки::адреса) == ні {
        обʼєкт_результату = обʼєкт_помилки;
        стрибнути вихід;
      }
      стрибнути виконання_вказівки;
    }
    позиція_вказівки += 1;
    стрибнути виконання_вказівки;
    вихід:
    звільнити_значення_накопичувача<Спроба>(спроби);
    відновити_СРНМ(М, СРНМ); // взагалі це по доброму треба було би викинути,
                             // але для цього ще треба порефакторити як працює сама машина
    вернути обʼєкт_результату;
  }

  дія отримати_назву_паку_з_середовища(М: адреса<Машина>, середовище: адреса<Середовище>): адреса<Назва> {
    змінна ціль поточне_середовище = середовище;
    поки поточне_середовище != пусто {
      якщо поточне_середовище.обʼєкт_модуля != пусто {
        якщо поточне_середовище.обʼєкт_модуля.назва_паку != пусто {
          вернути поточне_середовище.обʼєкт_модуля.назва_паку;
        }
      }
      поточне_середовище = поточне_середовище.батьківське;
    }
    вернути пусто;
  }

  місцева дія взяти_модуль(М: адреса<Машина>, середовище: адреса<Середовище>, назва_паку: адреса<Назва>, шлях: Накопичувач<адреса<Назва>>): обʼєкт_або_стан_падіння {
    якщо назва_паку == пусто {
      назва_паку = отримати_назву_паку_з_середовища(М, середовище);
    }
    якщо М.обробник_отримання_шляху_до_модуля == пусто {
      вернути виділити_обʼєкт_тексту_з_ю8(М, ю8"Обробник отримання шляху до модуля не втілено в Машині") як адреса<Обʼєкт>;
    }
    ціль шлях_до_модуля: памʼять<п8> = пусто;
    якщо М.обробник_отримання_шляху_до_модуля(М, назва_паку, шлях, шлях_до_модуля::адреса) == ні {
      увімкнути_стан_падіння(М, пусто);
      вернути виділити_обʼєкт_тексту_з_ю8(М, ю8"Не вдалося отримати шлях до модуля") як адреса<Обʼєкт>;
    }
    ціль елемент_взятого_модуля = отримати_з_реєстру<Ю8, адреса<ОбʼєктМодуля>>(М.взяті_модулі::адреса, шлях_до_модуля);
    якщо елемент_взятого_модуля != пусто {
      вернути елемент_взятого_модуля.значення як адреса<Обʼєкт>;
    }
    якщо М.обробник_взяття_модуля == пусто {
      вернути виділити_обʼєкт_тексту_з_ю8(М, ю8"Обробник взяття модуля не втілено в Машині") як адреса<Обʼєкт>;
    }
    ціль обʼєкт_модуля = виділити_обʼєкт_модуля(М, шлях.дані[шлях.розмір - 1]);
    якщо назва_паку != пусто {
      обʼєкт_модуля.назва_паку = назва_паку;
    }
    змінити_в_реєстрі<Ю8, адреса<ОбʼєктМодуля>>(М.взяті_модулі::адреса, шлях_до_модуля, обʼєкт_модуля);
    ціль результат_обробника_взяття_модуля = М.обробник_взяття_модуля(М, обʼєкт_модуля, шлях_до_модуля);
    якщо М.стан_падіння == позитивне(так) {
      вернути результат_обробника_взяття_модуля;
    }
    вернути обʼєкт_модуля як адреса<Обʼєкт>;
  }

  місцева дія взяти_модуль_за_шляхом(М: адреса<Машина>, середовище: адреса<Середовище>, назва_модуля: адреса<Назва>, шлях_до_модуля: Ю8): обʼєкт_або_стан_падіння {
    ціль елемент_взятого_модуля = отримати_з_реєстру<Ю8, адреса<ОбʼєктМодуля>>(М.взяті_модулі::адреса, шлях_до_модуля);
    якщо елемент_взятого_модуля != пусто {
      вернути елемент_взятого_модуля.значення як адреса<Обʼєкт>;
    }
    якщо М.обробник_взяття_модуля == пусто {
      вернути виділити_обʼєкт_тексту_з_ю8(М, ю8"Обробник взяття модуля не втілено в Машині") як адреса<Обʼєкт>;
    }
    ціль обʼєкт_модуля = виділити_обʼєкт_модуля(М, назва_модуля);
    змінити_в_реєстрі<Ю8, адреса<ОбʼєктМодуля>>(М.взяті_модулі::адреса, шлях_до_модуля, обʼєкт_модуля);
    ціль результат_обробника_взяття_модуля = М.обробник_взяття_модуля(М, обʼєкт_модуля, шлях_до_модуля);
    якщо М.стан_падіння == позитивне(так) {
      вернути результат_обробника_взяття_модуля;
    }
    вернути обʼєкт_модуля як адреса<Обʼєкт>;
  }

  місцева дія взяти_біб(М: адреса<Машина>, шлях: Накопичувач<адреса<Назва>>): обʼєкт_або_стан_падіння {
    ціль накопичувач_ю8_шляху_до_модуля = зробити_накопичувач_ю8();
    покласти_в_накопичувач_ю8(накопичувач_ю8_шляху_до_модуля::адреса, ю8"біб://");
    змінна ціль п: позитивне = 0;
    поки п < шлях.розмір {
      ціль назва = шлях.дані[п];
      ціль ю8_назви: Ю8 = пусто;
      якщо виділити_ю8_з_назви(М, назва, ю8_назви::адреса) == ні {
        увімкнути_стан_падіння(М, пусто);
        вернути виділити_обʼєкт_тексту_з_ю8(М, ю8"Не вдалося виділити Ю8 з назви") як адреса<Обʼєкт>;
      }
      покласти_в_накопичувач_ю8(накопичувач_ю8_шляху_до_модуля::адреса, ю8"/");
      покласти_в_накопичувач_ю8(накопичувач_ю8_шляху_до_модуля::адреса, ю8_назви);
      звільнити(ю8_назви як адреса);
      п += 1;
    }
    покласти_в_накопичувач_ю8(накопичувач_ю8_шляху_до_модуля::адреса, ю8".м");
    ціль шлях_до_модуля = виділити_ю8_з_накопичувача_ю8(накопичувач_ю8_шляху_до_модуля::адреса);
    звільнити_значення_накопичувача_ю8(накопичувач_ю8_шляху_до_модуля);
    ціль елемент_взятого_модуля = отримати_з_реєстру<Ю8, адреса<ОбʼєктМодуля>>(М.взяті_модулі::адреса, шлях_до_модуля);
    якщо елемент_взятого_модуля != пусто {
      вернути елемент_взятого_модуля.значення як адреса<Обʼєкт>;
    }
    якщо М.обробник_взяття_біб == пусто {
      вернути виділити_обʼєкт_тексту_з_ю8(М, ю8"Обробник взяття біб не втілено в Машині") як адреса<Обʼєкт>;
    }
    ціль обʼєкт_модуля = виділити_обʼєкт_модуля(М, шлях.дані[шлях.розмір - 1]);
    змінити_в_реєстрі<Ю8, адреса<ОбʼєктМодуля>>(М.взяті_модулі::адреса, шлях_до_модуля, обʼєкт_модуля);
    ціль результат_обробника_взяття_модуля = М.обробник_взяття_біб(М, обʼєкт_модуля, шлях);
    якщо М.стан_падіння == позитивне(так) {
      вернути результат_обробника_взяття_модуля;
    }
    вернути обʼєкт_модуля як адреса<Обʼєкт>;
  }

  місцева дія зберегти_СРНМ(М: адреса<Машина>): СтанРозмірівНакопичувачівМашини {
    вернути СтанРозмірівНакопичувачівМашини {
      розмір_історії = М.історія.розмір,
      розмір_НатО = М.НатО.розмір,
      розмір_НаО = М.НаО.розмір,
      розмір_НаРАрг = М.НаРАрг.розмір,
      розмір_НаРПар = М.НаРПар.розмір,
      розмір_НаН = М.НаН.розмір,
      значення_ТрК = М.ТрК,
      значення_ТрН = М.ТрН,
      розмір_НаОТ = М.НаОТ.розмір
    };
  }

  місцева дія відновити_СРНМ(М: адреса<Машина>, СРНМ: СтанРозмірівНакопичувачівМашини) {
    // тут можуть потенційно бути проблеми з невірними розмірами
    М.історія.розмір = СРНМ.розмір_історії;
    М.НатО.розмір = СРНМ.розмір_НатО;
    М.НаО.розмір = СРНМ.розмір_НаО;
    поки М.НаРАрг.розмір != СРНМ.розмір_НаРАрг {
      ціль реєстр_аргументів = забрати_з_накопичувача<адреса<Реєстр<адреса<Назва>, адреса<Обʼєкт>>>>(М.НаРАрг::адреса);
      звільнити_реєстр<адреса<Назва>, адреса<Обʼєкт>>(реєстр_аргументів);
    }
    поки М.НаРПар.розмір != СРНМ.розмір_НаРПар {
      ціль реєстр_параметрів = забрати_з_накопичувача<адреса<Реєстр<адреса<Назва>, Параметр>>>(М.НаРПар::адреса);
      звільнити_реєстр_параметрів(реєстр_параметрів);
    }
    М.НаН.розмір = СРНМ.розмір_НаН;
    М.ТрК = СРНМ.значення_ТрК;
    М.ТрН = СРНМ.значення_ТрН;
    М.НаОТ.розмір = СРНМ.розмір_НаОТ;
  }
}