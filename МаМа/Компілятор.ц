взяти визначення МаМа;

секція МаМа {
  місцева дія виділити_помилку_компіляції(місцезнаходження: адреса<Місцезнаходження>, повідомлення: Ю8): адреса<ПомилкаКомпіляції> {
    ціль помилка_компіляції = виділити<ПомилкаКомпіляції>();
    помилка_компіляції.місцезнаходження = місцезнаходження;
    помилка_компіляції.повідомлення = виділити_копію_ю8(повідомлення);
    вернути помилка_компіляції;
  }

  місцева дія виділити_контекст_компіляції(): адреса<КонтекстКомпіляції> {
    ціль контекст_компіляції = виділити<КонтекстКомпіляції>();
    контекст_компіляції.код_дії = пусто;
    вернути контекст_компіляції;
  }

  місцева дія скомпілювати_елемент_значення(М: адреса<Машина>, контекст: адреса<КонтекстКомпіляції>, код: адреса<Код>, елемент: адреса<АСДЗначення>): адреса<ПомилкаКомпіляції> {
    якщо елемент.вид == АСДВидЗвернутись {
      ціль дані = елемент.дані як адреса<АСДДаніЗвернутись>;
      ціль назва = знайти_або_виділити_й_додати_назву(М.БН::адреса, дані.ідентифікатор.значення);
      ціль позиція_назви = додати_назву_до_коду(код, назва);
      додати_вказівку_до_коду_з_аргументом_п32(код, елемент.місцезнаходження.рядок як п32, елемент.місцезнаходження.стовпець як п32, ВЗвернутись, позиція_назви);
      вернути пусто;
    } інакше якщо елемент.вид == АСДВидОтримати {
      ціль дані = елемент.дані як адреса<АСДДаніОтримати>;
      ціль помилка_компіляції_обʼєкта = скомпілювати_елемент_значення(М, контекст, код, дані.обʼєкт);
      якщо помилка_компіляції_обʼєкта != пусто {
        вернути помилка_компіляції_обʼєкта;
      }
      ціль назва = знайти_або_виділити_й_додати_назву(М.БН::адреса, дані.ідентифікатор.значення);
      ціль позиція_назви = додати_назву_до_коду(код, назва);
      додати_вказівку_до_коду_з_аргументом_п32(код, елемент.місцезнаходження.рядок як п32, елемент.місцезнаходження.стовпець як п32, ВОтримати, позиція_назви);
      вернути пусто;
    } інакше якщо елемент.вид == АСДВидОтриматиЗаПозицією {
      //
    } інакше якщо елемент.вид == АСДВидВиконати {
      ціль дані = елемент.дані як адреса<АСДДаніВиконати>;
      змінна ціль назва_прохання: адреса<Назва> = пусто;
      якщо дані.обʼєкт.вид == АСДВидОтримати {
        ціль дані_отримання = дані.обʼєкт.дані як адреса<АСДДаніОтримати>;
        ціль помилка_компіляції_обʼєкта = скомпілювати_елемент_значення(М, контекст, код, дані_отримання.обʼєкт);
        якщо помилка_компіляції_обʼєкта != пусто {
          вернути помилка_компіляції_обʼєкта;
        }
        назва_прохання = знайти_або_виділити_й_додати_назву(М.БН::адреса, дані_отримання.ідентифікатор.значення);
      } інакше {
        ціль помилка_компіляції_обʼєкта = скомпілювати_елемент_значення(М, контекст, код, дані.обʼєкт);
        якщо помилка_компіляції_обʼєкта != пусто {
          вернути помилка_компіляції_обʼєкта;
        }
      }
      змінна ціль па: позитивне = 0;
      змінна ціль кількість_аргументів_без_назви: п32 = 0;
      змінна ціль вже_був_аргумент_з_назвою = ні;
      поки па < дані.кількість_аргументів {
        ціль аргумент = дані.аргументи[па];
        якщо аргумент.ідентифікатор == пусто {
          якщо вже_був_аргумент_з_назвою {
            вернути виділити_помилку_компіляції(елемент.місцезнаходження, ю8"Позиційні аргументи не можна ставити після іменованих");
          }
          кількість_аргументів_без_назви = кількість_аргументів_без_назви + 1;
        } інакше {
          вже_був_аргумент_з_назвою = так;
        }
        па = па + 1;
      }
      змінна ціль має_аргументи_з_назвами = вже_був_аргумент_з_назвою;
      якщо має_аргументи_з_назвами {
        додати_вказівку_до_коду(код, елемент.місцезнаходження.рядок як п32, елемент.місцезнаходження.стовпець як п32, ВПокластиРеєстрАргументів);
      }
      па = 0;
      поки па < дані.кількість_аргументів {
        ціль аргумент = дані.аргументи[па];
        ціль помилка_компіляції_аргумента = скомпілювати_елемент_значення(М, контекст, код, аргумент.значення);
        якщо помилка_компіляції_аргумента != пусто {
          вернути помилка_компіляції_аргумента;
        }
        якщо аргумент.ідентифікатор != пусто {
          ціль назва = знайти_або_виділити_й_додати_назву(М.БН::адреса, аргумент.ідентифікатор.значення);
          ціль позиція_назви = додати_назву_до_коду(код, назва);
          додати_вказівку_до_коду_з_аргументом_п32(код, елемент.місцезнаходження.рядок як п32, елемент.місцезнаходження.стовпець як п32, ВЗареєструватиАргумент, позиція_назви);
        }
        па = па + 1;
      }
      якщо має_аргументи_з_назвами {
        якщо назва_прохання == пусто {
          додати_вказівку_до_коду_з_аргументом_п32(код, елемент.місцезнаходження.рядок як п32, елемент.місцезнаходження.стовпець як п32, ВВиконатиЗНазвами, кількість_аргументів_без_назви);
        } інакше {
          ціль позиція_назви = додати_назву_до_коду(код, назва_прохання);
          додати_вказівку_до_коду_з_двома_аргументами_п32(код, елемент.місцезнаходження.рядок як п32, елемент.місцезнаходження.стовпець як п32, ВПопроситиВиконатиЗНазвами, позиція_назви, кількість_аргументів_без_назви);
        }
      } інакше {
        якщо назва_прохання == пусто {
         додати_вказівку_до_коду_з_аргументом_п32(код, елемент.місцезнаходження.рядок як п32, елемент.місцезнаходження.стовпець як п32, ВВиконати, кількість_аргументів_без_назви);
        } інакше {
          ціль позиція_назви = додати_назву_до_коду(код, назва_прохання);
          додати_вказівку_до_коду_з_двома_аргументами_п32(код, елемент.місцезнаходження.рядок як п32, елемент.місцезнаходження.стовпець як п32, ВПопроситиВиконати, позиція_назви, кількість_аргументів_без_назви);
        }
      }
      вернути пусто;
    } інакше якщо елемент.вид == АСДВидДія {
      ціль дані = елемент.дані як адреса<АСДДаніДія>;
      ціль назва = знайти_або_виділити_й_додати_назву(М.БН::адреса, дані.ідентифікатор.значення);
      ціль позиція_назви = додати_назву_до_коду(код, назва);
      додати_вказівку_до_коду(код, елемент.місцезнаходження.рядок як п32, елемент.місцезнаходження.стовпець як п32, ВПокластиРеєстрПараметрів);
      змінна ціль па: позитивне = 0;
      поки па < дані.кількість_параметрів {
        ціль параметр = дані.параметри[па];
        ціль назва_параметра = знайти_або_виділити_й_додати_назву(М.БН::адреса, параметр.ідентифікатор.значення);
        ціль позиція_назви_параметра = додати_назву_до_коду(код, назва_параметра);
//        ціль помилка_компіляції_типу_параметра = скомпілювати_елемент_значення(М, контекст, код, параметр.тип);
//        якщо помилка_компіляції_типу_параметра != пусто {
//          вернути помилка_компіляції_типу_параметра;
//        }
        додати_вказівку_до_коду_з_двома_аргументами_п32(код, елемент.місцезнаходження.рядок як п32, елемент.місцезнаходження.стовпець як п32, ВЗареєструватиПараметр, позиція_назви_параметра, 0);
        па = па + 1;
      }
      ціль код_дії = виділити_код(код.текст_коду);
      ціль контекст_дії = виділити_контекст_компіляції();
      ціль помилка_компіляції_тіла_дії = скомпілювати_тіло(М, контекст_дії, код_дії, дані.тіло);
      якщо помилка_компіляції_тіла_дії != пусто {
        вернути помилка_компіляції_тіла_дії;
      }
      ціль позиція_підкоду = додати_підкод_до_коду(код, код_дії);
      додати_вказівку_до_коду_з_двома_аргументами_п32(код, елемент.місцезнаходження.рядок як п32, елемент.місцезнаходження.стовпець як п32, ВСтворитиДію, позиція_назви, позиція_підкоду);
      додати_вказівку_до_коду_з_аргументом_п32(код, елемент.місцезнаходження.рядок як п32, елемент.місцезнаходження.стовпець як п32, ВВизначити, позиція_назви);
      вернути пусто;
    } інакше якщо елемент.вид == АСДВидСтруктура {
      ціль дані = елемент.дані як адреса<АСДДаніСтруктура>;
      ціль назва = знайти_або_виділити_й_додати_назву(М.БН::адреса, дані.ідентифікатор.значення);
      ціль позиція_назви = додати_назву_до_коду(код, назва);
      якщо дані.предок == пусто {
        ціль назва = знайти_або_виділити_й_додати_назву(М.БН::адреса, ю8"обʼєкт");
        ціль позиція_назви = додати_назву_до_коду(код, назва);
        додати_вказівку_до_коду_з_аргументом_п32(код, елемент.місцезнаходження.рядок як п32, елемент.місцезнаходження.стовпець як п32, ВЗвернутись, позиція_назви);
      } інакше {
        ціль помилка_компіляції_предка = скомпілювати_елемент_значення(М, контекст, код, дані.предок);
        якщо помилка_компіляції_предка != пусто {
          вернути помилка_компіляції_предка;
        }
      }
      додати_вказівку_до_коду(код, елемент.місцезнаходження.рядок як п32, елемент.місцезнаходження.стовпець як п32, ВПокластиРеєстрПараметрів);
      змінна ціль па: позитивне = 0;
      поки па < дані.кількість_параметрів {
        ціль параметр = дані.параметри[па];
        ціль назва_параметра = знайти_або_виділити_й_додати_назву(М.БН::адреса, параметр.ідентифікатор.значення);
        ціль позиція_назви_параметра = додати_назву_до_коду(код, назва_параметра);
//        ціль помилка_компіляції_типу_параметра = скомпілювати_елемент_значення(М, контекст, код, параметр.тип);
//        якщо помилка_компіляції_типу_параметра != пусто {
//          вернути помилка_компіляції_типу_параметра;
//        }
        додати_вказівку_до_коду_з_двома_аргументами_п32(код, елемент.місцезнаходження.рядок як п32, елемент.місцезнаходження.стовпець як п32, ВЗареєструватиПараметр, позиція_назви_параметра, 0);
        па = па + 1;
      }
      додати_вказівку_до_коду_з_аргументом_п32(код, елемент.місцезнаходження.рядок як п32, елемент.місцезнаходження.стовпець як п32, ВСтворитиСтруктуру, позиція_назви);
      додати_вказівку_до_коду_з_аргументом_п32(код, елемент.місцезнаходження.рядок як п32, елемент.місцезнаходження.стовпець як п32, ВВизначити, позиція_назви);
      вернути пусто;
    } інакше якщо елемент.вид == АСДВидЧисло {
      ціль дані = елемент.дані як адреса<АСДДаніЧисло>;
      ціль результат_розбору_числа = різне::числа::розібрати_дійсне_з_ю8сі<д64>(дані.значення);
      якщо результат_розбору_числа.помилка != пусто {
        надрукувати_ю8(результат_розбору_числа.помилка);
      }
      ціль позиція_числа = додати_число_до_коду(код, результат_розбору_числа.значення);
      додати_вказівку_до_коду_з_аргументом_п32(код, елемент.місцезнаходження.рядок як п32, елемент.місцезнаходження.стовпець як п32, ВПокластиЧисло, позиція_числа);
      вернути пусто;
    } інакше якщо елемент.вид == АСДВидТекст {
      ціль дані = елемент.дані як адреса<АСДДаніТекст>;
      ціль ю32 = перетворити_ю8_на_ю32(дані.значення);
      ціль позиція_тексту = додати_текст_до_коду(код, ю32);
      звільнити(ю32);
      додати_вказівку_до_коду_з_аргументом_п32(код, елемент.місцезнаходження.рядок як п32, елемент.місцезнаходження.стовпець як п32, ВПокластиТекст, позиція_тексту);
      вернути пусто;
    } інакше якщо елемент.вид == АСДВидОперація {
      ціль дані = елемент.дані як адреса<АСДДаніОперація>;
      ціль помилка_компіляції_ліво = скомпілювати_елемент_значення(М, контекст, код, дані.ліво);
      якщо помилка_компіляції_ліво != пусто {
        вернути помилка_компіляції_ліво;
      }
      ціль помилка_компіляції_право = скомпілювати_елемент_значення(М, контекст, код, дані.право);
      якщо помилка_компіляції_право != пусто {
        вернути помилка_компіляції_право;
      }
      якщо дані.операція == АСДОпераціяДодавання {
        додати_вказівку_до_коду(код, елемент.місцезнаходження.рядок як п32, елемент.місцезнаходження.стовпець як п32, ВДодати);
        вернути пусто;
      } інакше {
        вернути виділити_помилку_компіляції(елемент.місцезнаходження, ю8"Невідома операція!");
      }
    } інакше якщо елемент.вид == АСДВидЗначенняЯкщо {
      //
    } інакше якщо елемент.вид == АСДВидЯк {
      //
    } інакше якщо елемент.вид == АСДВидСамоОперація {
      //
    }
    вернути виділити_помилку_компіляції(елемент.місцезнаходження, ю8"Невідомий вид АСДЗначення!");
  }

  місцева дія скомпілювати_тіло(М: адреса<Машина>, контекст: адреса<КонтекстКомпіляції>, код: адреса<Код>, тіло: адреса<СписокАСДЗначень>): адреса<ПомилкаКомпіляції> {
    змінна ціль пе: позитивне = 0;
    поки пе < тіло.довжина {
      ціль елемент = тіло.елементи[пе];
      якщо елемент.вид == АСДВидНіщо {
        вернути виділити_помилку_компіляції(елемент.місцезнаходження, ю8"Виявлено АСДВидНіщо!");
      } інакше якщо елемент.вид == АСДВидВизначити {
        ціль дані = елемент.дані як адреса<АСДДаніВизначити>;
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, дані.значення);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
        ціль назва = знайти_або_виділити_й_додати_назву(М.БН::адреса, дані.ідентифікатор.значення);
        ціль позиція_назви = додати_назву_до_коду(код, назва);
        додати_вказівку_до_коду_з_аргументом_п32(код, елемент.місцезнаходження.рядок як п32, елемент.місцезнаходження.стовпець як п32, ВВизначити, позиція_назви);
      } інакше якщо елемент.вид == АСДВидЗвернутись {
        ціль дані = елемент.дані як адреса<АСДДаніЗвернутись>;
        ціль назва = знайти_або_виділити_й_додати_назву(М.БН::адреса, дані.ідентифікатор.значення);
        ціль позиція_назви = додати_назву_до_коду(код, назва);
        додати_вказівку_до_коду_з_аргументом_п32(код, елемент.місцезнаходження.рядок як п32, елемент.місцезнаходження.стовпець як п32, ВЗвернутись, позиція_назви);
      } інакше якщо елемент.вид == АСДВидОтримати {
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, елемент);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
      } інакше якщо елемент.вид == АСДВидОтриматиЗаПозицією {
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, елемент);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
      } інакше якщо елемент.вид == АСДВидЗмінити {
        ціль дані = елемент.дані як адреса<АСДДаніЗмінити>;
        ціль помилка_компіляції_обʼєкта = скомпілювати_елемент_значення(М, контекст, код, дані.обʼєкт);
        якщо помилка_компіляції_обʼєкта != пусто {
          вернути помилка_компіляції_обʼєкта;
        }
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, дані.значення);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
        ціль назва = знайти_або_виділити_й_додати_назву(М.БН::адреса, дані.ідентифікатор.значення);
        ціль позиція_назви = додати_назву_до_коду(код, назва);
        додати_вказівку_до_коду_з_аргументом_п32(код, елемент.місцезнаходження.рядок як п32, елемент.місцезнаходження.стовпець як п32, ВЗмінити, позиція_назви);
      } інакше якщо елемент.вид == АСДВидЗмінитиЗаПозицією {
        //
      } інакше якщо елемент.вид == АСДВидВиконати {
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, елемент);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
      } інакше якщо елемент.вид == АСДВидДія {
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, елемент);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
      } інакше якщо елемент.вид == АСДВидСтруктура {
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, елемент);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
      } інакше якщо елемент.вид == АСДВидЧисло {
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, елемент);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
      } інакше якщо елемент.вид == АСДВидТекст {
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, елемент);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
      } інакше якщо елемент.вид == АСДВидОперація {
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, елемент);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
      } інакше якщо елемент.вид == АСДВидЯкщо {
        //
      } інакше якщо елемент.вид == АСДВидПоки {
        //
      } інакше якщо елемент.вид == АСДВидВернути {
        //
      } інакше якщо елемент.вид == АСДВидЗначенняЯкщо {
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, елемент);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
      } інакше якщо елемент.вид == АСДВидЯк {
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, елемент);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
      } інакше якщо елемент.вид == АСДВидСамоОперація {
        ціль помилка_компіляції_значення = скомпілювати_елемент_значення(М, контекст, код, елемент);
        якщо помилка_компіляції_значення != пусто {
          вернути помилка_компіляції_значення;
        }
      } інакше якщо елемент.вид == АСДВидВзяти {
        //
      } інакше {
        вернути виділити_помилку_компіляції(елемент.місцезнаходження, ю8"Невідомий вид АСДЗначення!");
      }
      пе = пе + 1;
    }
    вернути пусто;
  }
}