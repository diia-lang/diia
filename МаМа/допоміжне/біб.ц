взяти визначення ./біб;

секція МаМа {
  місцева дія перевірити_чи_ю8_рівні(а: Ю8, б: Ю8): логічне {
    змінна ціль позиція: позитивне = 0;
    поки а[позиція] == б[позиція] {
      якщо а[позиція] == 0 {
        вернути так;
      }
      позиція = позиція + 1;
    }
    вернути ні;
  }

  місцева дія виділити_копію_КД(вхід: памʼять<п8>, розмір_входу: позитивне, вихід: адреса<памʼять<п8>>): логічне {
    ціль копія = виділити<п8>(ц32(розмір_входу) + 1);
    змінна ціль позиція: позитивне = 0;
    поки вхід[позиція] != 0 {
      копія[позиція] = вхід[позиція];
      позиція += 1;
    }
    копія[позиція] = 0;
    вихід[0] = копія;
    вернути так;
  }

  місцева дія виділити_копію_Ю8(вхід: Ю8, розмір_входу: позитивне, вихід: адреса<Ю8>): логічне {
    ціль копія = виділити<п8>(ц32(розмір_входу) + 1);
    змінна ціль позиція: позитивне = 0;
    поки вхід[позиція] != 0 {
      копія[позиція] = вхід[позиція];
      позиція += 1;
    }
    копія[позиція] = 0;
    вихід[0] = копія;
    вернути так;
  }

  місцева дія виділити_копію_Ю32(вхід: Ю32, розмір_входу: позитивне, вихід: адреса<Ю32>): логічне {
    ціль копія = виділити<п32>(ц32(розмір_входу) + 1);
    змінна ціль позиція: позитивне = 0;
    поки вхід[позиція] != 0 {
      копія[позиція] = вхід[позиція];
      позиція += 1;
    }
    копія[позиція] = 0;
    вихід[0] = копія;
    вернути так;
  }

  місцева дія дізнатись_розмір_символа_юнікоду(перший_байт: п8): п8 {
    якщо (перший_байт & 128) == 0 {
      вернути 1;
    }
    якщо (перший_байт & 224) == 192 {
      вернути 2;
    }
    якщо (перший_байт & 240) == 224 {
      вернути 3;
    }
    якщо (перший_байт & 248) == 240 {
      вернути 4;
    }
    вернути 0;
  }

  місцева дія перекодувати_Ю8_в_Ю32(вхід: Ю8, розмір_входу: позитивне, адреса_виходу: адреса<Ю32>): позитивне {
    змінна ціль вихід: Ю32 = виділити<п32>(ц32(розмір_входу) + 1);
    адреса_виходу[0] = вихід;
    змінна ціль розмір_виходу: позитивне = 0;
    змінна ціль х: позитивне = 0;
    поки х < розмір_входу {
      ціль перший_байт = вхід[х];
      ціль розмір_символа = дізнатись_розмір_символа_юнікоду(перший_байт);
      якщо розмір_символа == 1 {
        вихід[розмір_виходу] = п32(перший_байт & 127);
        розмір_виходу = розмір_виходу + 1;
      }
      якщо розмір_символа == 2 {
        ціль другий_байт = вхід[х + 1];
        вихід[розмір_виходу] = (п32(перший_байт & 31) << 6) | п32(другий_байт & 63);
        розмір_виходу = розмір_виходу + 1;
        х = х + 1;
      }
      якщо розмір_символа == 3 {
        ціль другий_байт = вхід[х + 1];
        ціль третій_байт = вхід[х + 2];
        вихід[розмір_виходу] = (п32(перший_байт & 15) << 12) | (п32(другий_байт & 63) << 6) | п32(третій_байт & 63);
        розмір_виходу = розмір_виходу + 1;
        х = х + 2;
      }
      якщо розмір_символа == 4 {
        ціль другий_байт = вхід[х + 1];
        ціль третій_байт = вхід[х + 2];
        ціль четвертий_байт = вхід[х + 3];
        вихід[розмір_виходу] = (п32(перший_байт & 15) << 18) | (п32(другий_байт & 63) << 12) | (п32(третій_байт & 63) << 6) | п32(четвертий_байт & 63);
        розмір_виходу = розмір_виходу + 1;
        х = х + 3;
      }
      х = х + 1;
    }
    вихід[розмір_виходу] = 0;
    вихід = перевиділити<п32>(вихід, ц32(розмір_виходу) + 1);
    вернути розмір_виходу;
  }
}