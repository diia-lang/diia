зовнішня дія mavka_sysext_malloc(size: ц32): адреса;
зовнішня дія mavka_sysext_free(ptr: адреса);
зовнішня дія mavka_sysext_realloc(ptr: адреса, size: ц32): адреса;
зовнішня дія mavka_sysext_putchar(value: п8): ц32;

синонім памʼять<Т> = адреса<Т>;

дія виділити<Т>(): адреса<Т>;
дія виділити<Т>(кількість: ц32): памʼять<Т>;
дія перевиділити<Т>(значення: адреса<Т>, кількість: ц32): памʼять<Т>;
дія звільнити(значення: адреса);

дія виділити<Т>(): адреса<Т> {
  вернути mavka_sysext_malloc(Т.розмір) як адреса<Т>;
}

дія виділити<Т>(кількість: ц32): памʼять<Т> {
  вернути mavka_sysext_malloc(кількість * Т.розмір) як памʼять<Т>;
}

дія перевиділити<Т>(значення: адреса<Т>, кількість: ц32): памʼять<Т> {
  вернути mavka_sysext_realloc(значення, кількість * Т.розмір) як памʼять<Т>;
}

дія звільнити(значення: адреса) {
  mavka_sysext_free(значення);
}

синонім Ю8 = памʼять<п8>;
синонім Ю16 = памʼять<п16>;
синонім Ю32 = памʼять<п32>;

зовнішня дія перетворити_ю32_в_ю8(вхід: Ю32): Ю8;

дія вивести_ю8(значення: Ю8) {
  змінна ціль х: позитивне = 0;
  поки (значення[х] != 0) {
    mavka_sysext_putchar(значення[х]);
    х = х + 1;
  }
}

дія вивести_ю32(значення: Ю32) {
  ціль ю8 = перетворити_ю32_в_ю8(значення);
  вивести_ю8(ю8);
  звільнити(ю8);
}

дія надрукувати_ю8(значення: Ю8) {
  вивести_ю8(значення);
  mavka_sysext_putchar(10п8);
}

дія надрукувати_ю32(значення: Ю32) {
  вивести_ю32(значення);
  mavka_sysext_putchar(10п8);
}

дія перетворити_п64_в_ю8(значення: п64): Ю8 {
  змінна ціль буфер = виділити<п8>(21);
  змінна ціль індекс: ц32 = 20;
  буфер[20] = 0;
  поки (значення > 0) {
    індекс = індекс - 1;
    буфер[індекс] = (значення % 10) як п8 + 48;
    значення = значення / 10;
  }
  якщо (індекс == 20) {
    індекс = індекс - 1;
    буфер[індекс] = 48;
  }
  ціль результуючий_буфер = виділити<п8>(21ц32 - індекс);
  змінна ціль х: ц32 = 0;
  поки (індекс < 21) {
    результуючий_буфер[х] = буфер[індекс];
    х = х + 1;
    індекс = індекс + 1;
  }
  звільнити(буфер);
  вернути результуючий_буфер;
}

дія перетворити_д64_в_ю8(значення: д64): Ю8 {
  вернути перетворити_п64_в_ю8(значення як п64); // потім: пофіксати
}

дія вивести_п64(значення: п64) {
  ціль п64ю8 = перетворити_п64_в_ю8(значення);
  вивести_ю8(п64ю8);
  звільнити(п64ю8);
}

дія надрукувати_п64(значення: п64) {
  ціль п64ю8 = перетворити_п64_в_ю8(значення);
  надрукувати_ю8(п64ю8);
  звільнити(п64ю8);
}

дія вивести_д64(значення: д64) {
  ціль д64ю8 = перетворити_д64_в_ю8(значення);
  вивести_ю8(д64ю8);
  звільнити(д64ю8);
}

дія надрукувати_д64(значення: д64) {
  ціль д64ю8 = перетворити_д64_в_ю8(значення);
  надрукувати_ю8(д64ю8);
  звільнити(д64ю8);
}

дія fmod(a: д64, b: д64): д64 {
  вернути a - (a / b) * b;
}

дія перевірити_чи_ю8_рівні(а: Ю8, б: Ю8): логічне {
  змінна ціль позиція: позитивне = 0;
  поки а[позиція] == б[позиція] {
    якщо а[позиція] == 0 {
      вернути так;
    }
    позиція = позиція + 1;
  }
  вернути ні;
}

дія виділити_копію_ю8(вихідна: Ю8): Ю8 {
  змінна ціль довжина: позитивне = 0;
  поки вихідна[довжина] != 0 {
    довжина = довжина + 1;
  }
  ціль копія = виділити<п8>(довжина як ц32 + 1);
  змінна ціль позиція: позитивне = 0;
  поки вихідна[позиція] != 0 {
    копія[позиція] = вихідна[позиція];
    позиція = позиція + 1;
  }
  копія[позиція] = 0;
  вернути копія;
}

дія виділити_копію_ю32(вихідна: Ю32): Ю32 {
  змінна ціль довжина: позитивне = 0;
  поки вихідна[довжина] != 0 {
    довжина = довжина + 1;
  }
  ціль копія = виділити<п32>(довжина як ц32 + 1);
  змінна ціль позиція: позитивне = 0;
  поки вихідна[позиція] != 0 {
    копія[позиція] = вихідна[позиція];
    позиція = позиція + 1;
  }
  копія[позиція] = 0;
  вернути копія;
}

дія дізнатись_розмір_символа_юнікоду(перший_байт: п8): п8 {
  якщо (перший_байт & 0ш80) == 0ш00 {
    вернути 1;
  }
  якщо (перший_байт & 0шҐ0) == 0шВ0 {
    вернути 2;
  }
  якщо (перший_байт & 0шД0) == 0шҐ0 {
    вернути 3;
  }
  якщо (перший_байт & 0шД8) == 0шД0 {
    вернути 4;
  }
  вернути 0;
}

дія перетворити_ю8_на_ю32(вхід: Ю8): Ю32 {
  змінна ціль розмір_входу: позитивне = 0;
  поки вхід[розмір_входу] != 0 {
    розмір_входу = розмір_входу + 1;
  }
  змінна ціль вихід: Ю32 = виділити<п32>(розмір_входу як ц32);
  змінна ціль розмір_виходу: позитивне = 0;
  змінна ціль х: позитивне = 0;
  поки х < розмір_входу {
    ціль перший_байт = вхід[х];
    ціль розмір_символа = дізнатись_розмір_символа_юнікоду(перший_байт);
    якщо розмір_символа == 1 {
      вихід[розмір_виходу] = п32(перший_байт & 0ш7Д);
      розмір_виходу = розмір_виходу + 1;
    }
    якщо розмір_символа == 2 {
      ціль другий_байт = вхід[х + 1];
      вихід[розмір_виходу] = (п32(перший_байт & 0ш1Д) << 6) | п32(другий_байт & 0ш3Д);
      розмір_виходу = розмір_виходу + 1;
      х = х + 1;
    }
    якщо розмір_символа == 3 {
      ціль другий_байт = вхід[х + 1];
      ціль третій_байт = вхід[х + 2];
      вихід[розмір_виходу] = (п32(перший_байт & 0ш0Д) << 12) | (п32(другий_байт & 0ш3Д) << 6) | п32(третій_байт & 0ш3Д);
      розмір_виходу = розмір_виходу + 1;
      х = х + 2;
    }
    якщо розмір_символа == 4 {
      ціль другий_байт = вхід[х + 1];
      ціль третій_байт = вхід[х + 2];
      ціль четвертий_байт = вхід[х + 3];
      вихід[розмір_виходу] = (п32(перший_байт & 0ш0Д) << 18) | (п32(другий_байт & 0ш3Д) << 12) | (п32(третій_байт & 0ш3Д) << 6) | п32(четвертий_байт & 0ш3Д);
      розмір_виходу = розмір_виходу + 1;
      х = х + 3;
    }
    х = х + 1;
  }
  вихід[розмір_виходу] = 0;
  вернути вихід;
}
