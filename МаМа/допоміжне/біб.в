////
// Автор це Богданович Давид Когут Прихожденко та Організація Мавки та Організація Організацій
////

зовнішня дія malloc(size: size_t): адреса;
зовнішня дія free(ptr: адреса);
зовнішня дія realloc(ptr: адреса, size: size_t): адреса;
зовнішня дія strcmp(str1: адреса<п8>, str2: адреса<п8>): int;
зовнішня дія strcmp32(str1: адреса<п32>, str2: адреса<п32>): int;
зовнішня дія strlen(str: адреса<п8>): int;
зовнішня дія strlen32(str: адреса<п32>): int;
зовнішня дія exit(status: int);
зовнішня дія mama_convert_utf32_to_utf8(input: адреса<unsigned_int>): адреса<unsigned_char>;
зовнішня дія mama_print_utf8(value: адреса<unsigned_char>);
зовнішня дія mama_println_utf8(value: адреса<unsigned_char>);

синонім памʼять<Т> = адреса<Т>;

дія виділити<Т>(): адреса<Т>;
дія виділити<Т>(кількість: ц32): памʼять<Т>;
дія перевиділити<Т>(значення: адреса<Т>, кількість: ц32): памʼять<Т>;
дія звільнити(значення: адреса);

дія виділити<Т>(): адреса<Т> {
  вернути malloc(Т.розмір як size_t) як адреса<Т>;
}

дія виділити<Т>(кількість: ц32): памʼять<Т> {
  вернути malloc(кількість як size_t * Т.розмір) як памʼять<Т>;
}

дія перевиділити<Т>(значення: адреса<Т>, кількість: ц32): памʼять<Т> {
  вернути realloc(значення, кількість як size_t * Т.розмір) як памʼять<Т>;
}

дія звільнити(значення: адреса) {
  free(значення);
}

синонім Ю8 = памʼять<п8>;
синонім Ю16 = памʼять<п16>;
синонім Ю32 = памʼять<п32>;

дія перетворити_ю32_в_ю8(вхід: Ю32): Ю8 {
  вернути mama_convert_utf32_to_utf8(вхід);
}

дія вивести_ю8(значення: Ю8) {
  mama_print_utf8(значення);
}

дія надрукувати_ю8(значення: Ю8) {
  mama_println_utf8(значення);
}

дія ПОМЕРТИ(повідомлення: Ю8) {
  вивести_ю8(ю8"ПРИЧИНА СМЕТРІ: ");
  надрукувати_ю8(повідомлення);
  exit(1);
}

дія перетворити_п64_в_ю8(значення: п64): Ю8 {
  змінна ціль буфер = виділити<п8>(21);
  змінна ціль індекс: ц32 = 20;
  буфер[20] = 0;
  поки (значення > 0) {
    індекс = індекс - 1;
    буфер[індекс] = (значення % 10) як п8 + 48;
    значення = значення / 10;
  }
  якщо (індекс == 20) {
    індекс = індекс - 1;
    буфер[індекс] = 48;
  }
  ціль результуючий_буфер = виділити<п8>(21ц32 - індекс);
  змінна ціль х: ц32 = 0;
  поки (індекс < 21) {
    результуючий_буфер[х] = буфер[індекс];
    х = х + 1;
    індекс = індекс + 1;
  }
  звільнити(буфер);
  вернути результуючий_буфер;
}

дія перетворити_д64_в_ю8(значення: д64): Ю8 {
  вернути перетворити_п64_в_ю8(значення як п64); // потім: пофіксати
}

дія вивести_п64(значення: п64) {
  ціль п64ю8 = перетворити_п64_в_ю8(значення);
  вивести_ю8(п64ю8);
  звільнити(п64ю8);
}

дія надрукувати_п64(значення: п64) {
  ціль п64ю8 = перетворити_п64_в_ю8(значення);
  надрукувати_ю8(п64ю8);
  звільнити(п64ю8);
}

дія вивести_д64(значення: д64) {
  ціль д64ю8 = перетворити_д64_в_ю8(значення);
  вивести_ю8(д64ю8);
  звільнити(д64ю8);
}

дія надрукувати_д64(значення: д64) {
  ціль д64ю8 = перетворити_д64_в_ю8(значення);
  надрукувати_ю8(д64ю8);
  звільнити(д64ю8);
}

дія fmod(a: д64, b: д64): д64 {
  вернути a - (a / b) * b;
}

дія перевірити_чи_ю8_рівні(а: Ю8, б: Ю8): логічне {
  змінна ціль позиція: позитивне = 0;
  поки а[позиція] == б[позиція] {
    якщо а[позиція] == 0 {
      вернути так;
    }
    позиція = позиція + 1;
  }
  вернути ні;
}

дія виділити_копію_ю8(вихідна: Ю8): Ю8 {
  змінна ціль довжина: позитивне = 0;
  поки вихідна[довжина] != 0 {
    довжина = довжина + 1;
  }
  ціль копія = виділити<п8>(довжина як ц32 + 1);
  змінна ціль позиція: позитивне = 0;
  поки вихідна[позиція] != 0 {
    копія[позиція] = вихідна[позиція];
    позиція = позиція + 1;
  }
  копія[позиція] = 0;
  вернути копія;
}

дія виділити_копію_ю32(вихідна: Ю32): Ю32 {
  змінна ціль довжина: позитивне = 0;
  поки вихідна[довжина] != 0 {
    довжина = довжина + 1;
  }
  ціль копія = виділити<п32>(довжина як ц32 + 1);
  змінна ціль позиція: позитивне = 0;
  поки вихідна[позиція] != 0 {
    копія[позиція] = вихідна[позиція];
    позиція = позиція + 1;
  }
  копія[позиція] = 0;
  вернути копія;
}

дія дізнатись_розмір_символа_юнікоду(перший_байт: п8): п8 {
  якщо (перший_байт & 128) == 0 {
    вернути 1;
  }
  якщо (перший_байт & 224) == 192 {
    вернути 2;
  }
  якщо (перший_байт & 240) == 224 {
    вернути 3;
  }
  якщо (перший_байт & 248) == 240 {
    вернути 4;
  }
  вернути 0;
}

дія перетворити_ю8_на_ю32(вхід: Ю8): Ю32 {
  змінна ціль розмір_входу: позитивне = 0;
  поки вхід[розмір_входу] != 0 {
    розмір_входу = розмір_входу + 1;
  }
  змінна ціль вихід: Ю32 = виділити<п32>(розмір_входу як ц32);
  змінна ціль розмір_виходу: позитивне = 0;
  змінна ціль х: позитивне = 0;
  поки х < розмір_входу {
    ціль перший_байт = вхід[х];
    ціль розмір_символа = дізнатись_розмір_символа_юнікоду(перший_байт);
    якщо розмір_символа == 1 {
      вихід[розмір_виходу] = п32(перший_байт & 127);
      розмір_виходу = розмір_виходу + 1;
    }
    якщо розмір_символа == 2 {
      ціль другий_байт = вхід[х + 1];
      вихід[розмір_виходу] = (п32(перший_байт & 31) << 6) | п32(другий_байт & 63);
      розмір_виходу = розмір_виходу + 1;
      х = х + 1;
    }
    якщо розмір_символа == 3 {
      ціль другий_байт = вхід[х + 1];
      ціль третій_байт = вхід[х + 2];
      вихід[розмір_виходу] = (п32(перший_байт & 15) << 12) | (п32(другий_байт & 63) << 6) | п32(третій_байт & 63);
      розмір_виходу = розмір_виходу + 1;
      х = х + 2;
    }
    якщо розмір_символа == 4 {
      ціль другий_байт = вхід[х + 1];
      ціль третій_байт = вхід[х + 2];
      ціль четвертий_байт = вхід[х + 3];
      вихід[розмір_виходу] = (п32(перший_байт & 15) << 18) | (п32(другий_байт & 63) << 12) | (п32(третій_байт & 63) << 6) | п32(четвертий_байт & 63);
      розмір_виходу = розмір_виходу + 1;
      х = х + 3;
    }
    х = х + 1;
  }
  вихід[розмір_виходу] = 0;
  вернути вихід;
}
