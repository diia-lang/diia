////
// Автор це Богданович Давид Когут Прихожденко та Організація Мавки та Організація Організацій
////

зовнішня дія mama_malloc(size: size_t): адреса;
зовнішня дія mama_free(ptr: адреса);
зовнішня дія mama_realloc(ptr: адреса, size: size_t): адреса;
зовнішня дія mama_strcmp(str1: адреса<п8>, str2: адреса<п8>): int;
зовнішня дія mama_strcmp32(str1: адреса<п32>, str2: адреса<п32>): int;
зовнішня дія mama_exit(status: int);
зовнішня дія mama_floor(value: double): double;
зовнішня дія mama_pow(base: double, exponent: double): double;
зовнішня дія mama_convert_utf32_to_utf8(input: адреса<unsigned_int>): адреса<unsigned_char>;
зовнішня дія mama_print_utf8(value: адреса<unsigned_char>);
зовнішня дія mama_println_utf8(value: адреса<unsigned_char>);
зовнішня дія mama_bitnot(value: unsigned_long): unsigned_long;
зовнішня дія mama_negate(value: double): double;

секція МаМа {
  синонім памʼять = адреса;

  дія виділити<Т>(): адреса<Т>;
  дія виділити<Т>(кількість: ц32): памʼять<Т>;
  дія перевиділити<Т>(значення: адреса<Т>, кількість: ц32): памʼять<Т>;
  дія звільнити(значення: адреса);

  дія виділити<Т>(): адреса<Т> {
    вернути mama_malloc(Т.розмір як size_t) як адреса<Т>;
  }

  дія виділити<Т>(кількість: ц32): памʼять<Т> {
    вернути mama_malloc(кількість як size_t * Т.розмір) як памʼять<Т>;
  }

  дія перевиділити<Т>(значення: адреса<Т>, кількість: ц32): памʼять<Т> {
    вернути mama_realloc(значення, кількість як size_t * Т.розмір) як памʼять<Т>;
  }

  дія звільнити(значення: адреса) {
    mama_free(значення);
  }

  дія порахувати_розмір_КД(значення: адреса<п8>): позитивне {
    змінна ціль довжина: позитивне = 0;
    поки значення[довжина] != 0 {
      довжина += 1;
    }
    вернути довжина;
  }

  дія порахувати_розмір_Ю8(значення: адреса<п8>): позитивне {
    змінна ціль довжина: позитивне = 0;
    поки значення[довжина] != 0 {
      довжина += 1;
    }
    вернути довжина;
  }

  дія порахувати_розмір_Ю32(значення: адреса<п32>): позитивне {
    змінна ціль довжина: позитивне = 0;
    поки значення[довжина] != 0 {
      довжина += 1;
    }
    вернути довжина;
  }

  синонім Ю8 = памʼять<п8>;
  синонім Ю16 = памʼять<п16>;
  синонім Ю32 = памʼять<п32>;

  дія перетворити_ю32_в_ю8(вхід: Ю32): Ю8 {
    вернути mama_convert_utf32_to_utf8(вхід);
  }

  дія вивести_ю8(значення: Ю8) {
    mama_print_utf8(значення);
  }

  дія надрукувати_ю8(значення: Ю8) {
    mama_println_utf8(значення);
  }

  дія ПОМЕРТИ(повідомлення: Ю8) {
    вивести_ю8(ю8"ПРИЧИНА СМЕРТІ: ");
    надрукувати_ю8(повідомлення);
    mama_exit(1);
  }

  дія перетворити_п64_в_ю8(значення: п64): Ю8 {
    змінна ціль буфер = виділити<п8>(21);
    змінна ціль індекс: ц32 = 20;
    буфер[20] = 0;
    поки (значення > 0) {
      індекс = індекс - 1;
      буфер[індекс] = п8(значення % 10) + 48;
      значення = значення / 10;
    }
    якщо (індекс == 20) {
      індекс = індекс - 1;
      буфер[індекс] = 48;
    }
    ціль результуючий_буфер = виділити<п8>(21ц32 - індекс);
    змінна ціль х: ц32 = 0;
    поки (індекс < 21) {
      результуючий_буфер[х] = буфер[індекс];
      х = х + 1;
      індекс = індекс + 1;
    }
    звільнити(буфер);
    вернути результуючий_буфер;
  }

  дія перетворити_д64_в_ю8(значення: д64): Ю8 {
    вернути перетворити_п64_в_ю8(п64(значення)); // потім: пофіксати
  }

  дія вивести_п64(значення: п64) {
    ціль п64ю8 = перетворити_п64_в_ю8(значення);
    вивести_ю8(п64ю8);
    звільнити(п64ю8);
  }

  дія надрукувати_п64(значення: п64) {
    ціль п64ю8 = перетворити_п64_в_ю8(значення);
    надрукувати_ю8(п64ю8);
    звільнити(п64ю8);
  }

  дія вивести_д64(значення: д64) {
    ціль д64ю8 = перетворити_д64_в_ю8(значення);
    вивести_ю8(д64ю8);
    звільнити(д64ю8);
  }

  дія надрукувати_д64(значення: д64) {
    ціль д64ю8 = перетворити_д64_в_ю8(значення);
    надрукувати_ю8(д64ю8);
    звільнити(д64ю8);
  }

  дія fmod(a: д64, b: д64): д64 {
    вернути a - (a / b) * b;
  }

  дія перевірити_чи_ю8_рівні(а: Ю8, б: Ю8): логічне {
    змінна ціль позиція: позитивне = 0;
    поки а[позиція] == б[позиція] {
      якщо а[позиція] == 0 {
        вернути так;
      }
      позиція = позиція + 1;
    }
    вернути ні;
  }

  дія виділити_копію_ю8(вихідна: Ю8): Ю8 {
    змінна ціль довжина: позитивне = 0;
    поки вихідна[довжина] != 0 {
      довжина = довжина + 1;
    }
    ціль копія = виділити<п8>(ц32(довжина) + 1);
    змінна ціль позиція: позитивне = 0;
    поки вихідна[позиція] != 0 {
      копія[позиція] = вихідна[позиція];
      позиція = позиція + 1;
    }
    копія[позиція] = 0;
    вернути копія;
  }

  дія виділити_копію_Ю32(вхід: Ю32, вихід: адреса<Ю32>): логічне {
    змінна ціль довжина: позитивне = порахувати_розмір_Ю32(вхід);
    ціль копія = виділити<п32>(ц32(довжина) + 1);
    змінна ціль позиція: позитивне = 0;
    поки вхід[позиція] != 0 {
      копія[позиція] = вхід[позиція];
      позиція += 1;
    }
    копія[позиція] = 0;
    вихід[0] = копія;
    вернути так;
  }

  дія дізнатись_розмір_символа_юнікоду(перший_байт: п8): п8 {
    якщо (перший_байт & 128) == 0 {
      вернути 1;
    }
    якщо (перший_байт & 224) == 192 {
      вернути 2;
    }
    якщо (перший_байт & 240) == 224 {
      вернути 3;
    }
    якщо (перший_байт & 248) == 240 {
      вернути 4;
    }
    вернути 0;
  }

  дія перекодувати_Ю8_в_Ю32(вхід: Ю8, адреса_виходу: адреса<Ю32>): позитивне {
    змінна ціль розмір_входу = порахувати_розмір_Ю8(вхід);
    змінна ціль вихід: Ю32 = виділити<п32>(ц32(розмір_входу) + 1);
    адреса_виходу[0] = вихід;
    змінна ціль розмір_виходу: позитивне = 0;
    змінна ціль х: позитивне = 0;
    поки х < розмір_входу {
      ціль перший_байт = вхід[х];
      ціль розмір_символа = дізнатись_розмір_символа_юнікоду(перший_байт);
      якщо розмір_символа == 1 {
        вихід[розмір_виходу] = п32(перший_байт & 127);
        розмір_виходу = розмір_виходу + 1;
      }
      якщо розмір_символа == 2 {
        ціль другий_байт = вхід[х + 1];
        вихід[розмір_виходу] = (п32(перший_байт & 31) << 6) | п32(другий_байт & 63);
        розмір_виходу = розмір_виходу + 1;
        х = х + 1;
      }
      якщо розмір_символа == 3 {
        ціль другий_байт = вхід[х + 1];
        ціль третій_байт = вхід[х + 2];
        вихід[розмір_виходу] = (п32(перший_байт & 15) << 12) | (п32(другий_байт & 63) << 6) | п32(третій_байт & 63);
        розмір_виходу = розмір_виходу + 1;
        х = х + 2;
      }
      якщо розмір_символа == 4 {
        ціль другий_байт = вхід[х + 1];
        ціль третій_байт = вхід[х + 2];
        ціль четвертий_байт = вхід[х + 3];
        вихід[розмір_виходу] = (п32(перший_байт & 15) << 18) | (п32(другий_байт & 63) << 12) | (п32(третій_байт & 63) << 6) | п32(четвертий_байт & 63);
        розмір_виходу = розмір_виходу + 1;
        х = х + 3;
      }
      х = х + 1;
    }
    вихід[розмір_виходу] = 0;
    вихід = перевиділити<п32>(вихід, ц32(розмір_виходу) + 1);
    вернути розмір_виходу;
  }
}